import{ae as D,c as d,W as l,af as N,S as T,ag as M,ah as x,ai as W,aj as k,ak as B,al as j,d as u,p as K,J as q,q as F,am as S,an as Y,ao as z,n as G,_ as h,C as H,a as U,b as L,l as J}from"./index-DBeR5MVK.js";import{c as V,a as X,b as g}from"./solanaRpcMiddlewares-CNwm08_e.js";class $ extends D{async init(e){}async getIdentityToken(){if(!this.provider||this.status!==d.CONNECTED)throw l.notConnectedError();if(!this.coreOptions)throw N.invalidParams("Please initialize Web3Auth with a valid options");const e=await this.provider.request({method:T.GET_ACCOUNTS});if(e&&e.length>0){const n=M(e[0],this.name);if(n&&!x(n))return{idToken:n};const a=await this.provider.request({method:"solana_chainId"}),s=this.coreOptions.chains.find(c=>c.chainId===a);if(!s)throw N.invalidParams("chainConfig is required before authentication");const{chainNamespace:i}=s,y={domain:window.location.origin,uri:window.location.href,address:e[0],chainId:parseInt(a,16),version:"1",nonce:Math.random().toString(36).slice(2),issuedAt:new Date().toISOString()},f=await W(y,i),r=await this.provider.request({method:T.SIGN_MESSAGE,params:{data:f,display:"utf8"}}),o=await k(i,r,f,this.name,this.coreOptions.sessionTime,this.coreOptions.clientId,this.coreOptions.web3AuthNetwork);return B(e[0],this.name,o),{idToken:o}}throw l.notConnectedError("Not connected with wallet, Please login/connect first")}async disconnectSession(){super.checkDisconnectionRequirements();const e=await this.provider.request({method:T.GET_ACCOUNTS});e&&e.length>0&&j(e[0],this.name)}async disconnect(){this.rehydrated=!1,this.emit(u.DISCONNECTED)}}var Q=function(t,e,n,a){if(n==="a"&&!a)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?t!==e||!a:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return n==="m"?a:n==="a"?a.call(t):a?a.value:e.get(t)},Z=function(t,e,n,a,s){if(a==="m")throw new TypeError("Private method is not writable");if(a==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?t!==e||!s:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return a==="a"?s.call(t,n):s?s.value=n:e.set(t,n),n},E;let w;const C=new Set;function ee(t){m=void 0,C.add(t)}function ne(t){m=void 0,C.delete(t)}const p={};function ue(){if(w||(w=Object.freeze({register:O,get:te,on:ae}),typeof window>"u"))return w;const t=Object.freeze({register:O});try{window.addEventListener("wallet-standard:register-wallet",({detail:e})=>e(t))}catch(e){console.error(`wallet-standard:register-wallet event listener could not be added
`,e)}try{window.dispatchEvent(new se(t))}catch(e){console.error(`wallet-standard:app-ready event could not be dispatched
`,e)}return w}function O(...t){var e;return t=t.filter(n=>!C.has(n)),t.length?(t.forEach(n=>ee(n)),(e=p.register)==null||e.forEach(n=>b(()=>n(...t))),function(){var a;t.forEach(s=>ne(s)),(a=p.unregister)==null||a.forEach(s=>b(()=>s(...t)))}):()=>{}}let m;function te(){return m||(m=[...C]),m}function ae(t,e){var n;return(n=p[t])!=null&&n.push(e)||(p[t]=[e]),function(){var s;p[t]=(s=p[t])==null?void 0:s.filter(i=>e!==i)}}function b(t){try{t()}catch(e){console.error(e)}}class se extends Event{get detail(){return Q(this,E,"f")}get type(){return"wallet-standard:app-ready"}constructor(e){super("wallet-standard:app-ready",{bubbles:!1,cancelable:!1,composed:!1}),E.set(this,void 0),Z(this,E,e,"f")}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}}E=new WeakMap;const P="solana:signAndSendTransaction",R="solana:signMessage",A="solana:signTransaction",_="standard:connect",re="standard:disconnect";class ie extends K{constructor({config:e,state:n}){super({config:e,state:n})}async switchChain(e){throw l.unsupportedOperation("Chain switching is not supported by this connector")}async setupProvider(e,n){const a=new q,s=this.getChain(n),i=this.getProviderHandlers(e),y=V(i);a.push(y);const f=X(s);a.push(f);const r=this.getInjectedProviderProxy(e);r&&a.push(r);const o=F(a);this.updateProviderEngineProxy(o),await this.lookupNetwork(e,n)}async lookupNetwork(e,n){return this.update({chainId:n}),n||""}getInjectedProviderProxy(e){}}const oe=t=>({requestAccounts:async()=>t.publicKey?[g.encode(t.publicKey.toBytes())]:[],getPublicKey:async()=>t.publicKey?g.encode(t.publicKey.toBytes()):"",getAccounts:async()=>t.publicKey?[g.encode(t.publicKey.toBytes())]:[],getPrivateKey:async()=>{throw S.methodNotSupported()},getSecretKey:async()=>{throw S.methodNotSupported()},signTransaction:async n=>await t.signTransaction(n.params.message),signMessage:async n=>await t.signMessage(n.params.data,n.params.from,n.params.display),signAllTransactions:async n=>{var a,s;if(!((a=n.params)!==null&&a!==void 0&&a.message)||!((s=n.params)!==null&&s!==void 0&&s.message.length))throw S.invalidParams("message");return await t.signAllTransactions(n.params.message)},signAndSendTransaction:async n=>await t.signAndSendTransaction(n.params.message)}),I=t=>{switch(t.chainId){case"0x65":return"solana:mainnet";case"0x66":return"solana:testnet";case"0x67":return"solana:devnet";default:return null}};class ce extends ie{getProviderHandlers(e){const n=I(this.config.chain),a=()=>{const r=e==null?void 0:e.accounts[0];if(!r)throw l.notConnectedError();return r};return oe({get publicKey(){return new Y(a().publicKey)},signMessage:async r=>{const o=a(),c=new Uint8Array(Buffer.from(r,"utf-8")),v=await e.features[R].signMessage({account:o,message:c});return g.encode(v[0].signature)},signTransaction:async r=>{const o=a(),c=await e.features[A].signTransaction({account:o,transaction:new Uint8Array(Buffer.from(r,"base64")),chain:n});return g.encode(z.deserialize(c[0].signedTransaction).signatures[0])},signAllTransactions:async r=>{const o=a();return Promise.all(r.map(async c=>{const v=await e.features[A].signTransaction({account:o,transaction:new Uint8Array(Buffer.from(c,"base64")),chain:n});return Buffer.from(v[0].signedTransaction).toString("base64")}))},signAndSendTransaction:async r=>{const o=a(),c=await e.features[P].signAndSendTransaction({account:o,transaction:new Uint8Array(Buffer.from(r,"base64")),chain:n});return g.encode(c[0].signature)}})}}class de extends ${constructor(e){super(e),h(this,"name",void 0),h(this,"connectorNamespace",H.SOLANA),h(this,"currentChainNamespace",U.SOLANA),h(this,"type",L.EXTERNAL),h(this,"isInjected",!0),h(this,"status",d.NOT_READY),h(this,"wallet",null),h(this,"injectedProvider",null),this.name=e.name,this.icon=e.wallet.icon,this.wallet=["gate","solflare"].includes(this.name)?Object.freeze(e.wallet):e.wallet}get provider(){return this.status!==d.NOT_READY&&this.injectedProvider?this.injectedProvider:null}get isWalletConnected(){return this.status===d.CONNECTED&&this.wallet.accounts.length>0}async init(e){await super.init(e);const n=this.coreOptions.chains.find(a=>a.chainId===e.chainId);super.checkInitializationRequirements({chainConfig:n}),this.injectedProvider=new ce({config:{chain:n,chains:this.coreOptions.chains}}),await this.injectedProvider.setupProvider(this.wallet,e.chainId),this.status=d.READY,this.emit(u.READY,this.name);try{if(J.debug("initializing solana injected connector"),e.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:e.chainId})))throw this.rehydrated=!1,l.connectionError("Failed to rehydrate.")}catch(a){this.emit(u.REHYDRATION_ERROR,a)}}async connect({chainId:e}){try{super.checkConnectionRequirements();const n=this.coreOptions.chains.find(s=>s.chainId===e);if(!n)throw l.connectionError("Chain config is not available");this.status=d.CONNECTING,this.emit(u.CONNECTING,{connector:this.name});const a=I(n);if(!this.wallet.chains.find(s=>s===a))throw l.connectionError(`Chain ${a} not supported. Supported chains are ${this.wallet.chains.join(", ")}`);if(this.isWalletConnected||await this.wallet.features[_].connect(),this.wallet.accounts.length===0)throw l.connectionError();return this.status=d.CONNECTED,this.emit(u.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.provider}),this.provider}catch(n){throw this.status=d.READY,this.rehydrated||this.emit(u.ERRORED,n),this.rehydrated=!1,n}}async disconnect(e={cleanup:!1}){await super.disconnectSession();try{var n;await((n=this.wallet.features[re])===null||n===void 0?void 0:n.disconnect()),e.cleanup?(this.status=d.NOT_READY,this.injectedProvider=null):this.status=d.READY,await super.disconnect()}catch(a){this.emit(u.ERRORED,l.disconnectionError(a==null?void 0:a.message))}}async getUserInfo(){if(!this.isWalletConnected)throw l.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async switchChain(e,n=!1){var a;super.checkSwitchChainRequirements(e,n),await((a=this.injectedProvider)===null||a===void 0?void 0:a.switchChain(e))}async enableMFA(){throw new Error("Method not implemented.")}async manageMFA(){throw new Error("Method Not implemented")}}const pe=t=>({coreOptions:e})=>new de({name:G(t.name),wallet:t,coreOptions:e}),ge=t=>{const{chains:e,features:n}=t;return e.some(i=>i.startsWith("solana"))?!![_,R,A,P].every(i=>Object.keys(n).includes(i)):void 0};export{ue as createSolanaMipd,ge as hasSolanaWalletStandardFeatures,pe as walletStandardConnector};
