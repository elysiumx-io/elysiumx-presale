{
  "version": 3,
  "sources": ["../../@web3auth/no-modal/dist/lib.esm/connectors/base-evm-connector/baseEvmConnector.js", "../../@web3auth/no-modal/dist/lib.esm/connectors/injected-evm-connector/injectedEvmConnector.js"],
  "sourcesContent": ["import { signChallenge, verifySignedChallenge } from '@toruslabs/base-controllers';\nimport { EVM_METHOD_TYPES } from '@web3auth/ws-embed';\nimport { getSavedToken, checkIfTokenIsExpired, saveToken, clearToken } from '../../base/connector/utils.js';\nimport { BaseConnector } from '../../base/connector/baseConnector.js';\nimport { CONNECTOR_STATUS, CONNECTOR_EVENTS } from '../../base/connector/constants.js';\nimport { WalletLoginError, WalletInitializationError } from '../../base/errors/index.js';\n\nclass BaseEvmConnector extends BaseConnector {\n  async init(_) {}\n  async getIdentityToken() {\n    if (!this.provider || this.status !== CONNECTOR_STATUS.CONNECTED) throw WalletLoginError.notConnectedError();\n    if (!this.coreOptions) throw WalletInitializationError.invalidParams(\"Please initialize Web3Auth with valid options\");\n    const accounts = await this.provider.request({\n      method: EVM_METHOD_TYPES.GET_ACCOUNTS\n    });\n    if (accounts && accounts.length > 0) {\n      const existingToken = getSavedToken(accounts[0], this.name);\n      if (existingToken) {\n        const isExpired = checkIfTokenIsExpired(existingToken);\n        if (!isExpired) {\n          return {\n            idToken: existingToken\n          };\n        }\n      }\n      const chainId = await this.provider.request({\n        method: \"eth_chainId\"\n      });\n      const currentChainConfig = this.coreOptions.chains.find(x => x.chainId === chainId);\n      if (!currentChainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before authentication\");\n      const {\n        chainNamespace\n      } = currentChainConfig;\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString()\n      };\n      const challenge = await signChallenge(payload, chainNamespace);\n      const hexChallenge = `0x${Buffer.from(challenge, \"utf8\").toString(\"hex\")}`;\n      const signedMessage = await this.provider.request({\n        method: EVM_METHOD_TYPES.PERSONAL_SIGN,\n        params: [hexChallenge, accounts[0]]\n      });\n      const idToken = await verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.coreOptions.sessionTime, this.coreOptions.clientId, this.coreOptions.web3AuthNetwork);\n      saveToken(accounts[0], this.name, idToken);\n      return {\n        idToken\n      };\n    }\n    throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n  async disconnectSession() {\n    super.checkDisconnectionRequirements();\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n    if (accounts && accounts.length > 0) {\n      clearToken(accounts[0], this.name);\n    }\n  }\n  async disconnect() {\n    this.rehydrated = false;\n    this.emit(CONNECTOR_EVENTS.DISCONNECTED);\n  }\n}\n\nexport { BaseEvmConnector };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { normalizeWalletName } from '../../base/utils.js';\nimport { BaseEvmConnector } from '../base-evm-connector/baseEvmConnector.js';\nimport { CONNECTOR_NAMESPACES } from '../../base/chain/IChainInterface.js';\nimport { CHAIN_NAMESPACES } from '@toruslabs/base-controllers';\nimport { CONNECTOR_CATEGORY, CONNECTOR_STATUS, CONNECTOR_EVENTS } from '../../base/connector/constants.js';\nimport { log } from '../../base/loglevel.js';\nimport { WalletLoginError, Web3AuthError } from '../../base/errors/index.js';\n\nclass InjectedEvmConnector extends BaseEvmConnector {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"connectorNamespace\", CONNECTOR_NAMESPACES.EIP155);\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n    _defineProperty(this, \"type\", CONNECTOR_CATEGORY.EXTERNAL);\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"isInjected\", true);\n    _defineProperty(this, \"status\", CONNECTOR_STATUS.NOT_READY);\n    _defineProperty(this, \"injectedProvider\", null);\n    this.name = options.name;\n    this.injectedProvider = options.provider;\n    this.icon = options.icon;\n  }\n  get provider() {\n    if (this.status !== CONNECTOR_STATUS.NOT_READY && this.injectedProvider) {\n      return this.injectedProvider;\n    }\n    return null;\n  }\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n  async init(options) {\n    await super.init(options);\n    const chainConfig = this.coreOptions.chains.find(x => x.chainId === options.chainId);\n    super.checkInitializationRequirements({\n      chainConfig\n    });\n    this.status = CONNECTOR_STATUS.READY;\n    this.emit(CONNECTOR_EVENTS.READY, this.name);\n    try {\n      log.debug(`initializing ${this.name} injected connector`);\n      if (options.autoConnect) {\n        this.rehydrated = true;\n        const provider = await this.connect({\n          chainId: options.chainId\n        });\n        if (!provider) {\n          this.rehydrated = false;\n          throw WalletLoginError.connectionError(\"Failed to rehydrate.\");\n        }\n      }\n    } catch (error) {\n      this.emit(CONNECTOR_EVENTS.REHYDRATION_ERROR, error);\n    }\n  }\n  async connect({\n    chainId\n  }) {\n    super.checkConnectionRequirements();\n    if (!this.injectedProvider) throw WalletLoginError.connectionError(\"Injected provider is not available\");\n    const chainConfig = this.coreOptions.chains.find(x => x.chainId === chainId);\n    if (!chainConfig) throw WalletLoginError.connectionError(\"Chain config is not available\");\n    this.status = CONNECTOR_STATUS.CONNECTING;\n    this.emit(CONNECTOR_EVENTS.CONNECTING, {\n      connector: this.name\n    });\n    try {\n      await this.injectedProvider.request({\n        method: \"eth_requestAccounts\"\n      });\n      // switch chain if not connected to the right chain\n      if (this.injectedProvider.chainId !== chainConfig.chainId) {\n        try {\n          await this.switchChain(chainConfig, true);\n        } catch {\n          await this.addChain(chainConfig, true);\n          await this.switchChain(chainConfig, true);\n        }\n      }\n      this.status = CONNECTOR_STATUS.CONNECTED;\n      const accountDisconnectHandler = accounts => {\n        if (accounts.length === 0) {\n          var _this$injectedProvide;\n          this.disconnect();\n          if ((_this$injectedProvide = this.injectedProvider) !== null && _this$injectedProvide !== void 0 && _this$injectedProvide.removeListener) this.injectedProvider.removeListener(\"accountsChanged\", accountDisconnectHandler);\n        }\n      };\n      this.injectedProvider.on(\"accountsChanged\", accountDisconnectHandler);\n      this.emit(CONNECTOR_EVENTS.CONNECTED, {\n        connector: this.name,\n        reconnected: this.rehydrated,\n        provider: this.injectedProvider\n      });\n      return this.injectedProvider;\n    } catch (error) {\n      // ready again to be connected\n      this.status = CONNECTOR_STATUS.READY;\n      if (!this.rehydrated) this.emit(CONNECTOR_EVENTS.ERRORED, error);\n      this.rehydrated = false;\n      if (error instanceof Web3AuthError) throw error;\n      throw WalletLoginError.connectionError(`Failed to login with ${this.name} injected wallet`);\n    }\n  }\n  async disconnect(options = {\n    cleanup: false\n  }) {\n    if (!this.injectedProvider) throw WalletLoginError.connectionError(\"Injected provider is not available\");\n    await super.disconnectSession();\n    if (typeof this.injectedProvider.removeAllListeners !== \"undefined\") this.injectedProvider.removeAllListeners();\n    try {\n      await this.injectedProvider.request({\n        method: \"wallet_revokePermissions\",\n        params: [{\n          eth_accounts: {}\n        }]\n      });\n    } catch {\n      // ignore error\n    }\n    if (options.cleanup) {\n      this.status = CONNECTOR_STATUS.NOT_READY;\n      this.injectedProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = CONNECTOR_STATUS.READY;\n    }\n    await super.disconnect();\n  }\n  async getUserInfo() {\n    if (this.status !== CONNECTOR_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n  async addChain(chainConfig, _init = false) {\n    if (!this.injectedProvider) throw WalletLoginError.connectionError(\"Injected provider is not available\");\n    await this.injectedProvider.request({\n      method: \"wallet_addEthereumChain\",\n      params: [{\n        chainId: chainConfig.chainId,\n        chainName: chainConfig.displayName,\n        rpcUrls: [chainConfig.rpcTarget],\n        blockExplorerUrls: [chainConfig.blockExplorerUrl],\n        nativeCurrency: {\n          name: chainConfig.tickerName,\n          symbol: chainConfig.ticker,\n          decimals: chainConfig.decimals || 18\n        },\n        iconUrls: [chainConfig.logo]\n      }]\n    });\n  }\n  async switchChain(params, init = false) {\n    if (!this.injectedProvider) throw WalletLoginError.connectionError(\"Injected provider is not available\");\n    super.checkSwitchChainRequirements(params, init);\n    await this.injectedProvider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: params.chainId\n      }]\n    });\n  }\n  async enableMFA() {\n    throw new Error(\"Method Not implemented\");\n  }\n  async manageMFA() {\n    throw new Error(\"Method Not implemented\");\n  }\n}\nconst injectedEvmConnector = providerDetail => {\n  return ({\n    coreOptions\n  }) => {\n    return new InjectedEvmConnector({\n      name: normalizeWalletName(providerDetail.info.name),\n      provider: providerDetail.provider,\n      icon: providerDetail.info.icon,\n      coreOptions\n    });\n  };\n};\n\nexport { InjectedEvmConnector, injectedEvmConnector };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,IAAM,mBAAN,cAA+B,cAAc;AAAA,EAC3C,MAAM,KAAK,GAAG;AAAA,EAAC;AAAA,EACf,MAAM,mBAAmB;AACvB,QAAI,CAAC,KAAK,YAAY,KAAK,WAAW,iBAAiB,UAAW,OAAM,iBAAiB,kBAAkB;AAC3G,QAAI,CAAC,KAAK,YAAa,OAAM,0BAA0B,cAAc,+CAA+C;AACpH,UAAM,WAAW,MAAM,KAAK,SAAS,QAAQ;AAAA,MAC3C,QAAQ,iBAAiB;AAAA,IAC3B,CAAC;AACD,QAAI,YAAY,SAAS,SAAS,GAAG;AACnC,YAAM,gBAAgB,cAAc,SAAS,CAAC,GAAG,KAAK,IAAI;AAC1D,UAAI,eAAe;AACjB,cAAM,YAAY,sBAAsB,aAAa;AACrD,YAAI,CAAC,WAAW;AACd,iBAAO;AAAA,YACL,SAAS;AAAA,UACX;AAAA,QACF;AAAA,MACF;AACA,YAAM,UAAU,MAAM,KAAK,SAAS,QAAQ;AAAA,QAC1C,QAAQ;AAAA,MACV,CAAC;AACD,YAAM,qBAAqB,KAAK,YAAY,OAAO,KAAK,OAAK,EAAE,YAAY,OAAO;AAClF,UAAI,CAAC,mBAAoB,OAAM,0BAA0B,cAAc,+CAA+C;AACtH,YAAM;AAAA,QACJ;AAAA,MACF,IAAI;AACJ,YAAM,UAAU;AAAA,QACd,QAAQ,OAAO,SAAS;AAAA,QACxB,KAAK,OAAO,SAAS;AAAA,QACrB,SAAS,SAAS,CAAC;AAAA,QACnB,SAAS,SAAS,SAAS,EAAE;AAAA,QAC7B,SAAS;AAAA,QACT,OAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC;AAAA,QACzC,WAAU,oBAAI,KAAK,GAAE,YAAY;AAAA,MACnC;AACA,YAAM,YAAY,MAAM,cAAc,SAAS,cAAc;AAC7D,YAAM,eAAe,KAAK,OAAO,KAAK,WAAW,MAAM,EAAE,SAAS,KAAK,CAAC;AACxE,YAAM,gBAAgB,MAAM,KAAK,SAAS,QAAQ;AAAA,QAChD,QAAQ,iBAAiB;AAAA,QACzB,QAAQ,CAAC,cAAc,SAAS,CAAC,CAAC;AAAA,MACpC,CAAC;AACD,YAAM,UAAU,MAAM,sBAAsB,gBAAgB,eAAe,WAAW,KAAK,MAAM,KAAK,YAAY,aAAa,KAAK,YAAY,UAAU,KAAK,YAAY,eAAe;AAC1L,gBAAU,SAAS,CAAC,GAAG,KAAK,MAAM,OAAO;AACzC,aAAO;AAAA,QACL;AAAA,MACF;AAAA,IACF;AACA,UAAM,iBAAiB,kBAAkB,uDAAuD;AAAA,EAClG;AAAA,EACA,MAAM,oBAAoB;AACxB,UAAM,+BAA+B;AACrC,UAAM,WAAW,MAAM,KAAK,SAAS,QAAQ;AAAA,MAC3C,QAAQ;AAAA,IACV,CAAC;AACD,QAAI,YAAY,SAAS,SAAS,GAAG;AACnC,iBAAW,SAAS,CAAC,GAAG,KAAK,IAAI;AAAA,IACnC;AAAA,EACF;AAAA,EACA,MAAM,aAAa;AACjB,SAAK,aAAa;AAClB,SAAK,KAAK,iBAAiB,YAAY;AAAA,EACzC;AACF;;;AC5DA,IAAM,uBAAN,cAAmC,iBAAiB;AAAA,EAClD,YAAY,SAAS;AACnB,UAAM,OAAO;AACb,oBAAgB,MAAM,sBAAsB,qBAAqB,MAAM;AACvE,oBAAgB,MAAM,yBAAyB,iBAAiB,MAAM;AACtE,oBAAgB,MAAM,QAAQ,mBAAmB,QAAQ;AACzD,oBAAgB,MAAM,QAAQ,MAAM;AACpC,oBAAgB,MAAM,cAAc,IAAI;AACxC,oBAAgB,MAAM,UAAU,iBAAiB,SAAS;AAC1D,oBAAgB,MAAM,oBAAoB,IAAI;AAC9C,SAAK,OAAO,QAAQ;AACpB,SAAK,mBAAmB,QAAQ;AAChC,SAAK,OAAO,QAAQ;AAAA,EACtB;AAAA,EACA,IAAI,WAAW;AACb,QAAI,KAAK,WAAW,iBAAiB,aAAa,KAAK,kBAAkB;AACvE,aAAO,KAAK;AAAA,IACd;AACA,WAAO;AAAA,EACT;AAAA,EACA,IAAI,SAAS,GAAG;AACd,UAAM,IAAI,MAAM,iBAAiB;AAAA,EACnC;AAAA,EACA,MAAM,KAAK,SAAS;AAClB,UAAM,MAAM,KAAK,OAAO;AACxB,UAAM,cAAc,KAAK,YAAY,OAAO,KAAK,OAAK,EAAE,YAAY,QAAQ,OAAO;AACnF,UAAM,gCAAgC;AAAA,MACpC;AAAA,IACF,CAAC;AACD,SAAK,SAAS,iBAAiB;AAC/B,SAAK,KAAK,iBAAiB,OAAO,KAAK,IAAI;AAC3C,QAAI;AACF,UAAI,MAAM,gBAAgB,KAAK,IAAI,qBAAqB;AACxD,UAAI,QAAQ,aAAa;AACvB,aAAK,aAAa;AAClB,cAAM,WAAW,MAAM,KAAK,QAAQ;AAAA,UAClC,SAAS,QAAQ;AAAA,QACnB,CAAC;AACD,YAAI,CAAC,UAAU;AACb,eAAK,aAAa;AAClB,gBAAM,iBAAiB,gBAAgB,sBAAsB;AAAA,QAC/D;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,WAAK,KAAK,iBAAiB,mBAAmB,KAAK;AAAA,IACrD;AAAA,EACF;AAAA,EACA,MAAM,QAAQ;AAAA,IACZ;AAAA,EACF,GAAG;AACD,UAAM,4BAA4B;AAClC,QAAI,CAAC,KAAK,iBAAkB,OAAM,iBAAiB,gBAAgB,oCAAoC;AACvG,UAAM,cAAc,KAAK,YAAY,OAAO,KAAK,OAAK,EAAE,YAAY,OAAO;AAC3E,QAAI,CAAC,YAAa,OAAM,iBAAiB,gBAAgB,+BAA+B;AACxF,SAAK,SAAS,iBAAiB;AAC/B,SAAK,KAAK,iBAAiB,YAAY;AAAA,MACrC,WAAW,KAAK;AAAA,IAClB,CAAC;AACD,QAAI;AACF,YAAM,KAAK,iBAAiB,QAAQ;AAAA,QAClC,QAAQ;AAAA,MACV,CAAC;AAED,UAAI,KAAK,iBAAiB,YAAY,YAAY,SAAS;AACzD,YAAI;AACF,gBAAM,KAAK,YAAY,aAAa,IAAI;AAAA,QAC1C,QAAQ;AACN,gBAAM,KAAK,SAAS,aAAa,IAAI;AACrC,gBAAM,KAAK,YAAY,aAAa,IAAI;AAAA,QAC1C;AAAA,MACF;AACA,WAAK,SAAS,iBAAiB;AAC/B,YAAM,2BAA2B,cAAY;AAC3C,YAAI,SAAS,WAAW,GAAG;AACzB,cAAI;AACJ,eAAK,WAAW;AAChB,eAAK,wBAAwB,KAAK,sBAAsB,QAAQ,0BAA0B,UAAU,sBAAsB,eAAgB,MAAK,iBAAiB,eAAe,mBAAmB,wBAAwB;AAAA,QAC5N;AAAA,MACF;AACA,WAAK,iBAAiB,GAAG,mBAAmB,wBAAwB;AACpE,WAAK,KAAK,iBAAiB,WAAW;AAAA,QACpC,WAAW,KAAK;AAAA,QAChB,aAAa,KAAK;AAAA,QAClB,UAAU,KAAK;AAAA,MACjB,CAAC;AACD,aAAO,KAAK;AAAA,IACd,SAAS,OAAO;AAEd,WAAK,SAAS,iBAAiB;AAC/B,UAAI,CAAC,KAAK,WAAY,MAAK,KAAK,iBAAiB,SAAS,KAAK;AAC/D,WAAK,aAAa;AAClB,UAAI,iBAAiB,cAAe,OAAM;AAC1C,YAAM,iBAAiB,gBAAgB,wBAAwB,KAAK,IAAI,kBAAkB;AAAA,IAC5F;AAAA,EACF;AAAA,EACA,MAAM,WAAW,UAAU;AAAA,IACzB,SAAS;AAAA,EACX,GAAG;AACD,QAAI,CAAC,KAAK,iBAAkB,OAAM,iBAAiB,gBAAgB,oCAAoC;AACvG,UAAM,MAAM,kBAAkB;AAC9B,QAAI,OAAO,KAAK,iBAAiB,uBAAuB,YAAa,MAAK,iBAAiB,mBAAmB;AAC9G,QAAI;AACF,YAAM,KAAK,iBAAiB,QAAQ;AAAA,QAClC,QAAQ;AAAA,QACR,QAAQ,CAAC;AAAA,UACP,cAAc,CAAC;AAAA,QACjB,CAAC;AAAA,MACH,CAAC;AAAA,IACH,QAAQ;AAAA,IAER;AACA,QAAI,QAAQ,SAAS;AACnB,WAAK,SAAS,iBAAiB;AAC/B,WAAK,mBAAmB;AAAA,IAC1B,OAAO;AAEL,WAAK,SAAS,iBAAiB;AAAA,IACjC;AACA,UAAM,MAAM,WAAW;AAAA,EACzB;AAAA,EACA,MAAM,cAAc;AAClB,QAAI,KAAK,WAAW,iBAAiB,UAAW,OAAM,iBAAiB,kBAAkB,uDAAuD;AAChJ,WAAO,CAAC;AAAA,EACV;AAAA,EACA,MAAM,SAAS,aAAa,QAAQ,OAAO;AACzC,QAAI,CAAC,KAAK,iBAAkB,OAAM,iBAAiB,gBAAgB,oCAAoC;AACvG,UAAM,KAAK,iBAAiB,QAAQ;AAAA,MAClC,QAAQ;AAAA,MACR,QAAQ,CAAC;AAAA,QACP,SAAS,YAAY;AAAA,QACrB,WAAW,YAAY;AAAA,QACvB,SAAS,CAAC,YAAY,SAAS;AAAA,QAC/B,mBAAmB,CAAC,YAAY,gBAAgB;AAAA,QAChD,gBAAgB;AAAA,UACd,MAAM,YAAY;AAAA,UAClB,QAAQ,YAAY;AAAA,UACpB,UAAU,YAAY,YAAY;AAAA,QACpC;AAAA,QACA,UAAU,CAAC,YAAY,IAAI;AAAA,MAC7B,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EACA,MAAM,YAAY,QAAQ,OAAO,OAAO;AACtC,QAAI,CAAC,KAAK,iBAAkB,OAAM,iBAAiB,gBAAgB,oCAAoC;AACvG,UAAM,6BAA6B,QAAQ,IAAI;AAC/C,UAAM,KAAK,iBAAiB,QAAQ;AAAA,MAClC,QAAQ;AAAA,MACR,QAAQ,CAAC;AAAA,QACP,SAAS,OAAO;AAAA,MAClB,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EACA,MAAM,YAAY;AAChB,UAAM,IAAI,MAAM,wBAAwB;AAAA,EAC1C;AAAA,EACA,MAAM,YAAY;AAChB,UAAM,IAAI,MAAM,wBAAwB;AAAA,EAC1C;AACF;AACA,IAAM,uBAAuB,oBAAkB;AAC7C,SAAO,CAAC;AAAA,IACN;AAAA,EACF,MAAM;AACJ,WAAO,IAAI,qBAAqB;AAAA,MAC9B,MAAM,oBAAoB,eAAe,KAAK,IAAI;AAAA,MAClD,UAAU,eAAe;AAAA,MACzB,MAAM,eAAe,KAAK;AAAA,MAC1B;AAAA,IACF,CAAC;AAAA,EACH;AACF;",
  "names": []
}
