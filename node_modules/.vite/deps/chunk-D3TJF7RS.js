import {
  require_browser_ponyfill,
  require_eventemitter2
} from "./chunk-I6FMYGNX.js";
import {
  require_browser
} from "./chunk-MMSGLE56.js";
import {
  en
} from "./chunk-XJJJAC74.js";
import {
  ANALYTICS_EVENTS,
  ANALYTICS_INTEGRATION_TYPE,
  ANALYTICS_SDK_TYPE,
  Analytics,
  getSiteIcon,
  getSiteName,
  parseToken
} from "./chunk-E37ZTJS5.js";
import {
  CommonJRPCProvider
} from "./chunk-T76UJC3V.js";
import {
  VersionedTransaction
} from "./chunk-KVGG4UNH.js";
import {
  init_esm_browser,
  v4_default,
  validate_default
} from "./chunk-64SD37WF.js";
import {
  BaseEvmConnector
} from "./chunk-7AISMB4O.js";
import {
  BaseConnector,
  CONNECTOR_CATEGORY,
  CONNECTOR_EVENTS,
  CONNECTOR_NAMES,
  CONNECTOR_NAMESPACES,
  CONNECTOR_STATUS,
  EVM_CONNECTORS,
  LOGIN_MODE,
  SMART_ACCOUNT_WALLET_SCOPE,
  WALLET_CONNECTORS,
  WEB3AUTH_STATE_STORAGE_KEY,
  WIDGET_TYPE,
  fetchProjectConfig,
  fetchWalletRegistry,
  getAaAnalyticsProperties,
  getCaipChainId,
  getErrorAnalyticsProperties as getErrorAnalyticsProperties2,
  getHostname,
  getWalletServicesAnalyticsProperties,
  getWhitelabelAnalyticsProperties,
  isBrowser,
  isHexStrict,
  sdkVersion,
  storageAvailable as storageAvailable2,
  withAbort
} from "./chunk-A6MZY642.js";
import {
  log
} from "./chunk-NSXL3SWJ.js";
import {
  SOLANA_METHOD_TYPES
} from "./chunk-XLWISUI2.js";
import {
  WalletInitializationError,
  WalletLoginError,
  Web3AuthError
} from "./chunk-VBPUSRQJ.js";
import {
  AUTH_CONNECTION,
  Auth,
  BUILD_ENV,
  BUTTON_POSITION,
  BigNumber,
  CHAIN_NAMESPACES,
  CONFIRMATION_STRATEGY,
  EMAIL_FLOW,
  LANGUAGES,
  LANGUAGE_MAP,
  MemoryStore,
  PopupHandler,
  SDK_MODE,
  SUPPORTED_KEY_CURVES,
  SafeEventEmitter,
  SecurePubSub,
  THEME_MODES,
  UX_MODE,
  WEB3AUTH_NETWORK,
  _objectWithoutProperties,
  addHexPrefix,
  applyWhiteLabelTheme,
  bowser_default,
  cloneDeep,
  cloneDeep2,
  createHandler,
  getErrorAnalyticsProperties,
  getUserId,
  isValidAddress,
  randomId,
  randomId2,
  serializeError,
  storageAvailable,
  stripHexPrefix,
  version
} from "./chunk-B2N4C5QO.js";
import {
  require_bn
} from "./chunk-CQQ7RDSY.js";
import {
  _defineProperty,
  _objectSpread2,
  get,
  post,
  require_cjs,
  require_loglevel
} from "./chunk-Z2JNO6L5.js";
import {
  lookup
} from "./chunk-4W5QYKQT.js";
import {
  require_client
} from "./chunk-5WOPONXG.js";
import {
  require_jsx_runtime
} from "./chunk-TLG7CTPL.js";
import {
  require_react
} from "./chunk-VT65UQWK.js";
import {
  __commonJS,
  __glob,
  __publicField,
  __require,
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/openapi-fetch/dist/cjs/index.cjs
var require_cjs2 = __commonJS({
  "node_modules/openapi-fetch/dist/cjs/index.cjs"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to2, key) && key !== except)
            __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to2;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export(index_exports, {
      createFinalURL: () => createFinalURL,
      createPathBasedClient: () => createPathBasedClient,
      createQuerySerializer: () => createQuerySerializer,
      default: () => createClient,
      defaultBodySerializer: () => defaultBodySerializer,
      defaultPathSerializer: () => defaultPathSerializer,
      mergeHeaders: () => mergeHeaders,
      randomID: () => randomID,
      removeTrailingSlash: () => removeTrailingSlash,
      serializeArrayParam: () => serializeArrayParam,
      serializeObjectParam: () => serializeObjectParam,
      serializePrimitiveParam: () => serializePrimitiveParam,
      wrapAsPathBasedClient: () => wrapAsPathBasedClient
    });
    module.exports = __toCommonJS(index_exports);
    var PATH_PARAM_RE = /\{[^{}]+\}/g;
    var supportsRequestInitExt = () => {
      var _a2, _b;
      return typeof process === "object" && Number.parseInt((_b = (_a2 = process == null ? void 0 : process.versions) == null ? void 0 : _a2.node) == null ? void 0 : _b.substring(0, 2)) >= 18 && process.versions.undici;
    };
    function randomID() {
      return Math.random().toString(36).slice(2, 11);
    }
    function createClient(clientOptions) {
      let {
        baseUrl = "",
        Request: CustomRequest = globalThis.Request,
        fetch: baseFetch = globalThis.fetch,
        querySerializer: globalQuerySerializer,
        bodySerializer: globalBodySerializer,
        headers: baseHeaders,
        requestInitExt = void 0,
        ...baseOptions
      } = { ...clientOptions };
      requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;
      baseUrl = removeTrailingSlash(baseUrl);
      const middlewares = [];
      async function coreFetch(schemaPath, fetchOptions) {
        const {
          baseUrl: localBaseUrl,
          fetch: fetch2 = baseFetch,
          Request = CustomRequest,
          headers,
          params = {},
          parseAs = "json",
          querySerializer: requestQuerySerializer,
          bodySerializer = globalBodySerializer ?? defaultBodySerializer,
          body,
          ...init2
        } = fetchOptions || {};
        let finalBaseUrl = baseUrl;
        if (localBaseUrl) {
          finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;
        }
        let querySerializer = typeof globalQuerySerializer === "function" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);
        if (requestQuerySerializer) {
          querySerializer = typeof requestQuerySerializer === "function" ? requestQuerySerializer : createQuerySerializer({
            ...typeof globalQuerySerializer === "object" ? globalQuerySerializer : {},
            ...requestQuerySerializer
          });
        }
        const serializedBody = body === void 0 ? void 0 : bodySerializer(
          body,
          // Note: we declare mergeHeaders() both here and below because it’s a bit of a chicken-or-egg situation:
          // bodySerializer() needs all headers so we aren’t dropping ones set by the user, however,
          // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,
          // setting the content-type at the very beginning to be overwritten.
          // Lastly, based on the way headers work, it’s not a simple “present-or-not” check becauase null intentionally un-sets headers.
          mergeHeaders(baseHeaders, headers, params.header)
        );
        const finalHeaders = mergeHeaders(
          // with no body, we should not to set Content-Type
          serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression
          serializedBody instanceof FormData ? {} : {
            "Content-Type": "application/json"
          },
          baseHeaders,
          headers,
          params.header
        );
        const requestInit = {
          redirect: "follow",
          ...baseOptions,
          ...init2,
          body: serializedBody,
          headers: finalHeaders
        };
        let id2;
        let options2;
        let request = new CustomRequest(
          createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),
          requestInit
        );
        let response;
        for (const key in init2) {
          if (!(key in request)) {
            request[key] = init2[key];
          }
        }
        if (middlewares.length) {
          id2 = randomID();
          options2 = Object.freeze({
            baseUrl: finalBaseUrl,
            fetch: fetch2,
            parseAs,
            querySerializer,
            bodySerializer
          });
          for (const m2 of middlewares) {
            if (m2 && typeof m2 === "object" && typeof m2.onRequest === "function") {
              const result = await m2.onRequest({
                request,
                schemaPath,
                params,
                options: options2,
                id: id2
              });
              if (result) {
                if (result instanceof CustomRequest) {
                  request = result;
                } else if (result instanceof Response) {
                  response = result;
                  break;
                } else {
                  throw new Error("onRequest: must return new Request() or Response() when modifying the request");
                }
              }
            }
          }
        }
        if (!response) {
          try {
            response = await fetch2(request, requestInitExt);
          } catch (error2) {
            let errorAfterMiddleware = error2;
            if (middlewares.length) {
              for (let i2 = middlewares.length - 1; i2 >= 0; i2--) {
                const m2 = middlewares[i2];
                if (m2 && typeof m2 === "object" && typeof m2.onError === "function") {
                  const result = await m2.onError({
                    request,
                    error: errorAfterMiddleware,
                    schemaPath,
                    params,
                    options: options2,
                    id: id2
                  });
                  if (result) {
                    if (result instanceof Response) {
                      errorAfterMiddleware = void 0;
                      response = result;
                      break;
                    }
                    if (result instanceof Error) {
                      errorAfterMiddleware = result;
                      continue;
                    }
                    throw new Error("onError: must return new Response() or instance of Error");
                  }
                }
              }
            }
            if (errorAfterMiddleware) {
              throw errorAfterMiddleware;
            }
          }
          if (middlewares.length) {
            for (let i2 = middlewares.length - 1; i2 >= 0; i2--) {
              const m2 = middlewares[i2];
              if (m2 && typeof m2 === "object" && typeof m2.onResponse === "function") {
                const result = await m2.onResponse({
                  request,
                  response,
                  schemaPath,
                  params,
                  options: options2,
                  id: id2
                });
                if (result) {
                  if (!(result instanceof Response)) {
                    throw new Error("onResponse: must return new Response() when modifying the response");
                  }
                  response = result;
                }
              }
            }
          }
        }
        if (response.status === 204 || request.method === "HEAD" || response.headers.get("Content-Length") === "0") {
          return response.ok ? { data: void 0, response } : { error: void 0, response };
        }
        if (response.ok) {
          if (parseAs === "stream") {
            return { data: response.body, response };
          }
          return { data: await response[parseAs](), response };
        }
        let error = await response.text();
        try {
          error = JSON.parse(error);
        } catch {
        }
        return { error, response };
      }
      return {
        request(method, url, init2) {
          return coreFetch(url, { ...init2, method: method.toUpperCase() });
        },
        /** Call a GET endpoint */
        GET(url, init2) {
          return coreFetch(url, { ...init2, method: "GET" });
        },
        /** Call a PUT endpoint */
        PUT(url, init2) {
          return coreFetch(url, { ...init2, method: "PUT" });
        },
        /** Call a POST endpoint */
        POST(url, init2) {
          return coreFetch(url, { ...init2, method: "POST" });
        },
        /** Call a DELETE endpoint */
        DELETE(url, init2) {
          return coreFetch(url, { ...init2, method: "DELETE" });
        },
        /** Call a OPTIONS endpoint */
        OPTIONS(url, init2) {
          return coreFetch(url, { ...init2, method: "OPTIONS" });
        },
        /** Call a HEAD endpoint */
        HEAD(url, init2) {
          return coreFetch(url, { ...init2, method: "HEAD" });
        },
        /** Call a PATCH endpoint */
        PATCH(url, init2) {
          return coreFetch(url, { ...init2, method: "PATCH" });
        },
        /** Call a TRACE endpoint */
        TRACE(url, init2) {
          return coreFetch(url, { ...init2, method: "TRACE" });
        },
        /** Register middleware */
        use(...middleware) {
          for (const m2 of middleware) {
            if (!m2) {
              continue;
            }
            if (typeof m2 !== "object" || !("onRequest" in m2 || "onResponse" in m2 || "onError" in m2)) {
              throw new Error("Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`");
            }
            middlewares.push(m2);
          }
        },
        /** Unregister middleware */
        eject(...middleware) {
          for (const m2 of middleware) {
            const i2 = middlewares.indexOf(m2);
            if (i2 !== -1) {
              middlewares.splice(i2, 1);
            }
          }
        }
      };
    }
    var PathCallForwarder = class {
      constructor(client, url) {
        __publicField(this, "GET", (init2) => {
          return this.client.GET(this.url, init2);
        });
        __publicField(this, "PUT", (init2) => {
          return this.client.PUT(this.url, init2);
        });
        __publicField(this, "POST", (init2) => {
          return this.client.POST(this.url, init2);
        });
        __publicField(this, "DELETE", (init2) => {
          return this.client.DELETE(this.url, init2);
        });
        __publicField(this, "OPTIONS", (init2) => {
          return this.client.OPTIONS(this.url, init2);
        });
        __publicField(this, "HEAD", (init2) => {
          return this.client.HEAD(this.url, init2);
        });
        __publicField(this, "PATCH", (init2) => {
          return this.client.PATCH(this.url, init2);
        });
        __publicField(this, "TRACE", (init2) => {
          return this.client.TRACE(this.url, init2);
        });
        this.client = client;
        this.url = url;
      }
    };
    var PathClientProxyHandler = class {
      constructor() {
        this.client = null;
      }
      // Assume the property is an URL.
      get(coreClient, url) {
        const forwarder = new PathCallForwarder(coreClient, url);
        this.client[url] = forwarder;
        return forwarder;
      }
    };
    function wrapAsPathBasedClient(coreClient) {
      const handler = new PathClientProxyHandler();
      const proxy = new Proxy(coreClient, handler);
      function Client() {
      }
      Client.prototype = proxy;
      const client = new Client();
      handler.client = client;
      return client;
    }
    function createPathBasedClient(clientOptions) {
      return wrapAsPathBasedClient(createClient(clientOptions));
    }
    function serializePrimitiveParam(name, value, options2) {
      if (value === void 0 || value === null) {
        return "";
      }
      if (typeof value === "object") {
        throw new Error(
          "Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these."
        );
      }
      return `${name}=${(options2 == null ? void 0 : options2.allowReserved) === true ? value : encodeURIComponent(value)}`;
    }
    function serializeObjectParam(name, value, options2) {
      if (!value || typeof value !== "object") {
        return "";
      }
      const values = [];
      const joiner = {
        simple: ",",
        label: ".",
        matrix: ";"
      }[options2.style] || "&";
      if (options2.style !== "deepObject" && options2.explode === false) {
        for (const k3 in value) {
          values.push(k3, options2.allowReserved === true ? value[k3] : encodeURIComponent(value[k3]));
        }
        const final2 = values.join(",");
        switch (options2.style) {
          case "form": {
            return `${name}=${final2}`;
          }
          case "label": {
            return `.${final2}`;
          }
          case "matrix": {
            return `;${name}=${final2}`;
          }
          default: {
            return final2;
          }
        }
      }
      for (const k3 in value) {
        const finalName = options2.style === "deepObject" ? `${name}[${k3}]` : k3;
        values.push(serializePrimitiveParam(finalName, value[k3], options2));
      }
      const final = values.join(joiner);
      return options2.style === "label" || options2.style === "matrix" ? `${joiner}${final}` : final;
    }
    function serializeArrayParam(name, value, options2) {
      if (!Array.isArray(value)) {
        return "";
      }
      if (options2.explode === false) {
        const joiner2 = { form: ",", spaceDelimited: "%20", pipeDelimited: "|" }[options2.style] || ",";
        const final = (options2.allowReserved === true ? value : value.map((v2) => encodeURIComponent(v2))).join(joiner2);
        switch (options2.style) {
          case "simple": {
            return final;
          }
          case "label": {
            return `.${final}`;
          }
          case "matrix": {
            return `;${name}=${final}`;
          }
          // case "spaceDelimited":
          // case "pipeDelimited":
          default: {
            return `${name}=${final}`;
          }
        }
      }
      const joiner = { simple: ",", label: ".", matrix: ";" }[options2.style] || "&";
      const values = [];
      for (const v2 of value) {
        if (options2.style === "simple" || options2.style === "label") {
          values.push(options2.allowReserved === true ? v2 : encodeURIComponent(v2));
        } else {
          values.push(serializePrimitiveParam(name, v2, options2));
        }
      }
      return options2.style === "label" || options2.style === "matrix" ? `${joiner}${values.join(joiner)}` : values.join(joiner);
    }
    function createQuerySerializer(options2) {
      return function querySerializer(queryParams) {
        const search = [];
        if (queryParams && typeof queryParams === "object") {
          for (const name in queryParams) {
            const value = queryParams[name];
            if (value === void 0 || value === null) {
              continue;
            }
            if (Array.isArray(value)) {
              if (value.length === 0) {
                continue;
              }
              search.push(
                serializeArrayParam(name, value, {
                  style: "form",
                  explode: true,
                  ...options2 == null ? void 0 : options2.array,
                  allowReserved: (options2 == null ? void 0 : options2.allowReserved) || false
                })
              );
              continue;
            }
            if (typeof value === "object") {
              search.push(
                serializeObjectParam(name, value, {
                  style: "deepObject",
                  explode: true,
                  ...options2 == null ? void 0 : options2.object,
                  allowReserved: (options2 == null ? void 0 : options2.allowReserved) || false
                })
              );
              continue;
            }
            search.push(serializePrimitiveParam(name, value, options2));
          }
        }
        return search.join("&");
      };
    }
    function defaultPathSerializer(pathname, pathParams) {
      let nextURL = pathname;
      for (const match of pathname.match(PATH_PARAM_RE) ?? []) {
        let name = match.substring(1, match.length - 1);
        let explode = false;
        let style = "simple";
        if (name.endsWith("*")) {
          explode = true;
          name = name.substring(0, name.length - 1);
        }
        if (name.startsWith(".")) {
          style = "label";
          name = name.substring(1);
        } else if (name.startsWith(";")) {
          style = "matrix";
          name = name.substring(1);
        }
        if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {
          continue;
        }
        const value = pathParams[name];
        if (Array.isArray(value)) {
          nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));
          continue;
        }
        if (typeof value === "object") {
          nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));
          continue;
        }
        if (style === "matrix") {
          nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);
          continue;
        }
        nextURL = nextURL.replace(match, style === "label" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));
      }
      return nextURL;
    }
    function defaultBodySerializer(body, headers) {
      if (body instanceof FormData) {
        return body;
      }
      if (headers) {
        const contentType = headers.get instanceof Function ? headers.get("Content-Type") ?? headers.get("content-type") : headers["Content-Type"] ?? headers["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          return new URLSearchParams(body).toString();
        }
      }
      return JSON.stringify(body);
    }
    function createFinalURL(pathname, options2) {
      var _a2;
      let finalURL = `${options2.baseUrl}${pathname}`;
      if ((_a2 = options2.params) == null ? void 0 : _a2.path) {
        finalURL = defaultPathSerializer(finalURL, options2.params.path);
      }
      let search = options2.querySerializer(options2.params.query ?? {});
      if (search.startsWith("?")) {
        search = search.substring(1);
      }
      if (search) {
        finalURL += `?${search}`;
      }
      return finalURL;
    }
    function mergeHeaders(...allHeaders) {
      const finalHeaders = new Headers();
      for (const h3 of allHeaders) {
        if (!h3 || typeof h3 !== "object") {
          continue;
        }
        const iterator = h3 instanceof Headers ? h3.entries() : Object.entries(h3);
        for (const [k3, v2] of iterator) {
          if (v2 === null) {
            finalHeaders.delete(k3);
          } else if (Array.isArray(v2)) {
            for (const v22 of v2) {
              finalHeaders.append(k3, v22);
            }
          } else if (v2 !== void 0) {
            finalHeaders.set(k3, v2);
          }
        }
      }
      return finalHeaders;
    }
    function removeTrailingSlash(url) {
      if (url.endsWith("/")) {
        return url.substring(0, url.length - 1);
      }
      return url;
    }
  }
});

// node_modules/@metamask/sdk-analytics/dist/index.js
var require_dist = __commonJS({
  "node_modules/@metamask/sdk-analytics/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to2, key) && key !== except)
            __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to2;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export(index_exports, {
      analytics: () => analytics
    });
    module.exports = __toCommonJS(index_exports);
    var import_openapi_fetch = __toESM2(require_cjs2());
    var Sender = class {
      constructor(options2) {
        this.batch = [];
        this.maxTimeoutMs = 3e4;
        this.timeoutId = null;
        this.isSending = false;
        this.batchSize = options2.batchSize;
        this.baseTimeoutMs = options2.baseTimeoutMs;
        this.currentTimeoutMs = options2.baseTimeoutMs;
        this.sendFn = options2.sendFn;
      }
      enqueue(item) {
        this.batch.push(item);
        this.schedule();
      }
      schedule() {
        if (this.batch.length > 0 && !this.timeoutId) {
          this.timeoutId = setTimeout(() => {
            this.timeoutId = null;
            this.flush();
          }, this.currentTimeoutMs);
        }
      }
      async flush() {
        if (this.isSending || this.batch.length === 0) {
          return;
        }
        this.isSending = true;
        const current = [...this.batch.slice(0, this.batchSize)];
        this.batch = this.batch.slice(this.batchSize);
        try {
          await this.sendFn(current);
          this.currentTimeoutMs = this.baseTimeoutMs;
        } catch (error) {
          console.error("Sender: Failed to send batch", error);
          this.batch = [...current, ...this.batch];
          this.currentTimeoutMs = Math.min(
            this.currentTimeoutMs * 2,
            this.maxTimeoutMs
          );
        } finally {
          this.isSending = false;
          this.schedule();
        }
      }
    };
    var sender_default = Sender;
    var Analytics2 = class {
      constructor(baseUrl) {
        this.enabled = false;
        this.properties = {};
        const client2 = (0, import_openapi_fetch.default)({ baseUrl });
        const sendFn = async (batch) => {
          const res = await client2.POST("/v1/events", { body: batch });
          if (res.response.status !== 200) {
            throw new Error(res.error);
          }
        };
        this.sender = new sender_default({ batchSize: 100, baseTimeoutMs: 200, sendFn });
      }
      enable() {
        this.enabled = true;
      }
      setGlobalProperty(key, value) {
        this.properties[key] = value;
      }
      track(name, properties) {
        if (!this.enabled) {
          return;
        }
        const event = {
          name,
          ...this.properties,
          ...properties
        };
        this.sender.enqueue(event);
      }
    };
    var analytics_default = Analytics2;
    var endpoint;
    var _a2;
    if (typeof process !== "undefined" && process.env) {
      endpoint = (_a2 = process.env.METAMASK_ANALYTICS_ENDPOINT) != null ? _a2 : process.env.NEXT_PUBLIC_METAMASK_ANALYTICS_ENDPOINT;
    }
    var METAMASK_ANALYTICS_ENDPOINT = endpoint != null ? endpoint : "https://mm-sdk-analytics.api.cx.metamask.io/";
    var client = new analytics_default(METAMASK_ANALYTICS_ENDPOINT);
    var analytics = client;
  }
});

// node_modules/void-elements/index.js
var require_void_elements = __commonJS({
  "node_modules/void-elements/index.js"(exports, module) {
    module.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "link": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e8) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e8) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e8) {
        }
        try {
          return func + "";
        } catch (e8) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/qrcode-generator/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode-generator/qrcode.js"(exports, module) {
    var qrcode = function() {
      var qrcode2 = function(typeNumber, errorCorrectionLevel) {
        var PAD0 = 236;
        var PAD1 = 17;
        var _typeNumber = typeNumber;
        var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
        var _modules = null;
        var _moduleCount = 0;
        var _dataCache = null;
        var _dataList = [];
        var _this = {};
        var makeImpl = function(test, maskPattern) {
          _moduleCount = _typeNumber * 4 + 17;
          _modules = function(moduleCount) {
            var modules = new Array(moduleCount);
            for (var row = 0; row < moduleCount; row += 1) {
              modules[row] = new Array(moduleCount);
              for (var col = 0; col < moduleCount; col += 1) {
                modules[row][col] = null;
              }
            }
            return modules;
          }(_moduleCount);
          setupPositionProbePattern(0, 0);
          setupPositionProbePattern(_moduleCount - 7, 0);
          setupPositionProbePattern(0, _moduleCount - 7);
          setupPositionAdjustPattern();
          setupTimingPattern();
          setupTypeInfo(test, maskPattern);
          if (_typeNumber >= 7) {
            setupTypeNumber(test);
          }
          if (_dataCache == null) {
            _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
          }
          mapData(_dataCache, maskPattern);
        };
        var setupPositionProbePattern = function(row, col) {
          for (var r3 = -1; r3 <= 7; r3 += 1) {
            if (row + r3 <= -1 || _moduleCount <= row + r3) continue;
            for (var c2 = -1; c2 <= 7; c2 += 1) {
              if (col + c2 <= -1 || _moduleCount <= col + c2) continue;
              if (0 <= r3 && r3 <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r3 == 0 || r3 == 6) || 2 <= r3 && r3 <= 4 && 2 <= c2 && c2 <= 4) {
                _modules[row + r3][col + c2] = true;
              } else {
                _modules[row + r3][col + c2] = false;
              }
            }
          }
        };
        var getBestMaskPattern = function() {
          var minLostPoint = 0;
          var pattern = 0;
          for (var i2 = 0; i2 < 8; i2 += 1) {
            makeImpl(true, i2);
            var lostPoint = QRUtil.getLostPoint(_this);
            if (i2 == 0 || minLostPoint > lostPoint) {
              minLostPoint = lostPoint;
              pattern = i2;
            }
          }
          return pattern;
        };
        var setupTimingPattern = function() {
          for (var r3 = 8; r3 < _moduleCount - 8; r3 += 1) {
            if (_modules[r3][6] != null) {
              continue;
            }
            _modules[r3][6] = r3 % 2 == 0;
          }
          for (var c2 = 8; c2 < _moduleCount - 8; c2 += 1) {
            if (_modules[6][c2] != null) {
              continue;
            }
            _modules[6][c2] = c2 % 2 == 0;
          }
        };
        var setupPositionAdjustPattern = function() {
          var pos = QRUtil.getPatternPosition(_typeNumber);
          for (var i2 = 0; i2 < pos.length; i2 += 1) {
            for (var j3 = 0; j3 < pos.length; j3 += 1) {
              var row = pos[i2];
              var col = pos[j3];
              if (_modules[row][col] != null) {
                continue;
              }
              for (var r3 = -2; r3 <= 2; r3 += 1) {
                for (var c2 = -2; c2 <= 2; c2 += 1) {
                  if (r3 == -2 || r3 == 2 || c2 == -2 || c2 == 2 || r3 == 0 && c2 == 0) {
                    _modules[row + r3][col + c2] = true;
                  } else {
                    _modules[row + r3][col + c2] = false;
                  }
                }
              }
            }
          }
        };
        var setupTypeNumber = function(test) {
          var bits = QRUtil.getBCHTypeNumber(_typeNumber);
          for (var i2 = 0; i2 < 18; i2 += 1) {
            var mod = !test && (bits >> i2 & 1) == 1;
            _modules[Math.floor(i2 / 3)][i2 % 3 + _moduleCount - 8 - 3] = mod;
          }
          for (var i2 = 0; i2 < 18; i2 += 1) {
            var mod = !test && (bits >> i2 & 1) == 1;
            _modules[i2 % 3 + _moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;
          }
        };
        var setupTypeInfo = function(test, maskPattern) {
          var data = _errorCorrectionLevel << 3 | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data);
          for (var i2 = 0; i2 < 15; i2 += 1) {
            var mod = !test && (bits >> i2 & 1) == 1;
            if (i2 < 6) {
              _modules[i2][8] = mod;
            } else if (i2 < 8) {
              _modules[i2 + 1][8] = mod;
            } else {
              _modules[_moduleCount - 15 + i2][8] = mod;
            }
          }
          for (var i2 = 0; i2 < 15; i2 += 1) {
            var mod = !test && (bits >> i2 & 1) == 1;
            if (i2 < 8) {
              _modules[8][_moduleCount - i2 - 1] = mod;
            } else if (i2 < 9) {
              _modules[8][15 - i2 - 1 + 1] = mod;
            } else {
              _modules[8][15 - i2 - 1] = mod;
            }
          }
          _modules[_moduleCount - 8][8] = !test;
        };
        var mapData = function(data, maskPattern) {
          var inc = -1;
          var row = _moduleCount - 1;
          var bitIndex = 7;
          var byteIndex = 0;
          var maskFunc = QRUtil.getMaskFunction(maskPattern);
          for (var col = _moduleCount - 1; col > 0; col -= 2) {
            if (col == 6) col -= 1;
            while (true) {
              for (var c2 = 0; c2 < 2; c2 += 1) {
                if (_modules[row][col - c2] == null) {
                  var dark = false;
                  if (byteIndex < data.length) {
                    dark = (data[byteIndex] >>> bitIndex & 1) == 1;
                  }
                  var mask = maskFunc(row, col - c2);
                  if (mask) {
                    dark = !dark;
                  }
                  _modules[row][col - c2] = dark;
                  bitIndex -= 1;
                  if (bitIndex == -1) {
                    byteIndex += 1;
                    bitIndex = 7;
                  }
                }
              }
              row += inc;
              if (row < 0 || _moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };
        var createBytes = function(buffer, rsBlocks) {
          var offset = 0;
          var maxDcCount = 0;
          var maxEcCount = 0;
          var dcdata = new Array(rsBlocks.length);
          var ecdata = new Array(rsBlocks.length);
          for (var r3 = 0; r3 < rsBlocks.length; r3 += 1) {
            var dcCount = rsBlocks[r3].dataCount;
            var ecCount = rsBlocks[r3].totalCount - dcCount;
            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);
            dcdata[r3] = new Array(dcCount);
            for (var i2 = 0; i2 < dcdata[r3].length; i2 += 1) {
              dcdata[r3][i2] = 255 & buffer.getBuffer()[i2 + offset];
            }
            offset += dcCount;
            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = qrPolynomial(dcdata[r3], rsPoly.getLength() - 1);
            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r3] = new Array(rsPoly.getLength() - 1);
            for (var i2 = 0; i2 < ecdata[r3].length; i2 += 1) {
              var modIndex = i2 + modPoly.getLength() - ecdata[r3].length;
              ecdata[r3][i2] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
            }
          }
          var totalCodeCount = 0;
          for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {
            totalCodeCount += rsBlocks[i2].totalCount;
          }
          var data = new Array(totalCodeCount);
          var index = 0;
          for (var i2 = 0; i2 < maxDcCount; i2 += 1) {
            for (var r3 = 0; r3 < rsBlocks.length; r3 += 1) {
              if (i2 < dcdata[r3].length) {
                data[index] = dcdata[r3][i2];
                index += 1;
              }
            }
          }
          for (var i2 = 0; i2 < maxEcCount; i2 += 1) {
            for (var r3 = 0; r3 < rsBlocks.length; r3 += 1) {
              if (i2 < ecdata[r3].length) {
                data[index] = ecdata[r3][i2];
                index += 1;
              }
            }
          }
          return data;
        };
        var createData = function(typeNumber2, errorCorrectionLevel2, dataList) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, errorCorrectionLevel2);
          var buffer = qrBitBuffer();
          for (var i2 = 0; i2 < dataList.length; i2 += 1) {
            var data = dataList[i2];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));
            data.write(buffer);
          }
          var totalDataCount = 0;
          for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {
            totalDataCount += rsBlocks[i2].dataCount;
          }
          if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw "code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")";
          }
          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
          }
          while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
          }
          while (true) {
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD0, 8);
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD1, 8);
          }
          return createBytes(buffer, rsBlocks);
        };
        _this.addData = function(data, mode) {
          mode = mode || "Byte";
          var newData = null;
          switch (mode) {
            case "Numeric":
              newData = qrNumber(data);
              break;
            case "Alphanumeric":
              newData = qrAlphaNum(data);
              break;
            case "Byte":
              newData = qr8BitByte(data);
              break;
            case "Kanji":
              newData = qrKanji(data);
              break;
            default:
              throw "mode:" + mode;
          }
          _dataList.push(newData);
          _dataCache = null;
        };
        _this.isDark = function(row, col) {
          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
            throw row + "," + col;
          }
          return _modules[row][col];
        };
        _this.getModuleCount = function() {
          return _moduleCount;
        };
        _this.make = function() {
          if (_typeNumber < 1) {
            var typeNumber2 = 1;
            for (; typeNumber2 < 40; typeNumber2++) {
              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, _errorCorrectionLevel);
              var buffer = qrBitBuffer();
              for (var i2 = 0; i2 < _dataList.length; i2++) {
                var data = _dataList[i2];
                buffer.put(data.getMode(), 4);
                buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));
                data.write(buffer);
              }
              var totalDataCount = 0;
              for (var i2 = 0; i2 < rsBlocks.length; i2++) {
                totalDataCount += rsBlocks[i2].dataCount;
              }
              if (buffer.getLengthInBits() <= totalDataCount * 8) {
                break;
              }
            }
            _typeNumber = typeNumber2;
          }
          makeImpl(false, getBestMaskPattern());
        };
        _this.createTableTag = function(cellSize, margin) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var qrHtml = "";
          qrHtml += '<table style="';
          qrHtml += " border-width: 0px; border-style: none;";
          qrHtml += " border-collapse: collapse;";
          qrHtml += " padding: 0px; margin: " + margin + "px;";
          qrHtml += '">';
          qrHtml += "<tbody>";
          for (var r3 = 0; r3 < _this.getModuleCount(); r3 += 1) {
            qrHtml += "<tr>";
            for (var c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {
              qrHtml += '<td style="';
              qrHtml += " border-width: 0px; border-style: none;";
              qrHtml += " border-collapse: collapse;";
              qrHtml += " padding: 0px; margin: 0px;";
              qrHtml += " width: " + cellSize + "px;";
              qrHtml += " height: " + cellSize + "px;";
              qrHtml += " background-color: ";
              qrHtml += _this.isDark(r3, c2) ? "#000000" : "#ffffff";
              qrHtml += ";";
              qrHtml += '"/>';
            }
            qrHtml += "</tr>";
          }
          qrHtml += "</tbody>";
          qrHtml += "</table>";
          return qrHtml;
        };
        _this.createSvgTag = function(cellSize, margin, alt, title) {
          var opts = {};
          if (typeof arguments[0] == "object") {
            opts = arguments[0];
            cellSize = opts.cellSize;
            margin = opts.margin;
            alt = opts.alt;
            title = opts.title;
          }
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          alt = typeof alt === "string" ? { text: alt } : alt || {};
          alt.text = alt.text || null;
          alt.id = alt.text ? alt.id || "qrcode-description" : null;
          title = typeof title === "string" ? { text: title } : title || {};
          title.text = title.text || null;
          title.id = title.text ? title.id || "qrcode-title" : null;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var c2, mc2, r3, mr2, qrSvg = "", rect;
          rect = "l" + cellSize + ",0 0," + cellSize + " -" + cellSize + ",0 0,-" + cellSize + "z ";
          qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
          qrSvg += !opts.scalable ? ' width="' + size + 'px" height="' + size + 'px"' : "";
          qrSvg += ' viewBox="0 0 ' + size + " " + size + '" ';
          qrSvg += ' preserveAspectRatio="xMinYMin meet"';
          qrSvg += title.text || alt.text ? ' role="img" aria-labelledby="' + escapeXml([title.id, alt.id].join(" ").trim()) + '"' : "";
          qrSvg += ">";
          qrSvg += title.text ? '<title id="' + escapeXml(title.id) + '">' + escapeXml(title.text) + "</title>" : "";
          qrSvg += alt.text ? '<description id="' + escapeXml(alt.id) + '">' + escapeXml(alt.text) + "</description>" : "";
          qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
          qrSvg += '<path d="';
          for (r3 = 0; r3 < _this.getModuleCount(); r3 += 1) {
            mr2 = r3 * cellSize + margin;
            for (c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {
              if (_this.isDark(r3, c2)) {
                mc2 = c2 * cellSize + margin;
                qrSvg += "M" + mc2 + "," + mr2 + rect;
              }
            }
          }
          qrSvg += '" stroke="transparent" fill="black"/>';
          qrSvg += "</svg>";
          return qrSvg;
        };
        _this.createDataURL = function(cellSize, margin) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
          return createDataURL(size, size, function(x3, y3) {
            if (min <= x3 && x3 < max && min <= y3 && y3 < max) {
              var c2 = Math.floor((x3 - min) / cellSize);
              var r3 = Math.floor((y3 - min) / cellSize);
              return _this.isDark(r3, c2) ? 0 : 1;
            } else {
              return 1;
            }
          });
        };
        _this.createImgTag = function(cellSize, margin, alt) {
          cellSize = cellSize || 2;
          margin = typeof margin == "undefined" ? cellSize * 4 : margin;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var img = "";
          img += "<img";
          img += ' src="';
          img += _this.createDataURL(cellSize, margin);
          img += '"';
          img += ' width="';
          img += size;
          img += '"';
          img += ' height="';
          img += size;
          img += '"';
          if (alt) {
            img += ' alt="';
            img += escapeXml(alt);
            img += '"';
          }
          img += "/>";
          return img;
        };
        var escapeXml = function(s) {
          var escaped = "";
          for (var i2 = 0; i2 < s.length; i2 += 1) {
            var c2 = s.charAt(i2);
            switch (c2) {
              case "<":
                escaped += "&lt;";
                break;
              case ">":
                escaped += "&gt;";
                break;
              case "&":
                escaped += "&amp;";
                break;
              case '"':
                escaped += "&quot;";
                break;
              default:
                escaped += c2;
                break;
            }
          }
          return escaped;
        };
        var _createHalfASCII = function(margin) {
          var cellSize = 1;
          margin = typeof margin == "undefined" ? cellSize * 2 : margin;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
          var y3, x3, r1, r22, p3;
          var blocks = {
            "██": "█",
            "█ ": "▀",
            " █": "▄",
            "  ": " "
          };
          var blocksLastLineNoMargin = {
            "██": "▀",
            "█ ": "▀",
            " █": " ",
            "  ": " "
          };
          var ascii = "";
          for (y3 = 0; y3 < size; y3 += 2) {
            r1 = Math.floor((y3 - min) / cellSize);
            r22 = Math.floor((y3 + 1 - min) / cellSize);
            for (x3 = 0; x3 < size; x3 += 1) {
              p3 = "█";
              if (min <= x3 && x3 < max && min <= y3 && y3 < max && _this.isDark(r1, Math.floor((x3 - min) / cellSize))) {
                p3 = " ";
              }
              if (min <= x3 && x3 < max && min <= y3 + 1 && y3 + 1 < max && _this.isDark(r22, Math.floor((x3 - min) / cellSize))) {
                p3 += " ";
              } else {
                p3 += "█";
              }
              ascii += margin < 1 && y3 + 1 >= max ? blocksLastLineNoMargin[p3] : blocks[p3];
            }
            ascii += "\n";
          }
          if (size % 2 && margin > 0) {
            return ascii.substring(0, ascii.length - size - 1) + Array(size + 1).join("▀");
          }
          return ascii.substring(0, ascii.length - 1);
        };
        _this.createASCII = function(cellSize, margin) {
          cellSize = cellSize || 1;
          if (cellSize < 2) {
            return _createHalfASCII(margin);
          }
          cellSize -= 1;
          margin = typeof margin == "undefined" ? cellSize * 2 : margin;
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
          var y3, x3, r3, p3;
          var white = Array(cellSize + 1).join("██");
          var black = Array(cellSize + 1).join("  ");
          var ascii = "";
          var line = "";
          for (y3 = 0; y3 < size; y3 += 1) {
            r3 = Math.floor((y3 - min) / cellSize);
            line = "";
            for (x3 = 0; x3 < size; x3 += 1) {
              p3 = 1;
              if (min <= x3 && x3 < max && min <= y3 && y3 < max && _this.isDark(r3, Math.floor((x3 - min) / cellSize))) {
                p3 = 0;
              }
              line += p3 ? white : black;
            }
            for (r3 = 0; r3 < cellSize; r3 += 1) {
              ascii += line + "\n";
            }
          }
          return ascii.substring(0, ascii.length - 1);
        };
        _this.renderTo2dContext = function(context, cellSize) {
          cellSize = cellSize || 2;
          var length = _this.getModuleCount();
          for (var row = 0; row < length; row++) {
            for (var col = 0; col < length; col++) {
              context.fillStyle = _this.isDark(row, col) ? "black" : "white";
              context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
            }
          }
        };
        return _this;
      };
      qrcode2.stringToBytesFuncs = {
        "default": function(s) {
          var bytes = [];
          for (var i2 = 0; i2 < s.length; i2 += 1) {
            var c2 = s.charCodeAt(i2);
            bytes.push(c2 & 255);
          }
          return bytes;
        }
      };
      qrcode2.stringToBytes = qrcode2.stringToBytesFuncs["default"];
      qrcode2.createStringToBytes = function(unicodeData, numChars) {
        var unicodeMap = function() {
          var bin = base64DecodeInputStream(unicodeData);
          var read = function() {
            var b4 = bin.read();
            if (b4 == -1) throw "eof";
            return b4;
          };
          var count = 0;
          var unicodeMap2 = {};
          while (true) {
            var b0 = bin.read();
            if (b0 == -1) break;
            var b1 = read();
            var b22 = read();
            var b3 = read();
            var k3 = String.fromCharCode(b0 << 8 | b1);
            var v2 = b22 << 8 | b3;
            unicodeMap2[k3] = v2;
            count += 1;
          }
          if (count != numChars) {
            throw count + " != " + numChars;
          }
          return unicodeMap2;
        }();
        var unknownChar = "?".charCodeAt(0);
        return function(s) {
          var bytes = [];
          for (var i2 = 0; i2 < s.length; i2 += 1) {
            var c2 = s.charCodeAt(i2);
            if (c2 < 128) {
              bytes.push(c2);
            } else {
              var b3 = unicodeMap[s.charAt(i2)];
              if (typeof b3 == "number") {
                if ((b3 & 255) == b3) {
                  bytes.push(b3);
                } else {
                  bytes.push(b3 >>> 8);
                  bytes.push(b3 & 255);
                }
              } else {
                bytes.push(unknownChar);
              }
            }
          }
          return bytes;
        };
      };
      var QRMode = {
        MODE_NUMBER: 1 << 0,
        MODE_ALPHA_NUM: 1 << 1,
        MODE_8BIT_BYTE: 1 << 2,
        MODE_KANJI: 1 << 3
      };
      var QRErrorCorrectionLevel = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
      };
      var QRMaskPattern = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
      var QRUtil = function() {
        var PATTERN_POSITION_TABLE = [
          [],
          [6, 18],
          [6, 22],
          [6, 26],
          [6, 30],
          [6, 34],
          [6, 22, 38],
          [6, 24, 42],
          [6, 26, 46],
          [6, 28, 50],
          [6, 30, 54],
          [6, 32, 58],
          [6, 34, 62],
          [6, 26, 46, 66],
          [6, 26, 48, 70],
          [6, 26, 50, 74],
          [6, 30, 54, 78],
          [6, 30, 56, 82],
          [6, 30, 58, 86],
          [6, 34, 62, 90],
          [6, 28, 50, 72, 94],
          [6, 26, 50, 74, 98],
          [6, 30, 54, 78, 102],
          [6, 28, 54, 80, 106],
          [6, 32, 58, 84, 110],
          [6, 30, 58, 86, 114],
          [6, 34, 62, 90, 118],
          [6, 26, 50, 74, 98, 122],
          [6, 30, 54, 78, 102, 126],
          [6, 26, 52, 78, 104, 130],
          [6, 30, 56, 82, 108, 134],
          [6, 34, 60, 86, 112, 138],
          [6, 30, 58, 86, 114, 142],
          [6, 34, 62, 90, 118, 146],
          [6, 30, 54, 78, 102, 126, 150],
          [6, 24, 50, 76, 102, 128, 154],
          [6, 28, 54, 80, 106, 132, 158],
          [6, 32, 58, 84, 110, 136, 162],
          [6, 26, 54, 82, 110, 138, 166],
          [6, 30, 58, 86, 114, 142, 170]
        ];
        var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
        var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
        var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
        var _this = {};
        var getBCHDigit = function(data) {
          var digit = 0;
          while (data != 0) {
            digit += 1;
            data >>>= 1;
          }
          return digit;
        };
        _this.getBCHTypeInfo = function(data) {
          var d3 = data << 10;
          while (getBCHDigit(d3) - getBCHDigit(G15) >= 0) {
            d3 ^= G15 << getBCHDigit(d3) - getBCHDigit(G15);
          }
          return (data << 10 | d3) ^ G15_MASK;
        };
        _this.getBCHTypeNumber = function(data) {
          var d3 = data << 12;
          while (getBCHDigit(d3) - getBCHDigit(G18) >= 0) {
            d3 ^= G18 << getBCHDigit(d3) - getBCHDigit(G18);
          }
          return data << 12 | d3;
        };
        _this.getPatternPosition = function(typeNumber) {
          return PATTERN_POSITION_TABLE[typeNumber - 1];
        };
        _this.getMaskFunction = function(maskPattern) {
          switch (maskPattern) {
            case QRMaskPattern.PATTERN000:
              return function(i2, j3) {
                return (i2 + j3) % 2 == 0;
              };
            case QRMaskPattern.PATTERN001:
              return function(i2, j3) {
                return i2 % 2 == 0;
              };
            case QRMaskPattern.PATTERN010:
              return function(i2, j3) {
                return j3 % 3 == 0;
              };
            case QRMaskPattern.PATTERN011:
              return function(i2, j3) {
                return (i2 + j3) % 3 == 0;
              };
            case QRMaskPattern.PATTERN100:
              return function(i2, j3) {
                return (Math.floor(i2 / 2) + Math.floor(j3 / 3)) % 2 == 0;
              };
            case QRMaskPattern.PATTERN101:
              return function(i2, j3) {
                return i2 * j3 % 2 + i2 * j3 % 3 == 0;
              };
            case QRMaskPattern.PATTERN110:
              return function(i2, j3) {
                return (i2 * j3 % 2 + i2 * j3 % 3) % 2 == 0;
              };
            case QRMaskPattern.PATTERN111:
              return function(i2, j3) {
                return (i2 * j3 % 3 + (i2 + j3) % 2) % 2 == 0;
              };
            default:
              throw "bad maskPattern:" + maskPattern;
          }
        };
        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
          var a = qrPolynomial([1], 0);
          for (var i2 = 0; i2 < errorCorrectLength; i2 += 1) {
            a = a.multiply(qrPolynomial([1, QRMath.gexp(i2)], 0));
          }
          return a;
        };
        _this.getLengthInBits = function(mode, type) {
          if (1 <= type && type < 10) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 10;
              case QRMode.MODE_ALPHA_NUM:
                return 9;
              case QRMode.MODE_8BIT_BYTE:
                return 8;
              case QRMode.MODE_KANJI:
                return 8;
              default:
                throw "mode:" + mode;
            }
          } else if (type < 27) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 12;
              case QRMode.MODE_ALPHA_NUM:
                return 11;
              case QRMode.MODE_8BIT_BYTE:
                return 16;
              case QRMode.MODE_KANJI:
                return 10;
              default:
                throw "mode:" + mode;
            }
          } else if (type < 41) {
            switch (mode) {
              case QRMode.MODE_NUMBER:
                return 14;
              case QRMode.MODE_ALPHA_NUM:
                return 13;
              case QRMode.MODE_8BIT_BYTE:
                return 16;
              case QRMode.MODE_KANJI:
                return 12;
              default:
                throw "mode:" + mode;
            }
          } else {
            throw "type:" + type;
          }
        };
        _this.getLostPoint = function(qrcode3) {
          var moduleCount = qrcode3.getModuleCount();
          var lostPoint = 0;
          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount; col += 1) {
              var sameCount = 0;
              var dark = qrcode3.isDark(row, col);
              for (var r3 = -1; r3 <= 1; r3 += 1) {
                if (row + r3 < 0 || moduleCount <= row + r3) {
                  continue;
                }
                for (var c2 = -1; c2 <= 1; c2 += 1) {
                  if (col + c2 < 0 || moduleCount <= col + c2) {
                    continue;
                  }
                  if (r3 == 0 && c2 == 0) {
                    continue;
                  }
                  if (dark == qrcode3.isDark(row + r3, col + c2)) {
                    sameCount += 1;
                  }
                }
              }
              if (sameCount > 5) {
                lostPoint += 3 + sameCount - 5;
              }
            }
          }
          ;
          for (var row = 0; row < moduleCount - 1; row += 1) {
            for (var col = 0; col < moduleCount - 1; col += 1) {
              var count = 0;
              if (qrcode3.isDark(row, col)) count += 1;
              if (qrcode3.isDark(row + 1, col)) count += 1;
              if (qrcode3.isDark(row, col + 1)) count += 1;
              if (qrcode3.isDark(row + 1, col + 1)) count += 1;
              if (count == 0 || count == 4) {
                lostPoint += 3;
              }
            }
          }
          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount - 6; col += 1) {
              if (qrcode3.isDark(row, col) && !qrcode3.isDark(row, col + 1) && qrcode3.isDark(row, col + 2) && qrcode3.isDark(row, col + 3) && qrcode3.isDark(row, col + 4) && !qrcode3.isDark(row, col + 5) && qrcode3.isDark(row, col + 6)) {
                lostPoint += 40;
              }
            }
          }
          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount - 6; row += 1) {
              if (qrcode3.isDark(row, col) && !qrcode3.isDark(row + 1, col) && qrcode3.isDark(row + 2, col) && qrcode3.isDark(row + 3, col) && qrcode3.isDark(row + 4, col) && !qrcode3.isDark(row + 5, col) && qrcode3.isDark(row + 6, col)) {
                lostPoint += 40;
              }
            }
          }
          var darkCount = 0;
          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount; row += 1) {
              if (qrcode3.isDark(row, col)) {
                darkCount += 1;
              }
            }
          }
          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
          lostPoint += ratio * 10;
          return lostPoint;
        };
        return _this;
      }();
      var QRMath = function() {
        var EXP_TABLE = new Array(256);
        var LOG_TABLE = new Array(256);
        for (var i2 = 0; i2 < 8; i2 += 1) {
          EXP_TABLE[i2] = 1 << i2;
        }
        for (var i2 = 8; i2 < 256; i2 += 1) {
          EXP_TABLE[i2] = EXP_TABLE[i2 - 4] ^ EXP_TABLE[i2 - 5] ^ EXP_TABLE[i2 - 6] ^ EXP_TABLE[i2 - 8];
        }
        for (var i2 = 0; i2 < 255; i2 += 1) {
          LOG_TABLE[EXP_TABLE[i2]] = i2;
        }
        var _this = {};
        _this.glog = function(n2) {
          if (n2 < 1) {
            throw "glog(" + n2 + ")";
          }
          return LOG_TABLE[n2];
        };
        _this.gexp = function(n2) {
          while (n2 < 0) {
            n2 += 255;
          }
          while (n2 >= 256) {
            n2 -= 255;
          }
          return EXP_TABLE[n2];
        };
        return _this;
      }();
      function qrPolynomial(num, shift) {
        if (typeof num.length == "undefined") {
          throw num.length + "/" + shift;
        }
        var _num = function() {
          var offset = 0;
          while (offset < num.length && num[offset] == 0) {
            offset += 1;
          }
          var _num2 = new Array(num.length - offset + shift);
          for (var i2 = 0; i2 < num.length - offset; i2 += 1) {
            _num2[i2] = num[i2 + offset];
          }
          return _num2;
        }();
        var _this = {};
        _this.getAt = function(index) {
          return _num[index];
        };
        _this.getLength = function() {
          return _num.length;
        };
        _this.multiply = function(e8) {
          var num2 = new Array(_this.getLength() + e8.getLength() - 1);
          for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {
            for (var j3 = 0; j3 < e8.getLength(); j3 += 1) {
              num2[i2 + j3] ^= QRMath.gexp(QRMath.glog(_this.getAt(i2)) + QRMath.glog(e8.getAt(j3)));
            }
          }
          return qrPolynomial(num2, 0);
        };
        _this.mod = function(e8) {
          if (_this.getLength() - e8.getLength() < 0) {
            return _this;
          }
          var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e8.getAt(0));
          var num2 = new Array(_this.getLength());
          for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {
            num2[i2] = _this.getAt(i2);
          }
          for (var i2 = 0; i2 < e8.getLength(); i2 += 1) {
            num2[i2] ^= QRMath.gexp(QRMath.glog(e8.getAt(i2)) + ratio);
          }
          return qrPolynomial(num2, 0).mod(e8);
        };
        return _this;
      }
      ;
      var QRRSBlock = function() {
        var RS_BLOCK_TABLE = [
          // L
          // M
          // Q
          // H
          // 1
          [1, 26, 19],
          [1, 26, 16],
          [1, 26, 13],
          [1, 26, 9],
          // 2
          [1, 44, 34],
          [1, 44, 28],
          [1, 44, 22],
          [1, 44, 16],
          // 3
          [1, 70, 55],
          [1, 70, 44],
          [2, 35, 17],
          [2, 35, 13],
          // 4
          [1, 100, 80],
          [2, 50, 32],
          [2, 50, 24],
          [4, 25, 9],
          // 5
          [1, 134, 108],
          [2, 67, 43],
          [2, 33, 15, 2, 34, 16],
          [2, 33, 11, 2, 34, 12],
          // 6
          [2, 86, 68],
          [4, 43, 27],
          [4, 43, 19],
          [4, 43, 15],
          // 7
          [2, 98, 78],
          [4, 49, 31],
          [2, 32, 14, 4, 33, 15],
          [4, 39, 13, 1, 40, 14],
          // 8
          [2, 121, 97],
          [2, 60, 38, 2, 61, 39],
          [4, 40, 18, 2, 41, 19],
          [4, 40, 14, 2, 41, 15],
          // 9
          [2, 146, 116],
          [3, 58, 36, 2, 59, 37],
          [4, 36, 16, 4, 37, 17],
          [4, 36, 12, 4, 37, 13],
          // 10
          [2, 86, 68, 2, 87, 69],
          [4, 69, 43, 1, 70, 44],
          [6, 43, 19, 2, 44, 20],
          [6, 43, 15, 2, 44, 16],
          // 11
          [4, 101, 81],
          [1, 80, 50, 4, 81, 51],
          [4, 50, 22, 4, 51, 23],
          [3, 36, 12, 8, 37, 13],
          // 12
          [2, 116, 92, 2, 117, 93],
          [6, 58, 36, 2, 59, 37],
          [4, 46, 20, 6, 47, 21],
          [7, 42, 14, 4, 43, 15],
          // 13
          [4, 133, 107],
          [8, 59, 37, 1, 60, 38],
          [8, 44, 20, 4, 45, 21],
          [12, 33, 11, 4, 34, 12],
          // 14
          [3, 145, 115, 1, 146, 116],
          [4, 64, 40, 5, 65, 41],
          [11, 36, 16, 5, 37, 17],
          [11, 36, 12, 5, 37, 13],
          // 15
          [5, 109, 87, 1, 110, 88],
          [5, 65, 41, 5, 66, 42],
          [5, 54, 24, 7, 55, 25],
          [11, 36, 12, 7, 37, 13],
          // 16
          [5, 122, 98, 1, 123, 99],
          [7, 73, 45, 3, 74, 46],
          [15, 43, 19, 2, 44, 20],
          [3, 45, 15, 13, 46, 16],
          // 17
          [1, 135, 107, 5, 136, 108],
          [10, 74, 46, 1, 75, 47],
          [1, 50, 22, 15, 51, 23],
          [2, 42, 14, 17, 43, 15],
          // 18
          [5, 150, 120, 1, 151, 121],
          [9, 69, 43, 4, 70, 44],
          [17, 50, 22, 1, 51, 23],
          [2, 42, 14, 19, 43, 15],
          // 19
          [3, 141, 113, 4, 142, 114],
          [3, 70, 44, 11, 71, 45],
          [17, 47, 21, 4, 48, 22],
          [9, 39, 13, 16, 40, 14],
          // 20
          [3, 135, 107, 5, 136, 108],
          [3, 67, 41, 13, 68, 42],
          [15, 54, 24, 5, 55, 25],
          [15, 43, 15, 10, 44, 16],
          // 21
          [4, 144, 116, 4, 145, 117],
          [17, 68, 42],
          [17, 50, 22, 6, 51, 23],
          [19, 46, 16, 6, 47, 17],
          // 22
          [2, 139, 111, 7, 140, 112],
          [17, 74, 46],
          [7, 54, 24, 16, 55, 25],
          [34, 37, 13],
          // 23
          [4, 151, 121, 5, 152, 122],
          [4, 75, 47, 14, 76, 48],
          [11, 54, 24, 14, 55, 25],
          [16, 45, 15, 14, 46, 16],
          // 24
          [6, 147, 117, 4, 148, 118],
          [6, 73, 45, 14, 74, 46],
          [11, 54, 24, 16, 55, 25],
          [30, 46, 16, 2, 47, 17],
          // 25
          [8, 132, 106, 4, 133, 107],
          [8, 75, 47, 13, 76, 48],
          [7, 54, 24, 22, 55, 25],
          [22, 45, 15, 13, 46, 16],
          // 26
          [10, 142, 114, 2, 143, 115],
          [19, 74, 46, 4, 75, 47],
          [28, 50, 22, 6, 51, 23],
          [33, 46, 16, 4, 47, 17],
          // 27
          [8, 152, 122, 4, 153, 123],
          [22, 73, 45, 3, 74, 46],
          [8, 53, 23, 26, 54, 24],
          [12, 45, 15, 28, 46, 16],
          // 28
          [3, 147, 117, 10, 148, 118],
          [3, 73, 45, 23, 74, 46],
          [4, 54, 24, 31, 55, 25],
          [11, 45, 15, 31, 46, 16],
          // 29
          [7, 146, 116, 7, 147, 117],
          [21, 73, 45, 7, 74, 46],
          [1, 53, 23, 37, 54, 24],
          [19, 45, 15, 26, 46, 16],
          // 30
          [5, 145, 115, 10, 146, 116],
          [19, 75, 47, 10, 76, 48],
          [15, 54, 24, 25, 55, 25],
          [23, 45, 15, 25, 46, 16],
          // 31
          [13, 145, 115, 3, 146, 116],
          [2, 74, 46, 29, 75, 47],
          [42, 54, 24, 1, 55, 25],
          [23, 45, 15, 28, 46, 16],
          // 32
          [17, 145, 115],
          [10, 74, 46, 23, 75, 47],
          [10, 54, 24, 35, 55, 25],
          [19, 45, 15, 35, 46, 16],
          // 33
          [17, 145, 115, 1, 146, 116],
          [14, 74, 46, 21, 75, 47],
          [29, 54, 24, 19, 55, 25],
          [11, 45, 15, 46, 46, 16],
          // 34
          [13, 145, 115, 6, 146, 116],
          [14, 74, 46, 23, 75, 47],
          [44, 54, 24, 7, 55, 25],
          [59, 46, 16, 1, 47, 17],
          // 35
          [12, 151, 121, 7, 152, 122],
          [12, 75, 47, 26, 76, 48],
          [39, 54, 24, 14, 55, 25],
          [22, 45, 15, 41, 46, 16],
          // 36
          [6, 151, 121, 14, 152, 122],
          [6, 75, 47, 34, 76, 48],
          [46, 54, 24, 10, 55, 25],
          [2, 45, 15, 64, 46, 16],
          // 37
          [17, 152, 122, 4, 153, 123],
          [29, 74, 46, 14, 75, 47],
          [49, 54, 24, 10, 55, 25],
          [24, 45, 15, 46, 46, 16],
          // 38
          [4, 152, 122, 18, 153, 123],
          [13, 74, 46, 32, 75, 47],
          [48, 54, 24, 14, 55, 25],
          [42, 45, 15, 32, 46, 16],
          // 39
          [20, 147, 117, 4, 148, 118],
          [40, 75, 47, 7, 76, 48],
          [43, 54, 24, 22, 55, 25],
          [10, 45, 15, 67, 46, 16],
          // 40
          [19, 148, 118, 6, 149, 119],
          [18, 75, 47, 31, 76, 48],
          [34, 54, 24, 34, 55, 25],
          [20, 45, 15, 61, 46, 16]
        ];
        var qrRSBlock = function(totalCount, dataCount) {
          var _this2 = {};
          _this2.totalCount = totalCount;
          _this2.dataCount = dataCount;
          return _this2;
        };
        var _this = {};
        var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {
          switch (errorCorrectionLevel) {
            case QRErrorCorrectionLevel.L:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
            case QRErrorCorrectionLevel.M:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
            case QRErrorCorrectionLevel.Q:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
            case QRErrorCorrectionLevel.H:
              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
            default:
              return void 0;
          }
        };
        _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {
          var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);
          if (typeof rsBlock == "undefined") {
            throw "bad rs block @ typeNumber:" + typeNumber + "/errorCorrectionLevel:" + errorCorrectionLevel;
          }
          var length = rsBlock.length / 3;
          var list = [];
          for (var i2 = 0; i2 < length; i2 += 1) {
            var count = rsBlock[i2 * 3 + 0];
            var totalCount = rsBlock[i2 * 3 + 1];
            var dataCount = rsBlock[i2 * 3 + 2];
            for (var j3 = 0; j3 < count; j3 += 1) {
              list.push(qrRSBlock(totalCount, dataCount));
            }
          }
          return list;
        };
        return _this;
      }();
      var qrBitBuffer = function() {
        var _buffer = [];
        var _length = 0;
        var _this = {};
        _this.getBuffer = function() {
          return _buffer;
        };
        _this.getAt = function(index) {
          var bufIndex = Math.floor(index / 8);
          return (_buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
        };
        _this.put = function(num, length) {
          for (var i2 = 0; i2 < length; i2 += 1) {
            _this.putBit((num >>> length - i2 - 1 & 1) == 1);
          }
        };
        _this.getLengthInBits = function() {
          return _length;
        };
        _this.putBit = function(bit) {
          var bufIndex = Math.floor(_length / 8);
          if (_buffer.length <= bufIndex) {
            _buffer.push(0);
          }
          if (bit) {
            _buffer[bufIndex] |= 128 >>> _length % 8;
          }
          _length += 1;
        };
        return _this;
      };
      var qrNumber = function(data) {
        var _mode = QRMode.MODE_NUMBER;
        var _data = data;
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer) {
          return _data.length;
        };
        _this.write = function(buffer) {
          var data2 = _data;
          var i2 = 0;
          while (i2 + 2 < data2.length) {
            buffer.put(strToNum(data2.substring(i2, i2 + 3)), 10);
            i2 += 3;
          }
          if (i2 < data2.length) {
            if (data2.length - i2 == 1) {
              buffer.put(strToNum(data2.substring(i2, i2 + 1)), 4);
            } else if (data2.length - i2 == 2) {
              buffer.put(strToNum(data2.substring(i2, i2 + 2)), 7);
            }
          }
        };
        var strToNum = function(s) {
          var num = 0;
          for (var i2 = 0; i2 < s.length; i2 += 1) {
            num = num * 10 + chatToNum(s.charAt(i2));
          }
          return num;
        };
        var chatToNum = function(c2) {
          if ("0" <= c2 && c2 <= "9") {
            return c2.charCodeAt(0) - "0".charCodeAt(0);
          }
          throw "illegal char :" + c2;
        };
        return _this;
      };
      var qrAlphaNum = function(data) {
        var _mode = QRMode.MODE_ALPHA_NUM;
        var _data = data;
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer) {
          return _data.length;
        };
        _this.write = function(buffer) {
          var s = _data;
          var i2 = 0;
          while (i2 + 1 < s.length) {
            buffer.put(
              getCode(s.charAt(i2)) * 45 + getCode(s.charAt(i2 + 1)),
              11
            );
            i2 += 2;
          }
          if (i2 < s.length) {
            buffer.put(getCode(s.charAt(i2)), 6);
          }
        };
        var getCode = function(c2) {
          if ("0" <= c2 && c2 <= "9") {
            return c2.charCodeAt(0) - "0".charCodeAt(0);
          } else if ("A" <= c2 && c2 <= "Z") {
            return c2.charCodeAt(0) - "A".charCodeAt(0) + 10;
          } else {
            switch (c2) {
              case " ":
                return 36;
              case "$":
                return 37;
              case "%":
                return 38;
              case "*":
                return 39;
              case "+":
                return 40;
              case "-":
                return 41;
              case ".":
                return 42;
              case "/":
                return 43;
              case ":":
                return 44;
              default:
                throw "illegal char :" + c2;
            }
          }
        };
        return _this;
      };
      var qr8BitByte = function(data) {
        var _mode = QRMode.MODE_8BIT_BYTE;
        var _data = data;
        var _bytes = qrcode2.stringToBytes(data);
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer) {
          return _bytes.length;
        };
        _this.write = function(buffer) {
          for (var i2 = 0; i2 < _bytes.length; i2 += 1) {
            buffer.put(_bytes[i2], 8);
          }
        };
        return _this;
      };
      var qrKanji = function(data) {
        var _mode = QRMode.MODE_KANJI;
        var _data = data;
        var stringToBytes = qrcode2.stringToBytesFuncs["SJIS"];
        if (!stringToBytes) {
          throw "sjis not supported.";
        }
        !function(c2, code) {
          var test = stringToBytes(c2);
          if (test.length != 2 || (test[0] << 8 | test[1]) != code) {
            throw "sjis not supported.";
          }
        }("友", 38726);
        var _bytes = stringToBytes(data);
        var _this = {};
        _this.getMode = function() {
          return _mode;
        };
        _this.getLength = function(buffer) {
          return ~~(_bytes.length / 2);
        };
        _this.write = function(buffer) {
          var data2 = _bytes;
          var i2 = 0;
          while (i2 + 1 < data2.length) {
            var c2 = (255 & data2[i2]) << 8 | 255 & data2[i2 + 1];
            if (33088 <= c2 && c2 <= 40956) {
              c2 -= 33088;
            } else if (57408 <= c2 && c2 <= 60351) {
              c2 -= 49472;
            } else {
              throw "illegal char at " + (i2 + 1) + "/" + c2;
            }
            c2 = (c2 >>> 8 & 255) * 192 + (c2 & 255);
            buffer.put(c2, 13);
            i2 += 2;
          }
          if (i2 < data2.length) {
            throw "illegal char at " + (i2 + 1);
          }
        };
        return _this;
      };
      var byteArrayOutputStream = function() {
        var _bytes = [];
        var _this = {};
        _this.writeByte = function(b3) {
          _bytes.push(b3 & 255);
        };
        _this.writeShort = function(i2) {
          _this.writeByte(i2);
          _this.writeByte(i2 >>> 8);
        };
        _this.writeBytes = function(b3, off, len) {
          off = off || 0;
          len = len || b3.length;
          for (var i2 = 0; i2 < len; i2 += 1) {
            _this.writeByte(b3[i2 + off]);
          }
        };
        _this.writeString = function(s) {
          for (var i2 = 0; i2 < s.length; i2 += 1) {
            _this.writeByte(s.charCodeAt(i2));
          }
        };
        _this.toByteArray = function() {
          return _bytes;
        };
        _this.toString = function() {
          var s = "";
          s += "[";
          for (var i2 = 0; i2 < _bytes.length; i2 += 1) {
            if (i2 > 0) {
              s += ",";
            }
            s += _bytes[i2];
          }
          s += "]";
          return s;
        };
        return _this;
      };
      var base64EncodeOutputStream = function() {
        var _buffer = 0;
        var _buflen = 0;
        var _length = 0;
        var _base64 = "";
        var _this = {};
        var writeEncoded = function(b3) {
          _base64 += String.fromCharCode(encode(b3 & 63));
        };
        var encode = function(n2) {
          if (n2 < 0) {
          } else if (n2 < 26) {
            return 65 + n2;
          } else if (n2 < 52) {
            return 97 + (n2 - 26);
          } else if (n2 < 62) {
            return 48 + (n2 - 52);
          } else if (n2 == 62) {
            return 43;
          } else if (n2 == 63) {
            return 47;
          }
          throw "n:" + n2;
        };
        _this.writeByte = function(n2) {
          _buffer = _buffer << 8 | n2 & 255;
          _buflen += 8;
          _length += 1;
          while (_buflen >= 6) {
            writeEncoded(_buffer >>> _buflen - 6);
            _buflen -= 6;
          }
        };
        _this.flush = function() {
          if (_buflen > 0) {
            writeEncoded(_buffer << 6 - _buflen);
            _buffer = 0;
            _buflen = 0;
          }
          if (_length % 3 != 0) {
            var padlen = 3 - _length % 3;
            for (var i2 = 0; i2 < padlen; i2 += 1) {
              _base64 += "=";
            }
          }
        };
        _this.toString = function() {
          return _base64;
        };
        return _this;
      };
      var base64DecodeInputStream = function(str) {
        var _str = str;
        var _pos = 0;
        var _buffer = 0;
        var _buflen = 0;
        var _this = {};
        _this.read = function() {
          while (_buflen < 8) {
            if (_pos >= _str.length) {
              if (_buflen == 0) {
                return -1;
              }
              throw "unexpected end of file./" + _buflen;
            }
            var c2 = _str.charAt(_pos);
            _pos += 1;
            if (c2 == "=") {
              _buflen = 0;
              return -1;
            } else if (c2.match(/^\s$/)) {
              continue;
            }
            _buffer = _buffer << 6 | decode(c2.charCodeAt(0));
            _buflen += 6;
          }
          var n2 = _buffer >>> _buflen - 8 & 255;
          _buflen -= 8;
          return n2;
        };
        var decode = function(c2) {
          if (65 <= c2 && c2 <= 90) {
            return c2 - 65;
          } else if (97 <= c2 && c2 <= 122) {
            return c2 - 97 + 26;
          } else if (48 <= c2 && c2 <= 57) {
            return c2 - 48 + 52;
          } else if (c2 == 43) {
            return 62;
          } else if (c2 == 47) {
            return 63;
          } else {
            throw "c:" + c2;
          }
        };
        return _this;
      };
      var gifImage = function(width, height) {
        var _width = width;
        var _height = height;
        var _data = new Array(width * height);
        var _this = {};
        _this.setPixel = function(x3, y3, pixel) {
          _data[y3 * _width + x3] = pixel;
        };
        _this.write = function(out) {
          out.writeString("GIF87a");
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(128);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(0);
          out.writeByte(255);
          out.writeByte(255);
          out.writeByte(255);
          out.writeString(",");
          out.writeShort(0);
          out.writeShort(0);
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(0);
          var lzwMinCodeSize = 2;
          var raster = getLZWRaster(lzwMinCodeSize);
          out.writeByte(lzwMinCodeSize);
          var offset = 0;
          while (raster.length - offset > 255) {
            out.writeByte(255);
            out.writeBytes(raster, offset, 255);
            offset += 255;
          }
          out.writeByte(raster.length - offset);
          out.writeBytes(raster, offset, raster.length - offset);
          out.writeByte(0);
          out.writeString(";");
        };
        var bitOutputStream = function(out) {
          var _out = out;
          var _bitLength = 0;
          var _bitBuffer = 0;
          var _this2 = {};
          _this2.write = function(data, length) {
            if (data >>> length != 0) {
              throw "length over";
            }
            while (_bitLength + length >= 8) {
              _out.writeByte(255 & (data << _bitLength | _bitBuffer));
              length -= 8 - _bitLength;
              data >>>= 8 - _bitLength;
              _bitBuffer = 0;
              _bitLength = 0;
            }
            _bitBuffer = data << _bitLength | _bitBuffer;
            _bitLength = _bitLength + length;
          };
          _this2.flush = function() {
            if (_bitLength > 0) {
              _out.writeByte(_bitBuffer);
            }
          };
          return _this2;
        };
        var getLZWRaster = function(lzwMinCodeSize) {
          var clearCode = 1 << lzwMinCodeSize;
          var endCode = (1 << lzwMinCodeSize) + 1;
          var bitLength = lzwMinCodeSize + 1;
          var table = lzwTable();
          for (var i2 = 0; i2 < clearCode; i2 += 1) {
            table.add(String.fromCharCode(i2));
          }
          table.add(String.fromCharCode(clearCode));
          table.add(String.fromCharCode(endCode));
          var byteOut = byteArrayOutputStream();
          var bitOut = bitOutputStream(byteOut);
          bitOut.write(clearCode, bitLength);
          var dataIndex = 0;
          var s = String.fromCharCode(_data[dataIndex]);
          dataIndex += 1;
          while (dataIndex < _data.length) {
            var c2 = String.fromCharCode(_data[dataIndex]);
            dataIndex += 1;
            if (table.contains(s + c2)) {
              s = s + c2;
            } else {
              bitOut.write(table.indexOf(s), bitLength);
              if (table.size() < 4095) {
                if (table.size() == 1 << bitLength) {
                  bitLength += 1;
                }
                table.add(s + c2);
              }
              s = c2;
            }
          }
          bitOut.write(table.indexOf(s), bitLength);
          bitOut.write(endCode, bitLength);
          bitOut.flush();
          return byteOut.toByteArray();
        };
        var lzwTable = function() {
          var _map = {};
          var _size = 0;
          var _this2 = {};
          _this2.add = function(key) {
            if (_this2.contains(key)) {
              throw "dup key:" + key;
            }
            _map[key] = _size;
            _size += 1;
          };
          _this2.size = function() {
            return _size;
          };
          _this2.indexOf = function(key) {
            return _map[key];
          };
          _this2.contains = function(key) {
            return typeof _map[key] != "undefined";
          };
          return _this2;
        };
        return _this;
      };
      var createDataURL = function(width, height, getPixel) {
        var gif = gifImage(width, height);
        for (var y3 = 0; y3 < height; y3 += 1) {
          for (var x3 = 0; x3 < width; x3 += 1) {
            gif.setPixel(x3, y3, getPixel(x3, y3));
          }
        }
        var b3 = byteArrayOutputStream();
        gif.write(b3);
        var base64 = base64EncodeOutputStream();
        var bytes = b3.toByteArray();
        for (var i2 = 0; i2 < bytes.length; i2 += 1) {
          base64.writeByte(bytes[i2]);
        }
        base64.flush();
        return "data:image/gif;base64," + base64;
      };
      return qrcode2;
    }();
    !function() {
      qrcode.stringToBytesFuncs["UTF-8"] = function(s) {
        function toUTF8Array(str) {
          var utf8 = [];
          for (var i2 = 0; i2 < str.length; i2++) {
            var charcode = str.charCodeAt(i2);
            if (charcode < 128) utf8.push(charcode);
            else if (charcode < 2048) {
              utf8.push(
                192 | charcode >> 6,
                128 | charcode & 63
              );
            } else if (charcode < 55296 || charcode >= 57344) {
              utf8.push(
                224 | charcode >> 12,
                128 | charcode >> 6 & 63,
                128 | charcode & 63
              );
            } else {
              i2++;
              charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i2) & 1023);
              utf8.push(
                240 | charcode >> 18,
                128 | charcode >> 12 & 63,
                128 | charcode >> 6 & 63,
                128 | charcode & 63
              );
            }
          }
          return utf8;
        }
        return toUTF8Array(s);
      };
    }();
    (function(factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      }
    })(function() {
      return qrcode;
    });
  }
});

// node_modules/react-qrcode-logo/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/react-qrcode-logo/dist/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d3, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
          d4.__proto__ = b4;
        } || function(d4, b4) {
          for (var p3 in b4) if (Object.prototype.hasOwnProperty.call(b4, p3)) d4[p3] = b4[p3];
        };
        return extendStatics(d3, b3);
      };
      return function(d3, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d3, b3);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t3) {
        for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s = arguments[i2];
          for (var p3 in s) if (Object.prototype.hasOwnProperty.call(s, p3))
            t3[p3] = s[p3];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCode = void 0;
    var isEqual = require_lodash();
    var qrGenerator = require_qrcode();
    var React2 = require_react();
    var QRCode2 = (
      /** @class */
      function(_super) {
        __extends(QRCode3, _super);
        function QRCode3(props) {
          var _this = _super.call(this, props) || this;
          _this.canvasRef = React2.createRef();
          return _this;
        }
        QRCode3.prototype.download = function(fileType, fileName) {
          if (this.canvasRef.current) {
            var mimeType = void 0;
            switch (fileType) {
              case "jpg":
                mimeType = "image/jpeg";
                break;
              case "webp":
                mimeType = "image/webp";
                break;
              case "png":
              default:
                mimeType = "image/png";
                break;
            }
            var url = this.canvasRef.current.toDataURL(mimeType, 1);
            var link = document.createElement("a");
            link.download = fileName !== null && fileName !== void 0 ? fileName : "react-qrcode-logo";
            link.href = url;
            link.click();
          }
        };
        QRCode3.prototype.utf16to8 = function(str) {
          var out = "", i2, c2;
          var len = str.length;
          for (i2 = 0; i2 < len; i2++) {
            c2 = str.charCodeAt(i2);
            if (c2 >= 1 && c2 <= 127) {
              out += str.charAt(i2);
            } else if (c2 > 2047) {
              out += String.fromCharCode(224 | c2 >> 12 & 15);
              out += String.fromCharCode(128 | c2 >> 6 & 63);
              out += String.fromCharCode(128 | c2 >> 0 & 63);
            } else {
              out += String.fromCharCode(192 | c2 >> 6 & 31);
              out += String.fromCharCode(128 | c2 >> 0 & 63);
            }
          }
          return out;
        };
        QRCode3.prototype.drawRoundedSquare = function(lineWidth, x3, y3, size, color, radii, fill, ctx) {
          ctx.lineWidth = lineWidth;
          ctx.fillStyle = color;
          ctx.strokeStyle = color;
          y3 += lineWidth / 2;
          x3 += lineWidth / 2;
          size -= lineWidth;
          if (!Array.isArray(radii)) {
            radii = [radii, radii, radii, radii];
          }
          radii = radii.map(function(r3) {
            r3 = Math.min(r3, size / 2);
            return r3 < 0 ? 0 : r3;
          });
          var rTopLeft = radii[0] || 0;
          var rTopRight = radii[1] || 0;
          var rBottomRight = radii[2] || 0;
          var rBottomLeft = radii[3] || 0;
          ctx.beginPath();
          ctx.moveTo(x3 + rTopLeft, y3);
          ctx.lineTo(x3 + size - rTopRight, y3);
          if (rTopRight)
            ctx.quadraticCurveTo(x3 + size, y3, x3 + size, y3 + rTopRight);
          ctx.lineTo(x3 + size, y3 + size - rBottomRight);
          if (rBottomRight)
            ctx.quadraticCurveTo(x3 + size, y3 + size, x3 + size - rBottomRight, y3 + size);
          ctx.lineTo(x3 + rBottomLeft, y3 + size);
          if (rBottomLeft)
            ctx.quadraticCurveTo(x3, y3 + size, x3, y3 + size - rBottomLeft);
          ctx.lineTo(x3, y3 + rTopLeft);
          if (rTopLeft)
            ctx.quadraticCurveTo(x3, y3, x3 + rTopLeft, y3);
          ctx.closePath();
          ctx.stroke();
          if (fill) {
            ctx.fill();
          }
        };
        QRCode3.prototype.drawPositioningPattern = function(ctx, cellSize, offset, row, col, color, radii) {
          if (radii === void 0) {
            radii = [0, 0, 0, 0];
          }
          var lineWidth = Math.ceil(cellSize);
          var radiiOuter;
          var radiiInner;
          if (typeof radii !== "number" && !Array.isArray(radii)) {
            radiiOuter = radii.outer || 0;
            radiiInner = radii.inner || 0;
          } else {
            radiiOuter = radii;
            radiiInner = radiiOuter;
          }
          var colorOuter;
          var colorInner;
          if (typeof color !== "string") {
            colorOuter = color.outer;
            colorInner = color.inner;
          } else {
            colorOuter = color;
            colorInner = color;
          }
          var y3 = row * cellSize + offset;
          var x3 = col * cellSize + offset;
          var size = cellSize * 7;
          this.drawRoundedSquare(lineWidth, x3, y3, size, colorOuter, radiiOuter, false, ctx);
          size = cellSize * 3;
          y3 += cellSize * 2;
          x3 += cellSize * 2;
          this.drawRoundedSquare(lineWidth, x3, y3, size, colorInner, radiiInner, true, ctx);
        };
        ;
        QRCode3.prototype.isInPositioninZone = function(col, row, zones) {
          return zones.some(function(zone) {
            return row >= zone.row && row <= zone.row + 7 && col >= zone.col && col <= zone.col + 7;
          });
        };
        QRCode3.prototype.transformPixelLengthIntoNumberOfCells = function(pixelLength, cellSize) {
          return pixelLength / cellSize;
        };
        QRCode3.prototype.isCoordinateInImage = function(col, row, dWidthLogo, dHeightLogo, dxLogo, dyLogo, cellSize, logoImage) {
          if (logoImage) {
            var numberOfCellsMargin = 2;
            var firstRowOfLogo = this.transformPixelLengthIntoNumberOfCells(dxLogo, cellSize);
            var firstColumnOfLogo = this.transformPixelLengthIntoNumberOfCells(dyLogo, cellSize);
            var logoWidthInCells = this.transformPixelLengthIntoNumberOfCells(dWidthLogo, cellSize) - 1;
            var logoHeightInCells = this.transformPixelLengthIntoNumberOfCells(dHeightLogo, cellSize) - 1;
            return row >= firstRowOfLogo - numberOfCellsMargin && row <= firstRowOfLogo + logoWidthInCells + numberOfCellsMargin && col >= firstColumnOfLogo - numberOfCellsMargin && col <= firstColumnOfLogo + logoHeightInCells + numberOfCellsMargin;
          } else {
            return false;
          }
        };
        QRCode3.prototype.shouldComponentUpdate = function(nextProps) {
          return !isEqual(this.props, nextProps);
        };
        QRCode3.prototype.componentDidMount = function() {
          this.update();
        };
        QRCode3.prototype.componentDidUpdate = function() {
          this.update();
        };
        QRCode3.prototype.update = function() {
          var _a2;
          var _b = this.props, value = _b.value, ecLevel = _b.ecLevel, enableCORS = _b.enableCORS, bgColor = _b.bgColor, fgColor = _b.fgColor, logoImage = _b.logoImage, logoOpacity = _b.logoOpacity, logoOnLoad = _b.logoOnLoad, removeQrCodeBehindLogo = _b.removeQrCodeBehindLogo, qrStyle = _b.qrStyle, eyeRadius = _b.eyeRadius, eyeColor = _b.eyeColor, logoPaddingStyle = _b.logoPaddingStyle;
          var size = +this.props.size;
          var quietZone = +this.props.quietZone;
          var logoWidth = this.props.logoWidth ? +this.props.logoWidth : 0;
          var logoHeight = this.props.logoHeight ? +this.props.logoHeight : 0;
          var logoPadding = this.props.logoPadding ? +this.props.logoPadding : 0;
          var qrCode = qrGenerator(0, ecLevel);
          qrCode.addData(this.utf16to8(value));
          qrCode.make();
          var canvas = (_a2 = this.canvasRef) === null || _a2 === void 0 ? void 0 : _a2.current;
          var ctx = canvas.getContext("2d");
          var canvasSize = size + 2 * quietZone;
          var length = qrCode.getModuleCount();
          var cellSize = size / length;
          var scale = window.devicePixelRatio || 1;
          canvas.height = canvas.width = canvasSize * scale;
          ctx.scale(scale, scale);
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, canvasSize, canvasSize);
          var offset = quietZone;
          var positioningZones = [
            { row: 0, col: 0 },
            { row: 0, col: length - 7 },
            { row: length - 7, col: 0 }
          ];
          ctx.strokeStyle = fgColor;
          if (qrStyle === "dots") {
            ctx.fillStyle = fgColor;
            var radius = cellSize / 2;
            for (var row = 0; row < length; row++) {
              for (var col = 0; col < length; col++) {
                if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {
                  ctx.beginPath();
                  ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, radius / 100 * 75, 0, 2 * Math.PI, false);
                  ctx.closePath();
                  ctx.fill();
                }
              }
            }
          } else if (qrStyle === "fluid") {
            var radius = Math.ceil(cellSize / 2);
            for (var row = 0; row < length; row++) {
              for (var col = 0; col < length; col++) {
                if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {
                  var roundedCorners = [false, false, false, false];
                  if (row > 0 && !qrCode.isDark(row - 1, col) && (col > 0 && !qrCode.isDark(row, col - 1)))
                    roundedCorners[0] = true;
                  if (row > 0 && !qrCode.isDark(row - 1, col) && (col < length - 1 && !qrCode.isDark(row, col + 1)))
                    roundedCorners[1] = true;
                  if (row < length - 1 && !qrCode.isDark(row + 1, col) && (col < length - 1 && !qrCode.isDark(row, col + 1)))
                    roundedCorners[2] = true;
                  if (row < length - 1 && !qrCode.isDark(row + 1, col) && (col > 0 && !qrCode.isDark(row, col - 1)))
                    roundedCorners[3] = true;
                  var w2 = Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize);
                  var h3 = Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize);
                  ctx.fillStyle = fgColor;
                  ctx.beginPath();
                  ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, radius, 0, 2 * Math.PI, false);
                  ctx.closePath();
                  ctx.fill();
                  if (!roundedCorners[0])
                    ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w2 / 2, h3 / 2);
                  if (!roundedCorners[1])
                    ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w2 / 2), Math.round(row * cellSize) + offset, w2 / 2, h3 / 2);
                  if (!roundedCorners[2])
                    ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w2 / 2), Math.round(row * cellSize) + offset + Math.floor(h3 / 2), w2 / 2, h3 / 2);
                  if (!roundedCorners[3])
                    ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset + Math.floor(h3 / 2), w2 / 2, h3 / 2);
                }
              }
            }
          } else {
            for (var row = 0; row < length; row++) {
              for (var col = 0; col < length; col++) {
                if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {
                  ctx.fillStyle = fgColor;
                  var w2 = Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize);
                  var h3 = Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize);
                  ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w2, h3);
                }
              }
            }
          }
          for (var i2 = 0; i2 < 3; i2++) {
            var _c2 = positioningZones[i2], row = _c2.row, col = _c2.col;
            var radii = eyeRadius;
            var color = void 0;
            if (Array.isArray(radii)) {
              radii = radii[i2];
            }
            if (typeof radii == "number") {
              radii = [radii, radii, radii, radii];
            }
            if (!eyeColor) {
              color = fgColor;
            } else {
              if (Array.isArray(eyeColor)) {
                color = eyeColor[i2];
              } else {
                color = eyeColor;
              }
            }
            this.drawPositioningPattern(ctx, cellSize, offset, row, col, color, radii);
          }
          if (logoImage) {
            var image_1 = new Image();
            if (enableCORS) {
              image_1.crossOrigin = "Anonymous";
            }
            image_1.onload = function(e8) {
              ctx.save();
              var dWidthLogo = logoWidth || size * 0.2;
              var dHeightLogo = logoHeight || dWidthLogo;
              var dxLogo = (size - dWidthLogo) / 2;
              var dyLogo = (size - dHeightLogo) / 2;
              if (removeQrCodeBehindLogo || logoPadding) {
                ctx.beginPath();
                ctx.strokeStyle = bgColor;
                ctx.fillStyle = bgColor;
                var dWidthLogoPadding = dWidthLogo + 2 * logoPadding;
                var dHeightLogoPadding = dHeightLogo + 2 * logoPadding;
                var dxLogoPadding = dxLogo + offset - logoPadding;
                var dyLogoPadding = dyLogo + offset - logoPadding;
                if (logoPaddingStyle === "circle") {
                  var dxCenterLogoPadding = dxLogoPadding + dWidthLogoPadding / 2;
                  var dyCenterLogoPadding = dyLogoPadding + dHeightLogoPadding / 2;
                  ctx.ellipse(dxCenterLogoPadding, dyCenterLogoPadding, dWidthLogoPadding / 2, dHeightLogoPadding / 2, 0, 0, 2 * Math.PI);
                  ctx.stroke();
                  ctx.fill();
                } else {
                  ctx.fillRect(dxLogoPadding, dyLogoPadding, dWidthLogoPadding, dHeightLogoPadding);
                }
              }
              ctx.globalAlpha = logoOpacity;
              ctx.drawImage(image_1, dxLogo + offset, dyLogo + offset, dWidthLogo, dHeightLogo);
              ctx.restore();
              if (logoOnLoad) {
                logoOnLoad(e8);
              }
            };
            image_1.src = logoImage;
          }
        };
        QRCode3.prototype.render = function() {
          var _a2;
          var qrSize = +this.props.size + 2 * +this.props.quietZone;
          return React2.createElement("canvas", { id: (_a2 = this.props.id) !== null && _a2 !== void 0 ? _a2 : "react-qrcode-logo", height: qrSize, width: qrSize, style: __assign({ height: qrSize + "px", width: qrSize + "px" }, this.props.style), ref: this.canvasRef });
        };
        QRCode3.defaultProps = {
          value: "https://reactjs.org/",
          ecLevel: "M",
          enableCORS: false,
          size: 150,
          quietZone: 10,
          bgColor: "#FFFFFF",
          fgColor: "#000000",
          logoOpacity: 1,
          qrStyle: "squares",
          eyeRadius: [0, 0, 0],
          logoPaddingStyle: "square"
        };
        return QRCode3;
      }(React2.Component)
    );
    exports.QRCode = QRCode2;
  }
});

// node_modules/@web3auth/no-modal/dist/lib.esm/base/deserialize.js
function deserialize(value, reviver) {
  return JSON.parse(value, (key, value_) => {
    var _value, _value2, _reviver;
    let value2 = value_;
    if (((_value = value2) === null || _value === void 0 ? void 0 : _value.__type) === "bigint") value2 = BigInt(value2.value);
    if (((_value2 = value2) === null || _value2 === void 0 ? void 0 : _value2.__type) === "Map") value2 = new Map(value2.value);
    return (_reviver = void 0) !== null && _reviver !== void 0 ? _reviver : value2;
  });
}

// node_modules/@web3auth/no-modal/dist/lib.esm/base/cookie.js
var cookieStorage = (options2) => ({
  getItem(key) {
    if (typeof window === "undefined") return null;
    const value = parseCookie(document.cookie, key);
    return value !== null && value !== void 0 ? value : null;
  },
  setItem(key, value) {
    if (typeof window === "undefined") return;
    let cookieString = `${key}=${value};path=/;samesite=Lax`;
    if (options2 !== null && options2 !== void 0 && options2.expiry && typeof options2.expiry === "number") cookieString += `; expires=${new Date(Date.now() + options2.expiry).toUTCString()}`;
    if (false) cookieString += "; secure";
    document.cookie = cookieString;
  },
  removeItem(key) {
    if (typeof window === "undefined") return;
    document.cookie = `${key}=;max-age=-1;path=/`;
  }
});
function cookieToWeb3AuthState(cookie) {
  if (!cookie) return void 0;
  const parsed = parseCookie(cookie, WEB3AUTH_STATE_STORAGE_KEY);
  if (!parsed) return void 0;
  return deserialize(parsed);
}
function parseCookie(cookie, key) {
  const keyValue = cookie.split("; ").find((x3) => x3.startsWith(`${key}=`));
  if (!keyValue) return void 0;
  return keyValue.substring(key.length + 1);
}

// node_modules/@web3auth/no-modal/dist/lib.esm/connectors/auth-connector/authConnector.js
var import_deepmerge = __toESM(require_cjs());
var AuthConnector = class extends BaseConnector {
  constructor(params) {
    super(params);
    _defineProperty(this, "name", WALLET_CONNECTORS.AUTH);
    _defineProperty(this, "connectorNamespace", CONNECTOR_NAMESPACES.MULTICHAIN);
    _defineProperty(this, "type", CONNECTOR_CATEGORY.IN_APP);
    _defineProperty(this, "authInstance", null);
    _defineProperty(this, "status", CONNECTOR_STATUS.NOT_READY);
    _defineProperty(this, "privateKeyProvider", null);
    _defineProperty(this, "authOptions", void 0);
    _defineProperty(this, "loginSettings", {
      authConnection: ""
    });
    _defineProperty(this, "wsSettings", void 0);
    _defineProperty(this, "wsEmbedInstance", null);
    _defineProperty(this, "authConnectionConfig", []);
    _defineProperty(this, "wsEmbedInstancePromise", null);
    this.authOptions = params.connectorSettings;
    this.loginSettings = params.loginSettings || {
      authConnection: ""
    };
    this.wsSettings = params.walletServicesSettings || {};
    this.authConnectionConfig = params.authConnectionConfig || [];
  }
  get provider() {
    if (this.status !== CONNECTOR_STATUS.NOT_READY) {
      var _this$wsEmbedInstance;
      if ((_this$wsEmbedInstance = this.wsEmbedInstance) !== null && _this$wsEmbedInstance !== void 0 && _this$wsEmbedInstance.provider) {
        return this.wsEmbedInstance.provider;
      } else if (this.privateKeyProvider) return this.privateKeyProvider;
    }
    return null;
  }
  get wsEmbed() {
    return this.wsEmbedInstance;
  }
  set provider(_3) {
    throw new Error("Not implemented");
  }
  async init(options2) {
    const {
      chains
    } = this.coreOptions;
    const {
      chainId
    } = options2;
    const chainConfig = chains.find((x3) => x3.chainId === chainId);
    super.checkInitializationRequirements({
      chainConfig
    });
    if (!this.coreOptions.clientId) throw WalletInitializationError.invalidParams("clientId is required before auth's initialization");
    if (!this.authOptions) throw WalletInitializationError.invalidParams("authOptions is required before auth's initialization");
    if (this.authConnectionConfig.length === 0) throw WalletInitializationError.invalidParams("authConnectionConfig is required before auth's initialization");
    const isRedirectResult = this.authOptions.uxMode === UX_MODE.REDIRECT;
    this.authOptions = _objectSpread2(_objectSpread2({}, this.authOptions), {}, {
      replaceUrlOnRedirect: isRedirectResult,
      useCoreKitKey: this.coreOptions.useSFAKey
    });
    this.authInstance = new Auth(_objectSpread2(_objectSpread2({}, this.authOptions), {}, {
      clientId: this.coreOptions.clientId,
      network: this.coreOptions.web3AuthNetwork,
      sdkMode: SDK_MODE.IFRAME,
      authConnectionConfig: this.authConnectionConfig.filter((x3) => !x3.isDefault),
      mfaSettings: this.coreOptions.mfaSettings
    }));
    log.debug("initializing auth connector init", this.authOptions);
    const authInstancePromise = this.authInstance.init();
    if (this.coreOptions.privateKeyProvider) {
      this.privateKeyProvider = this.coreOptions.privateKeyProvider;
    } else {
      switch (chainConfig.chainNamespace) {
        case CHAIN_NAMESPACES.EIP155:
        case CHAIN_NAMESPACES.SOLANA: {
          const {
            default: WsEmbed
          } = await import("./lib-5GT2LGIX.js");
          this.wsEmbedInstance = new WsEmbed({
            web3AuthClientId: this.coreOptions.clientId,
            web3AuthNetwork: this.coreOptions.web3AuthNetwork,
            modalZIndex: this.wsSettings.modalZIndex
          });
          const wsSupportedChains = chains.filter((x3) => x3.chainNamespace === CHAIN_NAMESPACES.EIP155 || x3.chainNamespace === CHAIN_NAMESPACES.SOLANA);
          this.wsEmbedInstancePromise = this.wsEmbedInstance.init(_objectSpread2(_objectSpread2({}, this.wsSettings), {}, {
            chains: wsSupportedChains,
            chainId,
            whiteLabel: _objectSpread2(_objectSpread2({}, this.authOptions.whiteLabel), this.wsSettings.whiteLabel)
          })).then(() => {
            this.wsEmbedInstancePromise = null;
            return;
          });
          break;
        }
        case CHAIN_NAMESPACES.XRPL:
          throw WalletLoginError.connectionError("Private key provider is required for XRPL");
        default: {
          const {
            CommonPrivateKeyProvider: CommonPrivateKeyProvider2
          } = await import("./base-provider-JMD2AAST.js");
          this.privateKeyProvider = new CommonPrivateKeyProvider2({
            config: {
              chain: chainConfig,
              chains: this.coreOptions.chains
            }
          });
        }
      }
    }
    log.debug("initializing auth connector");
    await authInstancePromise;
    this.status = CONNECTOR_STATUS.READY;
    this.emit(CONNECTOR_EVENTS.READY, WALLET_CONNECTORS.AUTH);
    try {
      const {
        sessionId
      } = this.authInstance || {};
      if (sessionId && (options2.autoConnect || isRedirectResult)) {
        this.rehydrated = true;
        await this.connect({
          chainId: options2.chainId
        });
      } else if (!sessionId && options2.autoConnect) {
        throw WalletLoginError.connectionError("Failed to rehydrate");
      }
    } catch (error) {
      this.emit(CONNECTOR_EVENTS.REHYDRATION_ERROR, error);
    }
  }
  async connect(params) {
    super.checkConnectionRequirements();
    this.status = CONNECTOR_STATUS.CONNECTING;
    this.emit(CONNECTOR_EVENTS.CONNECTING, _objectSpread2(_objectSpread2({}, params), {}, {
      connector: WALLET_CONNECTORS.AUTH
    }));
    try {
      await this.connectWithProvider(params);
      return this.provider;
    } catch (error) {
      var _message;
      log.error("Failed to connect with auth provider", error);
      this.status = CONNECTOR_STATUS.READY;
      this.emit(CONNECTOR_EVENTS.ERRORED, error);
      if (error !== null && error !== void 0 && (_message = error.message) !== null && _message !== void 0 && _message.includes("user closed popup")) {
        throw WalletLoginError.popupClosed();
      } else if (error instanceof Web3AuthError) {
        throw error;
      }
      throw WalletLoginError.connectionError("Failed to login with auth", error);
    }
  }
  async enableMFA(params = {
    authConnection: ""
  }) {
    if (this.status !== CONNECTOR_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.authInstance) throw WalletInitializationError.notReady("authInstance is not ready");
    try {
      const result = await this.authInstance.enableMFA(params);
      if (result) this.emit(CONNECTOR_EVENTS.MFA_ENABLED, result);
    } catch (error) {
      log.error("Failed to enable MFA with auth provider", error);
      if (error instanceof Web3AuthError) {
        throw error;
      }
      throw WalletLoginError.connectionError("Failed to enable MFA with auth", error);
    }
  }
  async manageMFA(params = {
    authConnection: ""
  }) {
    if (this.status !== CONNECTOR_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.authInstance) throw WalletInitializationError.notReady("authInstance is not ready");
    try {
      await this.authInstance.manageMFA(params);
    } catch (error) {
      log.error("Failed to manage MFA with auth provider", error);
      if (error instanceof Web3AuthError) {
        throw error;
      }
      throw WalletLoginError.connectionError("Failed to manage MFA with auth", error);
    }
  }
  async disconnect(options2 = {
    cleanup: false
  }) {
    if (this.status !== CONNECTOR_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.authInstance) throw WalletInitializationError.notReady("authInstance is not ready");
    this.status = CONNECTOR_STATUS.DISCONNECTING;
    await this.authInstance.logout();
    if (this.wsEmbedInstance) await this.wsEmbedInstance.logout();
    if (options2.cleanup) {
      this.status = CONNECTOR_STATUS.NOT_READY;
      this.authInstance = null;
      if (this.wsEmbedInstance) this.wsEmbedInstance = null;
      if (this.privateKeyProvider) this.privateKeyProvider = null;
    } else {
      this.status = CONNECTOR_STATUS.READY;
    }
    this.rehydrated = false;
    this.emit(CONNECTOR_EVENTS.DISCONNECTED);
  }
  async getIdentityToken() {
    if (this.status !== CONNECTOR_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
    const userInfo = await this.getUserInfo();
    return {
      idToken: userInfo.idToken
    };
  }
  async getUserInfo() {
    if (this.status !== CONNECTOR_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.authInstance) throw WalletInitializationError.notReady("authInstance is not ready");
    const userInfo = this.authInstance.getUserInfo();
    return userInfo;
  }
  // we don't support switching between different namespaces, except for solana and evm
  async switchChain(params, init2 = false) {
    super.checkSwitchChainRequirements(params, init2);
    const {
      chainId: newChainId
    } = params;
    const {
      chainId: currentChainId
    } = this.provider;
    const {
      chainNamespace: currentNamespace
    } = this.getChain(currentChainId);
    const {
      chainNamespace: newNamespace
    } = this.getChain(newChainId);
    if (currentChainId === newChainId) return;
    if (currentNamespace === CHAIN_NAMESPACES.SOLANA || currentNamespace === CHAIN_NAMESPACES.EIP155) {
      var _this$wsEmbedInstance2;
      if (newNamespace !== CHAIN_NAMESPACES.SOLANA && newNamespace !== CHAIN_NAMESPACES.EIP155) throw WalletLoginError.connectionError("Cannot switch to other chain namespace");
      const fullChainId = `${newNamespace}:${Number(params.chainId)}`;
      await ((_this$wsEmbedInstance2 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance2 === void 0 ? void 0 : _this$wsEmbedInstance2.request({
        method: "wallet_switchChain",
        params: {
          chainId: fullChainId
        }
      }));
    } else {
      var _this$privateKeyProvi;
      if (currentNamespace !== newNamespace) throw WalletLoginError.connectionError("Cannot switch to other chain namespace");
      await ((_this$privateKeyProvi = this.privateKeyProvider) === null || _this$privateKeyProvi === void 0 ? void 0 : _this$privateKeyProvi.switchChain(params));
    }
  }
  async cleanup() {
    if (!this.authInstance) throw WalletInitializationError.notReady("authInstance is not ready");
    await this.authInstance.cleanup();
    if (this.wsEmbedInstance) {
      this.wsEmbedInstance.clearInit();
    }
  }
  getOAuthProviderConfig(params) {
    const {
      authConnection,
      authConnectionId,
      groupedAuthConnectionId
    } = params;
    const providerConfig = this.authConnectionConfig.find((x3) => {
      if (groupedAuthConnectionId && authConnectionId) {
        return x3.authConnection === authConnection && x3.groupedAuthConnectionId === groupedAuthConnectionId && x3.authConnectionId === authConnectionId;
      }
      if (authConnectionId) {
        return x3.authConnection === authConnection && x3.authConnectionId === authConnectionId;
      }
      return x3.authConnection === authConnection && x3.isDefault;
    });
    return providerConfig;
  }
  getChain(chainId) {
    return this.coreOptions.chains.find((x3) => x3.chainId === chainId);
  }
  _getFinalPrivKey() {
    if (!this.authInstance) return "";
    let finalPrivKey = this.authInstance.privKey;
    if (this.coreOptions.useSFAKey) {
      if (this.authInstance.privKey && !this.authInstance.coreKitKey) {
        throw WalletLoginError.sfaKeyNotFound();
      }
      finalPrivKey = this.authInstance.coreKitKey;
    }
    return finalPrivKey;
  }
  async connectWithProvider(params) {
    var _this$authInstance, _params$extraLoginOpt;
    if (!this.authInstance) throw WalletInitializationError.notReady("authInstance is not ready");
    const chainConfig = this.coreOptions.chains.find((x3) => x3.chainId === params.chainId);
    if (!chainConfig) throw WalletLoginError.connectionError("Chain config is not available");
    const {
      chainNamespace
    } = chainConfig;
    const keyAvailable = chainNamespace === CHAIN_NAMESPACES.EIP155 || chainNamespace === CHAIN_NAMESPACES.SOLANA ? (_this$authInstance = this.authInstance) === null || _this$authInstance === void 0 ? void 0 : _this$authInstance.sessionId : this._getFinalPrivKey();
    if (params.idToken) params.extraLoginOptions = _objectSpread2(_objectSpread2({}, params.extraLoginOptions), {}, {
      id_token: params.idToken
    });
    if (!keyAvailable || (_params$extraLoginOpt = params.extraLoginOptions) !== null && _params$extraLoginOpt !== void 0 && _params$extraLoginOpt.id_token) {
      var _params$extraLoginOpt2;
      this.loginSettings.curve = SUPPORTED_KEY_CURVES.OTHER;
      const loginParams = (0, import_deepmerge.default)(this.loginSettings, params);
      if ((_params$extraLoginOpt2 = params.extraLoginOptions) !== null && _params$extraLoginOpt2 !== void 0 && _params$extraLoginOpt2.id_token) {
        await this.connectWithJwtLogin(loginParams);
      } else {
        await this.connectWithSocialLogin(loginParams);
      }
    }
    if (chainNamespace === CHAIN_NAMESPACES.EIP155 || chainNamespace === CHAIN_NAMESPACES.SOLANA) {
      if (this.wsEmbedInstancePromise) await this.wsEmbedInstancePromise;
      const {
        sessionId,
        sessionNamespace
      } = this.authInstance || {};
      if (sessionId) {
        const isLoggedIn = await this.wsEmbedInstance.loginWithSessionId({
          sessionId,
          sessionNamespace
        });
        if (isLoggedIn) {
          var _this$wsEmbedInstance3;
          this.status = CONNECTOR_STATUS.CONNECTED;
          this.emit(CONNECTOR_EVENTS.CONNECTED, {
            connector: WALLET_CONNECTORS.AUTH,
            reconnected: this.rehydrated,
            provider: this.provider
          });
          (_this$wsEmbedInstance3 = this.wsEmbedInstance) === null || _this$wsEmbedInstance3 === void 0 || _this$wsEmbedInstance3.provider.on("accountsChanged", (accounts = []) => {
            if (accounts.length === 0 && this.status === CONNECTOR_STATUS.CONNECTED) this.disconnect({
              cleanup: false
            });
          });
        }
      }
    } else {
      const finalPrivKey = this._getFinalPrivKey();
      if (finalPrivKey) {
        await this.privateKeyProvider.setupProvider(finalPrivKey, params.chainId);
        this.status = CONNECTOR_STATUS.CONNECTED;
        this.emit(CONNECTOR_EVENTS.CONNECTED, {
          connector: WALLET_CONNECTORS.AUTH,
          reconnected: this.rehydrated,
          provider: this.provider
        });
      }
    }
  }
  async connectWithSocialLogin(params) {
    var _params$extraLoginOpt3, _params$extraLoginOpt4;
    const providerConfig = this.getOAuthProviderConfig({
      authConnection: params.authConnection,
      authConnectionId: params.authConnectionId,
      groupedAuthConnectionId: params.groupedAuthConnectionId
    });
    if (!(providerConfig !== null && providerConfig !== void 0 && providerConfig.authConnection)) throw WalletLoginError.connectionError("Invalid auth connection.");
    const jwtParams = _objectSpread2(_objectSpread2(_objectSpread2({}, providerConfig.jwtParameters || {}), params.extraLoginOptions || {}), {}, {
      login_hint: params.loginHint || ((_params$extraLoginOpt3 = params.extraLoginOptions) === null || _params$extraLoginOpt3 === void 0 ? void 0 : _params$extraLoginOpt3.login_hint)
    });
    const nonce = randomId();
    const loginParams = cloneDeep2(params);
    loginParams.extraLoginOptions = _objectSpread2(_objectSpread2({}, loginParams.extraLoginOptions || {}), {}, {
      login_hint: params.loginHint || ((_params$extraLoginOpt4 = params.extraLoginOptions) === null || _params$extraLoginOpt4 === void 0 ? void 0 : _params$extraLoginOpt4.login_hint)
    });
    delete loginParams.chainId;
    const popupParams = {
      authConnection: params.authConnection,
      authConnectionId: providerConfig.authConnectionId,
      clientId: providerConfig.clientId || jwtParams.client_id,
      groupedAuthConnectionId: providerConfig.groupedAuthConnectionId,
      redirect_uri: `${this.authInstance.options.sdkUrl}/auth`,
      jwtParams,
      customState: {
        nonce,
        appState: params.appState,
        // use the default settings from the auth instance.
        dapp_redirect_url: this.authInstance.options.redirectUrl,
        uxMode: this.authInstance.options.uxMode,
        whiteLabel: JSON.stringify(this.authInstance.options.whiteLabel),
        loginParams: JSON.stringify(loginParams),
        version: version.split(".")[0],
        web3AuthNetwork: this.coreOptions.web3AuthNetwork,
        web3AuthClientId: this.coreOptions.clientId,
        originData: this.authInstance.options.originData ? JSON.stringify(this.authInstance.options.originData) : void 0
      },
      web3AuthClientId: this.coreOptions.clientId,
      web3AuthNetwork: this.coreOptions.web3AuthNetwork
    };
    const loginHandler = createHandler(popupParams);
    const verifierWindow = new PopupHandler({
      url: loginHandler.finalURL,
      timeout: 0
    });
    if (this.authOptions.uxMode === UX_MODE.REDIRECT) return verifierWindow.redirect(this.authOptions.replaceUrlOnRedirect);
    let isClosedWindow = false;
    return new Promise((resolve, reject) => {
      verifierWindow.open().catch((error) => {
        log.error("Error during login with social", error);
        this.authInstance.postLoginCancelledMessage(nonce);
        reject(error);
      });
      const securePubSub = new SecurePubSub({
        sameIpCheck: true
      });
      securePubSub.subscribe(`web3auth-login-${nonce}`).then((data) => {
        const parsedData = JSON.parse(data || "{}");
        if ((parsedData === null || parsedData === void 0 ? void 0 : parsedData.message) === "login_finished") {
          if (parsedData !== null && parsedData !== void 0 && parsedData.error) {
            this.authInstance.postLoginCancelledMessage(nonce);
            reject(parsedData.error);
          }
          isClosedWindow = true;
          securePubSub.cleanup();
          verifierWindow.close();
        }
        return true;
      }).catch((error) => {
        log.error("Error during login with social", error);
      });
      verifierWindow.once("close", () => {
        if (!isClosedWindow) {
          securePubSub.cleanup();
          this.authInstance.postLoginCancelledMessage(nonce);
          reject(WalletLoginError.popupClosed());
        }
      });
      this.authInstance.postLoginInitiatedMessage(loginParams, nonce).then(resolve).catch((error) => {
        if (error instanceof Web3AuthError) {
          throw error;
        }
        reject(WalletLoginError.connectionError(error instanceof Error ? error.message : error || "Failed to login with social"));
      });
    });
  }
  connectWithJwtLogin(params) {
    var _params$extraLoginOpt5, _params$extraLoginOpt7;
    const loginConfig = this.getOAuthProviderConfig({
      authConnection: params.authConnection,
      authConnectionId: params.authConnectionId,
      groupedAuthConnectionId: params.groupedAuthConnectionId
    });
    if (!(loginConfig !== null && loginConfig !== void 0 && loginConfig.authConnection) && !params.authConnectionId) throw WalletLoginError.connectionError("Invalid auth connection.");
    if (!(loginConfig !== null && loginConfig !== void 0 && loginConfig.authConnection)) {
      this.authInstance.options.authConnectionConfig.push({
        authConnection: params.authConnection,
        authConnectionId: params.authConnectionId,
        groupedAuthConnectionId: params.groupedAuthConnectionId
      });
    }
    const loginParams = cloneDeep2(params);
    const finalExtraLoginOptions = _objectSpread2(_objectSpread2({}, (loginConfig === null || loginConfig === void 0 ? void 0 : loginConfig.jwtParameters) || {}), params.extraLoginOptions || {});
    let finalUserId;
    if (params.loginHint || (_params$extraLoginOpt5 = params.extraLoginOptions) !== null && _params$extraLoginOpt5 !== void 0 && _params$extraLoginOpt5.login_hint) {
      var _params$extraLoginOpt6;
      finalUserId = params.loginHint || ((_params$extraLoginOpt6 = params.extraLoginOptions) === null || _params$extraLoginOpt6 === void 0 ? void 0 : _params$extraLoginOpt6.login_hint);
    } else if ((_params$extraLoginOpt7 = params.extraLoginOptions) !== null && _params$extraLoginOpt7 !== void 0 && _params$extraLoginOpt7.id_token) {
      const {
        payload
      } = parseToken(params.extraLoginOptions.id_token);
      finalUserId = getUserId(payload, loginParams.authConnection, finalExtraLoginOptions.userIdField, finalExtraLoginOptions.isUserIdCaseSensitive);
    } else {
      throw WalletLoginError.connectionError("Invalid login hint or id_token");
    }
    loginParams.extraLoginOptions = _objectSpread2(_objectSpread2({}, finalExtraLoginOptions), {}, {
      login_hint: finalUserId
    });
    delete loginParams.chainId;
    return this.authInstance.postLoginInitiatedMessage(loginParams);
  }
};
var authConnector = (params) => {
  return ({
    projectConfig,
    coreOptions
  }) => {
    var _coreOptions$uiConfig, _coreOptions$walletSe, _coreOptions$walletSe2, _coreOptions$walletSe3;
    const connectorSettings = {};
    const {
      whitelist,
      sessionTime
    } = projectConfig;
    if (whitelist) connectorSettings.originData = whitelist.signed_urls;
    if (coreOptions.sessionTime) {
      connectorSettings.sessionTime = coreOptions.sessionTime;
    } else if (sessionTime) {
      connectorSettings.sessionTime = sessionTime;
    }
    if ((_coreOptions$uiConfig = coreOptions.uiConfig) !== null && _coreOptions$uiConfig !== void 0 && _coreOptions$uiConfig.uxMode) connectorSettings.uxMode = coreOptions.uiConfig.uxMode;
    const uiConfig = coreOptions.uiConfig || {};
    connectorSettings.whiteLabel = uiConfig;
    const finalConnectorSettings = import_deepmerge.default.all([
      {
        uxMode: UX_MODE.POPUP,
        buildEnv: coreOptions.authBuildEnv || BUILD_ENV.PRODUCTION
      },
      // default settings
      connectorSettings,
      (params === null || params === void 0 ? void 0 : params.connectorSettings) || {}
    ]);
    const whiteLabel = import_deepmerge.default.all([uiConfig, ((_coreOptions$walletSe = coreOptions.walletServicesConfig) === null || _coreOptions$walletSe === void 0 ? void 0 : _coreOptions$walletSe.whiteLabel) || {}]);
    const finalWsSettings = _objectSpread2(_objectSpread2({}, coreOptions.walletServicesConfig), {}, {
      whiteLabel,
      accountAbstractionConfig: coreOptions.accountAbstractionConfig,
      enableLogging: coreOptions.enableLogging
    });
    const isKeyExportEnabled = (_coreOptions$walletSe2 = (_coreOptions$walletSe3 = coreOptions.walletServicesConfig) === null || _coreOptions$walletSe3 === void 0 ? void 0 : _coreOptions$walletSe3.enableKeyExport) !== null && _coreOptions$walletSe2 !== void 0 ? _coreOptions$walletSe2 : true;
    if (coreOptions.privateKeyProvider) coreOptions.privateKeyProvider.setKeyExportFlag(isKeyExportEnabled);
    return new AuthConnector({
      connectorSettings: finalConnectorSettings,
      walletServicesSettings: finalWsSettings,
      loginSettings: _objectSpread2(_objectSpread2({}, (params === null || params === void 0 ? void 0 : params.loginSettings) || {}), {}, {
        mfaLevel: coreOptions.mfaLevel
      }),
      coreOptions,
      authConnectionConfig: projectConfig.embeddedWalletAuth
    });
  };
};

// node_modules/@web3auth/no-modal/node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_debug = __toESM(require_browser());
var import_sdk_analytics = __toESM(require_dist());
var import_eventemitter2 = __toESM(require_eventemitter2());
init_esm_browser();

// import("./**/*.entry.js") in node_modules/@web3auth/no-modal/node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
var globImport_entry_js = __glob({});

// node_modules/@web3auth/no-modal/node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
function c(e8, t3, n2, r3) {
  return new (n2 || (n2 = Promise))(function(i2, o) {
    function s(e9) {
      try {
        c2(r3.next(e9));
      } catch (e10) {
        o(e10);
      }
    }
    function a(e9) {
      try {
        c2(r3.throw(e9));
      } catch (e10) {
        o(e10);
      }
    }
    function c2(e9) {
      var t4;
      e9.done ? i2(e9.value) : (t4 = e9.value, t4 instanceof n2 ? t4 : new n2(function(e10) {
        e10(t4);
      })).then(s, a);
    }
    c2((r3 = r3.apply(e8, t3 || [])).next());
  });
}
var l = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
var d = [];
var u = [];
var h = "undefined" != typeof Uint8Array ? Uint8Array : Array;
var f = false;
function p() {
  f = true;
  for (var e8 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t3 = 0; t3 < 64; ++t3) d[t3] = e8[t3], u[e8.charCodeAt(t3)] = t3;
  u["-".charCodeAt(0)] = 62, u["_".charCodeAt(0)] = 63;
}
function g(e8, t3, n2) {
  for (var r3, i2, o = [], s = t3; s < n2; s += 3) r3 = (e8[s] << 16) + (e8[s + 1] << 8) + e8[s + 2], o.push(d[(i2 = r3) >> 18 & 63] + d[i2 >> 12 & 63] + d[i2 >> 6 & 63] + d[63 & i2]);
  return o.join("");
}
function m(e8) {
  var t3;
  f || p();
  for (var n2 = e8.length, r3 = n2 % 3, i2 = "", o = [], s = 16383, a = 0, c2 = n2 - r3; a < c2; a += s) o.push(g(e8, a, a + s > c2 ? c2 : a + s));
  return 1 === r3 ? (t3 = e8[n2 - 1], i2 += d[t3 >> 2], i2 += d[t3 << 4 & 63], i2 += "==") : 2 === r3 && (t3 = (e8[n2 - 2] << 8) + e8[n2 - 1], i2 += d[t3 >> 10], i2 += d[t3 >> 4 & 63], i2 += d[t3 << 2 & 63], i2 += "="), o.push(i2), o.join("");
}
function y(e8, t3, n2, r3, i2) {
  var o, s, a = 8 * i2 - r3 - 1, c2 = (1 << a) - 1, l3 = c2 >> 1, d3 = -7, u2 = n2 ? i2 - 1 : 0, h3 = n2 ? -1 : 1, f2 = e8[t3 + u2];
  for (u2 += h3, o = f2 & (1 << -d3) - 1, f2 >>= -d3, d3 += a; d3 > 0; o = 256 * o + e8[t3 + u2], u2 += h3, d3 -= 8) ;
  for (s = o & (1 << -d3) - 1, o >>= -d3, d3 += r3; d3 > 0; s = 256 * s + e8[t3 + u2], u2 += h3, d3 -= 8) ;
  if (0 === o) o = 1 - l3;
  else {
    if (o === c2) return s ? NaN : 1 / 0 * (f2 ? -1 : 1);
    s += Math.pow(2, r3), o -= l3;
  }
  return (f2 ? -1 : 1) * s * Math.pow(2, o - r3);
}
function v(e8, t3, n2, r3, i2, o) {
  var s, a, c2, l3 = 8 * o - i2 - 1, d3 = (1 << l3) - 1, u2 = d3 >> 1, h3 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = r3 ? 0 : o - 1, p3 = r3 ? 1 : -1, g3 = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
  for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a = isNaN(t3) ? 1 : 0, s = d3) : (s = Math.floor(Math.log(t3) / Math.LN2), t3 * (c2 = Math.pow(2, -s)) < 1 && (s--, c2 *= 2), (t3 += s + u2 >= 1 ? h3 / c2 : h3 * Math.pow(2, 1 - u2)) * c2 >= 2 && (s++, c2 /= 2), s + u2 >= d3 ? (a = 0, s = d3) : s + u2 >= 1 ? (a = (t3 * c2 - 1) * Math.pow(2, i2), s += u2) : (a = t3 * Math.pow(2, u2 - 1) * Math.pow(2, i2), s = 0)); i2 >= 8; e8[n2 + f2] = 255 & a, f2 += p3, a /= 256, i2 -= 8) ;
  for (s = s << i2 | a, l3 += i2; l3 > 0; e8[n2 + f2] = 255 & s, f2 += p3, s /= 256, l3 -= 8) ;
  e8[n2 + f2 - p3] |= 128 * g3;
}
var b = {}.toString;
var w = Array.isArray || function(e8) {
  return "[object Array]" == b.call(e8);
};
C.TYPED_ARRAY_SUPPORT = void 0 === l.TYPED_ARRAY_SUPPORT || l.TYPED_ARRAY_SUPPORT;
var E = S();
function S() {
  return C.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function _(e8, t3) {
  if (S() < t3) throw new RangeError("Invalid typed array length");
  return C.TYPED_ARRAY_SUPPORT ? (e8 = new Uint8Array(t3)).__proto__ = C.prototype : (null === e8 && (e8 = new C(t3)), e8.length = t3), e8;
}
function C(e8, t3, n2) {
  if (!(C.TYPED_ARRAY_SUPPORT || this instanceof C)) return new C(e8, t3, n2);
  if ("number" == typeof e8) {
    if ("string" == typeof t3) throw new Error("If encoding is specified then the first argument must be a string");
    return x(this, e8);
  }
  return k(this, e8, t3, n2);
}
function k(e8, t3, n2, r3) {
  if ("number" == typeof t3) throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && t3 instanceof ArrayBuffer ? function(e9, t4, n3, r4) {
    if (t4.byteLength, n3 < 0 || t4.byteLength < n3) throw new RangeError("'offset' is out of bounds");
    if (t4.byteLength < n3 + (r4 || 0)) throw new RangeError("'length' is out of bounds");
    t4 = void 0 === n3 && void 0 === r4 ? new Uint8Array(t4) : void 0 === r4 ? new Uint8Array(t4, n3) : new Uint8Array(t4, n3, r4);
    C.TYPED_ARRAY_SUPPORT ? (e9 = t4).__proto__ = C.prototype : e9 = M(e9, t4);
    return e9;
  }(e8, t3, n2, r3) : "string" == typeof t3 ? function(e9, t4, n3) {
    "string" == typeof n3 && "" !== n3 || (n3 = "utf8");
    if (!C.isEncoding(n3)) throw new TypeError('"encoding" must be a valid string encoding');
    var r4 = 0 | R(t4, n3);
    e9 = _(e9, r4);
    var i2 = e9.write(t4, n3);
    i2 !== r4 && (e9 = e9.slice(0, i2));
    return e9;
  }(e8, t3, n2) : function(e9, t4) {
    if (T(t4)) {
      var n3 = 0 | I(t4.length);
      return 0 === (e9 = _(e9, n3)).length || t4.copy(e9, 0, 0, n3), e9;
    }
    if (t4) {
      if ("undefined" != typeof ArrayBuffer && t4.buffer instanceof ArrayBuffer || "length" in t4) return "number" != typeof t4.length || (r4 = t4.length) != r4 ? _(e9, 0) : M(e9, t4);
      if ("Buffer" === t4.type && w(t4.data)) return M(e9, t4.data);
    }
    var r4;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }(e8, t3);
}
function A(e8) {
  if ("number" != typeof e8) throw new TypeError('"size" argument must be a number');
  if (e8 < 0) throw new RangeError('"size" argument must not be negative');
}
function x(e8, t3) {
  if (A(t3), e8 = _(e8, t3 < 0 ? 0 : 0 | I(t3)), !C.TYPED_ARRAY_SUPPORT) for (var n2 = 0; n2 < t3; ++n2) e8[n2] = 0;
  return e8;
}
function M(e8, t3) {
  var n2 = t3.length < 0 ? 0 : 0 | I(t3.length);
  e8 = _(e8, n2);
  for (var r3 = 0; r3 < n2; r3 += 1) e8[r3] = 255 & t3[r3];
  return e8;
}
function I(e8) {
  if (e8 >= S()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S().toString(16) + " bytes");
  return 0 | e8;
}
function T(e8) {
  return !(null == e8 || !e8._isBuffer);
}
function R(e8, t3) {
  if (T(e8)) return e8.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e8) || e8 instanceof ArrayBuffer)) return e8.byteLength;
  "string" != typeof e8 && (e8 = "" + e8);
  var n2 = e8.length;
  if (0 === n2) return 0;
  for (var r3 = false; ; ) switch (t3) {
    case "ascii":
    case "latin1":
    case "binary":
      return n2;
    case "utf8":
    case "utf-8":
    case void 0:
      return ie(e8).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * n2;
    case "hex":
      return n2 >>> 1;
    case "base64":
      return oe(e8).length;
    default:
      if (r3) return ie(e8).length;
      t3 = ("" + t3).toLowerCase(), r3 = true;
  }
}
function P(e8, t3, n2) {
  var r3 = false;
  if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
  if ((void 0 === n2 || n2 > this.length) && (n2 = this.length), n2 <= 0) return "";
  if ((n2 >>>= 0) <= (t3 >>>= 0)) return "";
  for (e8 || (e8 = "utf8"); ; ) switch (e8) {
    case "hex":
      return V(this, t3, n2);
    case "utf8":
    case "utf-8":
      return F(this, t3, n2);
    case "ascii":
      return q(this, t3, n2);
    case "latin1":
    case "binary":
      return W(this, t3, n2);
    case "base64":
      return H(this, t3, n2);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return G(this, t3, n2);
    default:
      if (r3) throw new TypeError("Unknown encoding: " + e8);
      e8 = (e8 + "").toLowerCase(), r3 = true;
  }
}
function O(e8, t3, n2) {
  var r3 = e8[t3];
  e8[t3] = e8[n2], e8[n2] = r3;
}
function N(e8, t3, n2, r3, i2) {
  if (0 === e8.length) return -1;
  if ("string" == typeof n2 ? (r3 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = i2 ? 0 : e8.length - 1), n2 < 0 && (n2 = e8.length + n2), n2 >= e8.length) {
    if (i2) return -1;
    n2 = e8.length - 1;
  } else if (n2 < 0) {
    if (!i2) return -1;
    n2 = 0;
  }
  if ("string" == typeof t3 && (t3 = C.from(t3, r3)), T(t3)) return 0 === t3.length ? -1 : L(e8, t3, n2, r3, i2);
  if ("number" == typeof t3) return t3 &= 255, C.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e8, t3, n2) : Uint8Array.prototype.lastIndexOf.call(e8, t3, n2) : L(e8, [t3], n2, r3, i2);
  throw new TypeError("val must be string, number or Buffer");
}
function L(e8, t3, n2, r3, i2) {
  var o, s = 1, a = e8.length, c2 = t3.length;
  if (void 0 !== r3 && ("ucs2" === (r3 = String(r3).toLowerCase()) || "ucs-2" === r3 || "utf16le" === r3 || "utf-16le" === r3)) {
    if (e8.length < 2 || t3.length < 2) return -1;
    s = 2, a /= 2, c2 /= 2, n2 /= 2;
  }
  function l3(e9, t4) {
    return 1 === s ? e9[t4] : e9.readUInt16BE(t4 * s);
  }
  if (i2) {
    var d3 = -1;
    for (o = n2; o < a; o++) if (l3(e8, o) === l3(t3, -1 === d3 ? 0 : o - d3)) {
      if (-1 === d3 && (d3 = o), o - d3 + 1 === c2) return d3 * s;
    } else -1 !== d3 && (o -= o - d3), d3 = -1;
  } else for (n2 + c2 > a && (n2 = a - c2), o = n2; o >= 0; o--) {
    for (var u2 = true, h3 = 0; h3 < c2; h3++) if (l3(e8, o + h3) !== l3(t3, h3)) {
      u2 = false;
      break;
    }
    if (u2) return o;
  }
  return -1;
}
function D(e8, t3, n2, r3) {
  n2 = Number(n2) || 0;
  var i2 = e8.length - n2;
  r3 ? (r3 = Number(r3)) > i2 && (r3 = i2) : r3 = i2;
  var o = t3.length;
  if (o % 2 != 0) throw new TypeError("Invalid hex string");
  r3 > o / 2 && (r3 = o / 2);
  for (var s = 0; s < r3; ++s) {
    var a = parseInt(t3.substr(2 * s, 2), 16);
    if (isNaN(a)) return s;
    e8[n2 + s] = a;
  }
  return s;
}
function $(e8, t3, n2, r3) {
  return se(ie(t3, e8.length - n2), e8, n2, r3);
}
function B(e8, t3, n2, r3) {
  return se(function(e9) {
    for (var t4 = [], n3 = 0; n3 < e9.length; ++n3) t4.push(255 & e9.charCodeAt(n3));
    return t4;
  }(t3), e8, n2, r3);
}
function K(e8, t3, n2, r3) {
  return B(e8, t3, n2, r3);
}
function j(e8, t3, n2, r3) {
  return se(oe(t3), e8, n2, r3);
}
function U(e8, t3, n2, r3) {
  return se(function(e9, t4) {
    for (var n3, r4, i2, o = [], s = 0; s < e9.length && !((t4 -= 2) < 0); ++s) r4 = (n3 = e9.charCodeAt(s)) >> 8, i2 = n3 % 256, o.push(i2), o.push(r4);
    return o;
  }(t3, e8.length - n2), e8, n2, r3);
}
function H(e8, t3, n2) {
  return 0 === t3 && n2 === e8.length ? m(e8) : m(e8.slice(t3, n2));
}
function F(e8, t3, n2) {
  n2 = Math.min(e8.length, n2);
  for (var r3 = [], i2 = t3; i2 < n2; ) {
    var o, s, a, c2, l3 = e8[i2], d3 = null, u2 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
    if (i2 + u2 <= n2) switch (u2) {
      case 1:
        l3 < 128 && (d3 = l3);
        break;
      case 2:
        128 == (192 & (o = e8[i2 + 1])) && (c2 = (31 & l3) << 6 | 63 & o) > 127 && (d3 = c2);
        break;
      case 3:
        o = e8[i2 + 1], s = e8[i2 + 2], 128 == (192 & o) && 128 == (192 & s) && (c2 = (15 & l3) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (c2 < 55296 || c2 > 57343) && (d3 = c2);
        break;
      case 4:
        o = e8[i2 + 1], s = e8[i2 + 2], a = e8[i2 + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (c2 = (15 & l3) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && c2 < 1114112 && (d3 = c2);
    }
    null === d3 ? (d3 = 65533, u2 = 1) : d3 > 65535 && (d3 -= 65536, r3.push(d3 >>> 10 & 1023 | 55296), d3 = 56320 | 1023 & d3), r3.push(d3), i2 += u2;
  }
  return function(e9) {
    var t4 = e9.length;
    if (t4 <= z) return String.fromCharCode.apply(String, e9);
    var n3 = "", r4 = 0;
    for (; r4 < t4; ) n3 += String.fromCharCode.apply(String, e9.slice(r4, r4 += z));
    return n3;
  }(r3);
}
C.poolSize = 8192, C._augment = function(e8) {
  return e8.__proto__ = C.prototype, e8;
}, C.from = function(e8, t3, n2) {
  return k(null, e8, t3, n2);
}, C.TYPED_ARRAY_SUPPORT && (C.prototype.__proto__ = Uint8Array.prototype, C.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && C[Symbol.species]), C.alloc = function(e8, t3, n2) {
  return function(e9, t4, n3, r3) {
    return A(t4), t4 <= 0 ? _(e9, t4) : void 0 !== n3 ? "string" == typeof r3 ? _(e9, t4).fill(n3, r3) : _(e9, t4).fill(n3) : _(e9, t4);
  }(null, e8, t3, n2);
}, C.allocUnsafe = function(e8) {
  return x(null, e8);
}, C.allocUnsafeSlow = function(e8) {
  return x(null, e8);
}, C.isBuffer = ae, C.compare = function(e8, t3) {
  if (!T(e8) || !T(t3)) throw new TypeError("Arguments must be Buffers");
  if (e8 === t3) return 0;
  for (var n2 = e8.length, r3 = t3.length, i2 = 0, o = Math.min(n2, r3); i2 < o; ++i2) if (e8[i2] !== t3[i2]) {
    n2 = e8[i2], r3 = t3[i2];
    break;
  }
  return n2 < r3 ? -1 : r3 < n2 ? 1 : 0;
}, C.isEncoding = function(e8) {
  switch (String(e8).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, C.concat = function(e8, t3) {
  if (!w(e8)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === e8.length) return C.alloc(0);
  var n2;
  if (void 0 === t3) for (t3 = 0, n2 = 0; n2 < e8.length; ++n2) t3 += e8[n2].length;
  var r3 = C.allocUnsafe(t3), i2 = 0;
  for (n2 = 0; n2 < e8.length; ++n2) {
    var o = e8[n2];
    if (!T(o)) throw new TypeError('"list" argument must be an Array of Buffers');
    o.copy(r3, i2), i2 += o.length;
  }
  return r3;
}, C.byteLength = R, C.prototype._isBuffer = true, C.prototype.swap16 = function() {
  var e8 = this.length;
  if (e8 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t3 = 0; t3 < e8; t3 += 2) O(this, t3, t3 + 1);
  return this;
}, C.prototype.swap32 = function() {
  var e8 = this.length;
  if (e8 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t3 = 0; t3 < e8; t3 += 4) O(this, t3, t3 + 3), O(this, t3 + 1, t3 + 2);
  return this;
}, C.prototype.swap64 = function() {
  var e8 = this.length;
  if (e8 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t3 = 0; t3 < e8; t3 += 8) O(this, t3, t3 + 7), O(this, t3 + 1, t3 + 6), O(this, t3 + 2, t3 + 5), O(this, t3 + 3, t3 + 4);
  return this;
}, C.prototype.toString = function() {
  var e8 = 0 | this.length;
  return 0 === e8 ? "" : 0 === arguments.length ? F(this, 0, e8) : P.apply(this, arguments);
}, C.prototype.equals = function(e8) {
  if (!T(e8)) throw new TypeError("Argument must be a Buffer");
  return this === e8 || 0 === C.compare(this, e8);
}, C.prototype.inspect = function() {
  var e8 = "";
  return this.length > 0 && (e8 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e8 += " ... ")), "<Buffer " + e8 + ">";
}, C.prototype.compare = function(e8, t3, n2, r3, i2) {
  if (!T(e8)) throw new TypeError("Argument must be a Buffer");
  if (void 0 === t3 && (t3 = 0), void 0 === n2 && (n2 = e8 ? e8.length : 0), void 0 === r3 && (r3 = 0), void 0 === i2 && (i2 = this.length), t3 < 0 || n2 > e8.length || r3 < 0 || i2 > this.length) throw new RangeError("out of range index");
  if (r3 >= i2 && t3 >= n2) return 0;
  if (r3 >= i2) return -1;
  if (t3 >= n2) return 1;
  if (this === e8) return 0;
  for (var o = (i2 >>>= 0) - (r3 >>>= 0), s = (n2 >>>= 0) - (t3 >>>= 0), a = Math.min(o, s), c2 = this.slice(r3, i2), l3 = e8.slice(t3, n2), d3 = 0; d3 < a; ++d3) if (c2[d3] !== l3[d3]) {
    o = c2[d3], s = l3[d3];
    break;
  }
  return o < s ? -1 : s < o ? 1 : 0;
}, C.prototype.includes = function(e8, t3, n2) {
  return -1 !== this.indexOf(e8, t3, n2);
}, C.prototype.indexOf = function(e8, t3, n2) {
  return N(this, e8, t3, n2, true);
}, C.prototype.lastIndexOf = function(e8, t3, n2) {
  return N(this, e8, t3, n2, false);
}, C.prototype.write = function(e8, t3, n2, r3) {
  if (void 0 === t3) r3 = "utf8", n2 = this.length, t3 = 0;
  else if (void 0 === n2 && "string" == typeof t3) r3 = t3, n2 = this.length, t3 = 0;
  else {
    if (!isFinite(t3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t3 |= 0, isFinite(n2) ? (n2 |= 0, void 0 === r3 && (r3 = "utf8")) : (r3 = n2, n2 = void 0);
  }
  var i2 = this.length - t3;
  if ((void 0 === n2 || n2 > i2) && (n2 = i2), e8.length > 0 && (n2 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  r3 || (r3 = "utf8");
  for (var o = false; ; ) switch (r3) {
    case "hex":
      return D(this, e8, t3, n2);
    case "utf8":
    case "utf-8":
      return $(this, e8, t3, n2);
    case "ascii":
      return B(this, e8, t3, n2);
    case "latin1":
    case "binary":
      return K(this, e8, t3, n2);
    case "base64":
      return j(this, e8, t3, n2);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return U(this, e8, t3, n2);
    default:
      if (o) throw new TypeError("Unknown encoding: " + r3);
      r3 = ("" + r3).toLowerCase(), o = true;
  }
}, C.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var z = 4096;
function q(e8, t3, n2) {
  var r3 = "";
  n2 = Math.min(e8.length, n2);
  for (var i2 = t3; i2 < n2; ++i2) r3 += String.fromCharCode(127 & e8[i2]);
  return r3;
}
function W(e8, t3, n2) {
  var r3 = "";
  n2 = Math.min(e8.length, n2);
  for (var i2 = t3; i2 < n2; ++i2) r3 += String.fromCharCode(e8[i2]);
  return r3;
}
function V(e8, t3, n2) {
  var r3 = e8.length;
  (!t3 || t3 < 0) && (t3 = 0), (!n2 || n2 < 0 || n2 > r3) && (n2 = r3);
  for (var i2 = "", o = t3; o < n2; ++o) i2 += re(e8[o]);
  return i2;
}
function G(e8, t3, n2) {
  for (var r3 = e8.slice(t3, n2), i2 = "", o = 0; o < r3.length; o += 2) i2 += String.fromCharCode(r3[o] + 256 * r3[o + 1]);
  return i2;
}
function Y(e8, t3, n2) {
  if (e8 % 1 != 0 || e8 < 0) throw new RangeError("offset is not uint");
  if (e8 + t3 > n2) throw new RangeError("Trying to access beyond buffer length");
}
function Z(e8, t3, n2, r3, i2, o) {
  if (!T(e8)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t3 > i2 || t3 < o) throw new RangeError('"value" argument is out of bounds');
  if (n2 + r3 > e8.length) throw new RangeError("Index out of range");
}
function J(e8, t3, n2, r3) {
  t3 < 0 && (t3 = 65535 + t3 + 1);
  for (var i2 = 0, o = Math.min(e8.length - n2, 2); i2 < o; ++i2) e8[n2 + i2] = (t3 & 255 << 8 * (r3 ? i2 : 1 - i2)) >>> 8 * (r3 ? i2 : 1 - i2);
}
function Q(e8, t3, n2, r3) {
  t3 < 0 && (t3 = 4294967295 + t3 + 1);
  for (var i2 = 0, o = Math.min(e8.length - n2, 4); i2 < o; ++i2) e8[n2 + i2] = t3 >>> 8 * (r3 ? i2 : 3 - i2) & 255;
}
function X(e8, t3, n2, r3, i2, o) {
  if (n2 + r3 > e8.length) throw new RangeError("Index out of range");
  if (n2 < 0) throw new RangeError("Index out of range");
}
function ee(e8, t3, n2, r3, i2) {
  return i2 || X(e8, 0, n2, 4), v(e8, t3, n2, r3, 23, 4), n2 + 4;
}
function te(e8, t3, n2, r3, i2) {
  return i2 || X(e8, 0, n2, 8), v(e8, t3, n2, r3, 52, 8), n2 + 8;
}
C.prototype.slice = function(e8, t3) {
  var n2, r3 = this.length;
  if ((e8 = ~~e8) < 0 ? (e8 += r3) < 0 && (e8 = 0) : e8 > r3 && (e8 = r3), (t3 = void 0 === t3 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e8 && (t3 = e8), C.TYPED_ARRAY_SUPPORT) (n2 = this.subarray(e8, t3)).__proto__ = C.prototype;
  else {
    var i2 = t3 - e8;
    n2 = new C(i2, void 0);
    for (var o = 0; o < i2; ++o) n2[o] = this[o + e8];
  }
  return n2;
}, C.prototype.readUIntLE = function(e8, t3, n2) {
  e8 |= 0, t3 |= 0, n2 || Y(e8, t3, this.length);
  for (var r3 = this[e8], i2 = 1, o = 0; ++o < t3 && (i2 *= 256); ) r3 += this[e8 + o] * i2;
  return r3;
}, C.prototype.readUIntBE = function(e8, t3, n2) {
  e8 |= 0, t3 |= 0, n2 || Y(e8, t3, this.length);
  for (var r3 = this[e8 + --t3], i2 = 1; t3 > 0 && (i2 *= 256); ) r3 += this[e8 + --t3] * i2;
  return r3;
}, C.prototype.readUInt8 = function(e8, t3) {
  return t3 || Y(e8, 1, this.length), this[e8];
}, C.prototype.readUInt16LE = function(e8, t3) {
  return t3 || Y(e8, 2, this.length), this[e8] | this[e8 + 1] << 8;
}, C.prototype.readUInt16BE = function(e8, t3) {
  return t3 || Y(e8, 2, this.length), this[e8] << 8 | this[e8 + 1];
}, C.prototype.readUInt32LE = function(e8, t3) {
  return t3 || Y(e8, 4, this.length), (this[e8] | this[e8 + 1] << 8 | this[e8 + 2] << 16) + 16777216 * this[e8 + 3];
}, C.prototype.readUInt32BE = function(e8, t3) {
  return t3 || Y(e8, 4, this.length), 16777216 * this[e8] + (this[e8 + 1] << 16 | this[e8 + 2] << 8 | this[e8 + 3]);
}, C.prototype.readIntLE = function(e8, t3, n2) {
  e8 |= 0, t3 |= 0, n2 || Y(e8, t3, this.length);
  for (var r3 = this[e8], i2 = 1, o = 0; ++o < t3 && (i2 *= 256); ) r3 += this[e8 + o] * i2;
  return r3 >= (i2 *= 128) && (r3 -= Math.pow(2, 8 * t3)), r3;
}, C.prototype.readIntBE = function(e8, t3, n2) {
  e8 |= 0, t3 |= 0, n2 || Y(e8, t3, this.length);
  for (var r3 = t3, i2 = 1, o = this[e8 + --r3]; r3 > 0 && (i2 *= 256); ) o += this[e8 + --r3] * i2;
  return o >= (i2 *= 128) && (o -= Math.pow(2, 8 * t3)), o;
}, C.prototype.readInt8 = function(e8, t3) {
  return t3 || Y(e8, 1, this.length), 128 & this[e8] ? -1 * (255 - this[e8] + 1) : this[e8];
}, C.prototype.readInt16LE = function(e8, t3) {
  t3 || Y(e8, 2, this.length);
  var n2 = this[e8] | this[e8 + 1] << 8;
  return 32768 & n2 ? 4294901760 | n2 : n2;
}, C.prototype.readInt16BE = function(e8, t3) {
  t3 || Y(e8, 2, this.length);
  var n2 = this[e8 + 1] | this[e8] << 8;
  return 32768 & n2 ? 4294901760 | n2 : n2;
}, C.prototype.readInt32LE = function(e8, t3) {
  return t3 || Y(e8, 4, this.length), this[e8] | this[e8 + 1] << 8 | this[e8 + 2] << 16 | this[e8 + 3] << 24;
}, C.prototype.readInt32BE = function(e8, t3) {
  return t3 || Y(e8, 4, this.length), this[e8] << 24 | this[e8 + 1] << 16 | this[e8 + 2] << 8 | this[e8 + 3];
}, C.prototype.readFloatLE = function(e8, t3) {
  return t3 || Y(e8, 4, this.length), y(this, e8, true, 23, 4);
}, C.prototype.readFloatBE = function(e8, t3) {
  return t3 || Y(e8, 4, this.length), y(this, e8, false, 23, 4);
}, C.prototype.readDoubleLE = function(e8, t3) {
  return t3 || Y(e8, 8, this.length), y(this, e8, true, 52, 8);
}, C.prototype.readDoubleBE = function(e8, t3) {
  return t3 || Y(e8, 8, this.length), y(this, e8, false, 52, 8);
}, C.prototype.writeUIntLE = function(e8, t3, n2, r3) {
  (e8 = +e8, t3 |= 0, n2 |= 0, r3) || Z(this, e8, t3, n2, Math.pow(2, 8 * n2) - 1, 0);
  var i2 = 1, o = 0;
  for (this[t3] = 255 & e8; ++o < n2 && (i2 *= 256); ) this[t3 + o] = e8 / i2 & 255;
  return t3 + n2;
}, C.prototype.writeUIntBE = function(e8, t3, n2, r3) {
  (e8 = +e8, t3 |= 0, n2 |= 0, r3) || Z(this, e8, t3, n2, Math.pow(2, 8 * n2) - 1, 0);
  var i2 = n2 - 1, o = 1;
  for (this[t3 + i2] = 255 & e8; --i2 >= 0 && (o *= 256); ) this[t3 + i2] = e8 / o & 255;
  return t3 + n2;
}, C.prototype.writeUInt8 = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 1, 255, 0), C.TYPED_ARRAY_SUPPORT || (e8 = Math.floor(e8)), this[t3] = 255 & e8, t3 + 1;
}, C.prototype.writeUInt16LE = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 2, 65535, 0), C.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e8, this[t3 + 1] = e8 >>> 8) : J(this, e8, t3, true), t3 + 2;
}, C.prototype.writeUInt16BE = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 2, 65535, 0), C.TYPED_ARRAY_SUPPORT ? (this[t3] = e8 >>> 8, this[t3 + 1] = 255 & e8) : J(this, e8, t3, false), t3 + 2;
}, C.prototype.writeUInt32LE = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 4, 4294967295, 0), C.TYPED_ARRAY_SUPPORT ? (this[t3 + 3] = e8 >>> 24, this[t3 + 2] = e8 >>> 16, this[t3 + 1] = e8 >>> 8, this[t3] = 255 & e8) : Q(this, e8, t3, true), t3 + 4;
}, C.prototype.writeUInt32BE = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 4, 4294967295, 0), C.TYPED_ARRAY_SUPPORT ? (this[t3] = e8 >>> 24, this[t3 + 1] = e8 >>> 16, this[t3 + 2] = e8 >>> 8, this[t3 + 3] = 255 & e8) : Q(this, e8, t3, false), t3 + 4;
}, C.prototype.writeIntLE = function(e8, t3, n2, r3) {
  if (e8 = +e8, t3 |= 0, !r3) {
    var i2 = Math.pow(2, 8 * n2 - 1);
    Z(this, e8, t3, n2, i2 - 1, -i2);
  }
  var o = 0, s = 1, a = 0;
  for (this[t3] = 255 & e8; ++o < n2 && (s *= 256); ) e8 < 0 && 0 === a && 0 !== this[t3 + o - 1] && (a = 1), this[t3 + o] = (e8 / s >> 0) - a & 255;
  return t3 + n2;
}, C.prototype.writeIntBE = function(e8, t3, n2, r3) {
  if (e8 = +e8, t3 |= 0, !r3) {
    var i2 = Math.pow(2, 8 * n2 - 1);
    Z(this, e8, t3, n2, i2 - 1, -i2);
  }
  var o = n2 - 1, s = 1, a = 0;
  for (this[t3 + o] = 255 & e8; --o >= 0 && (s *= 256); ) e8 < 0 && 0 === a && 0 !== this[t3 + o + 1] && (a = 1), this[t3 + o] = (e8 / s >> 0) - a & 255;
  return t3 + n2;
}, C.prototype.writeInt8 = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 1, 127, -128), C.TYPED_ARRAY_SUPPORT || (e8 = Math.floor(e8)), e8 < 0 && (e8 = 255 + e8 + 1), this[t3] = 255 & e8, t3 + 1;
}, C.prototype.writeInt16LE = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 2, 32767, -32768), C.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e8, this[t3 + 1] = e8 >>> 8) : J(this, e8, t3, true), t3 + 2;
}, C.prototype.writeInt16BE = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 2, 32767, -32768), C.TYPED_ARRAY_SUPPORT ? (this[t3] = e8 >>> 8, this[t3 + 1] = 255 & e8) : J(this, e8, t3, false), t3 + 2;
}, C.prototype.writeInt32LE = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 4, 2147483647, -2147483648), C.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e8, this[t3 + 1] = e8 >>> 8, this[t3 + 2] = e8 >>> 16, this[t3 + 3] = e8 >>> 24) : Q(this, e8, t3, true), t3 + 4;
}, C.prototype.writeInt32BE = function(e8, t3, n2) {
  return e8 = +e8, t3 |= 0, n2 || Z(this, e8, t3, 4, 2147483647, -2147483648), e8 < 0 && (e8 = 4294967295 + e8 + 1), C.TYPED_ARRAY_SUPPORT ? (this[t3] = e8 >>> 24, this[t3 + 1] = e8 >>> 16, this[t3 + 2] = e8 >>> 8, this[t3 + 3] = 255 & e8) : Q(this, e8, t3, false), t3 + 4;
}, C.prototype.writeFloatLE = function(e8, t3, n2) {
  return ee(this, e8, t3, true, n2);
}, C.prototype.writeFloatBE = function(e8, t3, n2) {
  return ee(this, e8, t3, false, n2);
}, C.prototype.writeDoubleLE = function(e8, t3, n2) {
  return te(this, e8, t3, true, n2);
}, C.prototype.writeDoubleBE = function(e8, t3, n2) {
  return te(this, e8, t3, false, n2);
}, C.prototype.copy = function(e8, t3, n2, r3) {
  if (n2 || (n2 = 0), r3 || 0 === r3 || (r3 = this.length), t3 >= e8.length && (t3 = e8.length), t3 || (t3 = 0), r3 > 0 && r3 < n2 && (r3 = n2), r3 === n2) return 0;
  if (0 === e8.length || 0 === this.length) return 0;
  if (t3 < 0) throw new RangeError("targetStart out of bounds");
  if (n2 < 0 || n2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (r3 < 0) throw new RangeError("sourceEnd out of bounds");
  r3 > this.length && (r3 = this.length), e8.length - t3 < r3 - n2 && (r3 = e8.length - t3 + n2);
  var i2, o = r3 - n2;
  if (this === e8 && n2 < t3 && t3 < r3) for (i2 = o - 1; i2 >= 0; --i2) e8[i2 + t3] = this[i2 + n2];
  else if (o < 1e3 || !C.TYPED_ARRAY_SUPPORT) for (i2 = 0; i2 < o; ++i2) e8[i2 + t3] = this[i2 + n2];
  else Uint8Array.prototype.set.call(e8, this.subarray(n2, n2 + o), t3);
  return o;
}, C.prototype.fill = function(e8, t3, n2, r3) {
  if ("string" == typeof e8) {
    if ("string" == typeof t3 ? (r3 = t3, t3 = 0, n2 = this.length) : "string" == typeof n2 && (r3 = n2, n2 = this.length), 1 === e8.length) {
      var i2 = e8.charCodeAt(0);
      i2 < 256 && (e8 = i2);
    }
    if (void 0 !== r3 && "string" != typeof r3) throw new TypeError("encoding must be a string");
    if ("string" == typeof r3 && !C.isEncoding(r3)) throw new TypeError("Unknown encoding: " + r3);
  } else "number" == typeof e8 && (e8 &= 255);
  if (t3 < 0 || this.length < t3 || this.length < n2) throw new RangeError("Out of range index");
  if (n2 <= t3) return this;
  var o;
  if (t3 >>>= 0, n2 = void 0 === n2 ? this.length : n2 >>> 0, e8 || (e8 = 0), "number" == typeof e8) for (o = t3; o < n2; ++o) this[o] = e8;
  else {
    var s = T(e8) ? e8 : ie(new C(e8, r3).toString()), a = s.length;
    for (o = 0; o < n2 - t3; ++o) this[o + t3] = s[o % a];
  }
  return this;
};
var ne = /[^+\/0-9A-Za-z-_]/g;
function re(e8) {
  return e8 < 16 ? "0" + e8.toString(16) : e8.toString(16);
}
function ie(e8, t3) {
  var n2;
  t3 = t3 || 1 / 0;
  for (var r3 = e8.length, i2 = null, o = [], s = 0; s < r3; ++s) {
    if ((n2 = e8.charCodeAt(s)) > 55295 && n2 < 57344) {
      if (!i2) {
        if (n2 > 56319) {
          (t3 -= 3) > -1 && o.push(239, 191, 189);
          continue;
        }
        if (s + 1 === r3) {
          (t3 -= 3) > -1 && o.push(239, 191, 189);
          continue;
        }
        i2 = n2;
        continue;
      }
      if (n2 < 56320) {
        (t3 -= 3) > -1 && o.push(239, 191, 189), i2 = n2;
        continue;
      }
      n2 = 65536 + (i2 - 55296 << 10 | n2 - 56320);
    } else i2 && (t3 -= 3) > -1 && o.push(239, 191, 189);
    if (i2 = null, n2 < 128) {
      if ((t3 -= 1) < 0) break;
      o.push(n2);
    } else if (n2 < 2048) {
      if ((t3 -= 2) < 0) break;
      o.push(n2 >> 6 | 192, 63 & n2 | 128);
    } else if (n2 < 65536) {
      if ((t3 -= 3) < 0) break;
      o.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
    } else {
      if (!(n2 < 1114112)) throw new Error("Invalid code point");
      if ((t3 -= 4) < 0) break;
      o.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
    }
  }
  return o;
}
function oe(e8) {
  return function(e9) {
    var t3, n2, r3, i2, o, s;
    f || p();
    var a = e9.length;
    if (a % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    o = "=" === e9[a - 2] ? 2 : "=" === e9[a - 1] ? 1 : 0, s = new h(3 * a / 4 - o), r3 = o > 0 ? a - 4 : a;
    var c2 = 0;
    for (t3 = 0, n2 = 0; t3 < r3; t3 += 4, n2 += 3) i2 = u[e9.charCodeAt(t3)] << 18 | u[e9.charCodeAt(t3 + 1)] << 12 | u[e9.charCodeAt(t3 + 2)] << 6 | u[e9.charCodeAt(t3 + 3)], s[c2++] = i2 >> 16 & 255, s[c2++] = i2 >> 8 & 255, s[c2++] = 255 & i2;
    return 2 === o ? (i2 = u[e9.charCodeAt(t3)] << 2 | u[e9.charCodeAt(t3 + 1)] >> 4, s[c2++] = 255 & i2) : 1 === o && (i2 = u[e9.charCodeAt(t3)] << 10 | u[e9.charCodeAt(t3 + 1)] << 4 | u[e9.charCodeAt(t3 + 2)] >> 2, s[c2++] = i2 >> 8 & 255, s[c2++] = 255 & i2), s;
  }(function(e9) {
    if ((e9 = function(e10) {
      return e10.trim ? e10.trim() : e10.replace(/^\s+|\s+$/g, "");
    }(e9).replace(ne, "")).length < 2) return "";
    for (; e9.length % 4 != 0; ) e9 += "=";
    return e9;
  }(e8));
}
function se(e8, t3, n2, r3) {
  for (var i2 = 0; i2 < r3 && !(i2 + n2 >= t3.length || i2 >= e8.length); ++i2) t3[i2 + n2] = e8[i2];
  return i2;
}
function ae(e8) {
  return null != e8 && (!!e8._isBuffer || ce(e8) || function(e9) {
    return "function" == typeof e9.readFloatLE && "function" == typeof e9.slice && ce(e9.slice(0, 0));
  }(e8));
}
function ce(e8) {
  return !!e8.constructor && "function" == typeof e8.constructor.isBuffer && e8.constructor.isBuffer(e8);
}
var le = Object.freeze({ __proto__: null, Buffer: C, INSPECT_MAX_BYTES: 50, SlowBuffer: function(e8) {
  return +e8 != e8 && (e8 = 0), C.alloc(+e8);
}, isBuffer: ae, kMaxLength: E });
var de = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function ue(e8) {
  return e8 && e8.__esModule && Object.prototype.hasOwnProperty.call(e8, "default") ? e8.default : e8;
}
function he(e8) {
  if (e8.__esModule) return e8;
  var t3 = e8.default;
  if ("function" == typeof t3) {
    var n2 = function e9() {
      return this instanceof e9 ? Reflect.construct(t3, arguments, this.constructor) : t3.apply(this, arguments);
    };
    n2.prototype = t3.prototype;
  } else n2 = {};
  return Object.defineProperty(n2, "__esModule", { value: true }), Object.keys(e8).forEach(function(t4) {
    var r3 = Object.getOwnPropertyDescriptor(e8, t4);
    Object.defineProperty(n2, t4, r3.get ? r3 : { enumerable: true, get: function() {
      return e8[t4];
    } });
  }), n2;
}
var fe = {};
var pe = {};
var ge = {};
function me(e8) {
  if (!Number.isSafeInteger(e8) || e8 < 0) throw new Error(`positive integer expected, not ${e8}`);
}
function ye(e8) {
  if ("boolean" != typeof e8) throw new Error(`boolean expected, not ${e8}`);
}
function ve(e8) {
  return e8 instanceof Uint8Array || null != e8 && "object" == typeof e8 && "Uint8Array" === e8.constructor.name;
}
function be(e8, ...t3) {
  if (!ve(e8)) throw new Error("Uint8Array expected");
  if (t3.length > 0 && !t3.includes(e8.length)) throw new Error(`Uint8Array expected of length ${t3}, not of length=${e8.length}`);
}
function we(e8) {
  if ("function" != typeof e8 || "function" != typeof e8.create) throw new Error("hash must be wrapped by utils.wrapConstructor");
  me(e8.outputLen), me(e8.blockLen);
}
function Ee(e8, t3 = true) {
  if (e8.destroyed) throw new Error("Hash instance has been destroyed");
  if (t3 && e8.finished) throw new Error("Hash#digest() has already been called");
}
function Se(e8, t3) {
  be(e8);
  const n2 = t3.outputLen;
  if (e8.length < n2) throw new Error(`digestInto() expects output buffer of length at least ${n2}`);
}
Object.defineProperty(ge, "__esModule", { value: true }), ge.isBytes = ve, ge.number = me, ge.bool = ye, ge.bytes = be, ge.hash = we, ge.exists = Ee, ge.output = Se;
var _e = { number: me, bool: ye, bytes: be, hash: we, exists: Ee, output: Se };
ge.default = _e, function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.wrapCipher = e8.Hash = e8.nextTick = e8.isLE = e8.createView = e8.u32 = e8.u16 = e8.u8 = void 0, e8.bytesToHex = r3, e8.hexToBytes = s, e8.hexToNumber = a, e8.bytesToNumberBE = function(e9) {
    return a(r3(e9));
  }, e8.numberToBytesBE = function(e9, t4) {
    return s(e9.toString(16).padStart(2 * t4, "0"));
  }, e8.asyncLoop = async function(t4, n3, r4) {
    let i3 = Date.now();
    for (let o2 = 0; o2 < t4; o2++) {
      r4(o2);
      const t5 = Date.now() - i3;
      t5 >= 0 && t5 < n3 || (await (0, e8.nextTick)(), i3 += t5);
    }
  }, e8.utf8ToBytes = c2, e8.bytesToUtf8 = function(e9) {
    return new TextDecoder().decode(e9);
  }, e8.toBytes = function(e9) {
    if ("string" == typeof e9) e9 = c2(e9);
    else {
      if (!(0, t3.isBytes)(e9)) throw new Error("Uint8Array expected, got " + typeof e9);
      e9 = d3(e9);
    }
    return e9;
  }, e8.concatBytes = function(...e9) {
    let n3 = 0;
    for (let r5 = 0; r5 < e9.length; r5++) {
      const i3 = e9[r5];
      (0, t3.bytes)(i3), n3 += i3.length;
    }
    const r4 = new Uint8Array(n3);
    for (let t4 = 0, n4 = 0; t4 < e9.length; t4++) {
      const i3 = e9[t4];
      r4.set(i3, n4), n4 += i3.length;
    }
    return r4;
  }, e8.checkOpts = function(e9, t4) {
    if (null == t4 || "object" != typeof t4) throw new Error("options must be defined");
    return Object.assign(e9, t4);
  }, e8.equalBytes = function(e9, t4) {
    if (e9.length !== t4.length) return false;
    let n3 = 0;
    for (let r4 = 0; r4 < e9.length; r4++) n3 |= e9[r4] ^ t4[r4];
    return 0 === n3;
  }, e8.setBigUint64 = l3, e8.u64Lengths = function(t4, n3) {
    const r4 = new Uint8Array(16), i3 = (0, e8.createView)(r4);
    return l3(i3, 0, BigInt(n3 ? n3.length : 0), true), l3(i3, 8, BigInt(t4.length), true), r4;
  }, e8.isAligned32 = function(e9) {
    return e9.byteOffset % 4 == 0;
  }, e8.copyBytes = d3, e8.clean = function(...e9) {
    for (let t4 = 0; t4 < e9.length; t4++) e9[t4].fill(0);
  };
  const t3 = ge;
  e8.u8 = (e9) => new Uint8Array(e9.buffer, e9.byteOffset, e9.byteLength);
  e8.u16 = (e9) => new Uint16Array(e9.buffer, e9.byteOffset, Math.floor(e9.byteLength / 2));
  e8.u32 = (e9) => new Uint32Array(e9.buffer, e9.byteOffset, Math.floor(e9.byteLength / 4));
  if (e8.createView = (e9) => new DataView(e9.buffer, e9.byteOffset, e9.byteLength), e8.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !e8.isLE) throw new Error("Non little-endian hardware is not supported");
  const n2 = Array.from({ length: 256 }, (e9, t4) => t4.toString(16).padStart(2, "0"));
  function r3(e9) {
    (0, t3.bytes)(e9);
    let r4 = "";
    for (let t4 = 0; t4 < e9.length; t4++) r4 += n2[e9[t4]];
    return r4;
  }
  const i2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o(e9) {
    return e9 >= i2._0 && e9 <= i2._9 ? e9 - i2._0 : e9 >= i2._A && e9 <= i2._F ? e9 - (i2._A - 10) : e9 >= i2._a && e9 <= i2._f ? e9 - (i2._a - 10) : void 0;
  }
  function s(e9) {
    if ("string" != typeof e9) throw new Error("hex string expected, got " + typeof e9);
    const t4 = e9.length, n3 = t4 / 2;
    if (t4 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t4);
    const r4 = new Uint8Array(n3);
    for (let t5 = 0, i3 = 0; t5 < n3; t5++, i3 += 2) {
      const n4 = o(e9.charCodeAt(i3)), s2 = o(e9.charCodeAt(i3 + 1));
      if (void 0 === n4 || void 0 === s2) {
        const t6 = e9[i3] + e9[i3 + 1];
        throw new Error('hex string expected, got non-hex character "' + t6 + '" at index ' + i3);
      }
      r4[t5] = 16 * n4 + s2;
    }
    return r4;
  }
  function a(e9) {
    if ("string" != typeof e9) throw new Error("hex string expected, got " + typeof e9);
    return BigInt("" === e9 ? "0" : `0x${e9}`);
  }
  function c2(e9) {
    if ("string" != typeof e9) throw new Error("string expected, got " + typeof e9);
    return new Uint8Array(new TextEncoder().encode(e9));
  }
  e8.nextTick = async () => {
  };
  e8.Hash = class {
  };
  function l3(e9, t4, n3, r4) {
    if ("function" == typeof e9.setBigUint64) return e9.setBigUint64(t4, n3, r4);
    const i3 = BigInt(32), o2 = BigInt(4294967295), s2 = Number(n3 >> i3 & o2), a2 = Number(n3 & o2), c3 = r4 ? 4 : 0, l4 = r4 ? 0 : 4;
    e9.setUint32(t4 + c3, s2, r4), e9.setUint32(t4 + l4, a2, r4);
  }
  function d3(e9) {
    return Uint8Array.from(e9);
  }
  e8.wrapCipher = (e9, t4) => (Object.assign(t4, e9), t4);
}(pe);
var Ce = {};
var ke = {};
Object.defineProperty(ke, "__esModule", { value: true }), ke.AEAD_TAG_LENGTH = ke.XCHACHA20_NONCE_LENGTH = ke.CURVE25519_PUBLIC_KEY_SIZE = ke.ETH_PUBLIC_KEY_SIZE = ke.UNCOMPRESSED_PUBLIC_KEY_SIZE = ke.COMPRESSED_PUBLIC_KEY_SIZE = ke.SECRET_KEY_LENGTH = void 0, ke.SECRET_KEY_LENGTH = 32, ke.COMPRESSED_PUBLIC_KEY_SIZE = 33, ke.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65, ke.ETH_PUBLIC_KEY_SIZE = 64, ke.CURVE25519_PUBLIC_KEY_SIZE = 32, ke.XCHACHA20_NONCE_LENGTH = 24, ke.AEAD_TAG_LENGTH = 16, function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.ephemeralKeySize = e8.symmetricNonceLength = e8.symmetricAlgorithm = e8.isHkdfKeyCompressed = e8.isEphemeralKeyCompressed = e8.ellipticCurve = e8.ECIES_CONFIG = void 0;
  var t3 = ke, n2 = function() {
    this.ellipticCurve = "secp256k1", this.isEphemeralKeyCompressed = false, this.isHkdfKeyCompressed = false, this.symmetricAlgorithm = "aes-256-gcm", this.symmetricNonceLength = 16;
  };
  e8.ECIES_CONFIG = new n2();
  e8.ellipticCurve = function() {
    return e8.ECIES_CONFIG.ellipticCurve;
  };
  e8.isEphemeralKeyCompressed = function() {
    return e8.ECIES_CONFIG.isEphemeralKeyCompressed;
  };
  e8.isHkdfKeyCompressed = function() {
    return e8.ECIES_CONFIG.isHkdfKeyCompressed;
  };
  e8.symmetricAlgorithm = function() {
    return e8.ECIES_CONFIG.symmetricAlgorithm;
  };
  e8.symmetricNonceLength = function() {
    return e8.ECIES_CONFIG.symmetricNonceLength;
  };
  e8.ephemeralKeySize = function() {
    var n3 = { secp256k1: e8.ECIES_CONFIG.isEphemeralKeyCompressed ? t3.COMPRESSED_PUBLIC_KEY_SIZE : t3.UNCOMPRESSED_PUBLIC_KEY_SIZE, x25519: t3.CURVE25519_PUBLIC_KEY_SIZE, ed25519: t3.CURVE25519_PUBLIC_KEY_SIZE };
    if (e8.ECIES_CONFIG.ellipticCurve in n3) return n3[e8.ECIES_CONFIG.ellipticCurve];
    throw new Error("Not implemented");
  };
}(Ce);
var Ae = {};
var xe = {};
var Me = {};
var Ie = {};
var Te = {};
var Re = {};
Object.defineProperty(Re, "__esModule", { value: true }), Re.crypto = void 0, Re.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.gcm = e8.ctr = e8.cbc = e8.utils = void 0, e8.randomBytes = i2, e8.getWebcryptoSubtle = o, e8.managedNonce = function(e9) {
    return (0, n2.number)(e9.nonceLength), (t4, ...n3) => ({ encrypt(o2, ...s2) {
      const { nonceLength: a2 } = e9, c2 = i2(a2), l3 = e9(t4, c2, ...n3).encrypt(o2, ...s2), d3 = (0, r3.concatBytes)(c2, l3);
      return l3.fill(0), d3;
    }, decrypt(r4, ...i3) {
      const { nonceLength: o2 } = e9, s2 = r4.subarray(0, o2), a2 = r4.subarray(o2);
      return e9(t4, s2, ...n3).decrypt(a2, ...i3);
    } });
  };
  const t3 = Re, n2 = ge, r3 = pe;
  function i2(e9 = 32) {
    if (t3.crypto && "function" == typeof t3.crypto.getRandomValues) return t3.crypto.getRandomValues(new Uint8Array(e9));
    if (t3.crypto && "function" == typeof t3.crypto.randomBytes) return t3.crypto.randomBytes(e9);
    throw new Error("crypto.getRandomValues must be defined");
  }
  function o() {
    if (t3.crypto && "object" == typeof t3.crypto.subtle && null != t3.crypto.subtle) return t3.crypto.subtle;
    throw new Error("crypto.subtle must be defined");
  }
  e8.utils = { async encrypt(e9, t4, n3, r4) {
    const i3 = o(), s2 = await i3.importKey("raw", e9, t4, true, ["encrypt"]), a2 = await i3.encrypt(n3, s2, r4);
    return new Uint8Array(a2);
  }, async decrypt(e9, t4, n3, r4) {
    const i3 = o(), s2 = await i3.importKey("raw", e9, t4, true, ["decrypt"]), a2 = await i3.decrypt(n3, s2, r4);
    return new Uint8Array(a2);
  } };
  const s = { CBC: "AES-CBC", CTR: "AES-CTR", GCM: "AES-GCM" };
  function a(t4) {
    return (r4, i3, o2) => {
      (0, n2.bytes)(r4), (0, n2.bytes)(i3);
      const a2 = { name: t4, length: 8 * r4.length }, c2 = function(e9, t5, n3) {
        if (e9 === s.CBC) return { name: s.CBC, iv: t5 };
        if (e9 === s.CTR) return { name: s.CTR, counter: t5, length: 64 };
        if (e9 === s.GCM) return n3 ? { name: s.GCM, iv: t5, additionalData: n3 } : { name: s.GCM, iv: t5 };
        throw new Error("unknown aes block mode");
      }(t4, i3, o2);
      return { encrypt: (t5) => ((0, n2.bytes)(t5), e8.utils.encrypt(r4, a2, c2, t5)), decrypt: (t5) => ((0, n2.bytes)(t5), e8.utils.decrypt(r4, a2, c2, t5)) };
    };
  }
  e8.cbc = a(s.CBC), e8.ctr = a(s.CTR), e8.gcm = a(s.GCM);
}(Te);
var Pe = {};
var Oe = {};
var Ne = {};
var Le = {};
function De(e8) {
  if (!Number.isSafeInteger(e8) || e8 < 0) throw new Error(`positive integer expected, not ${e8}`);
}
function $e(e8) {
  if ("boolean" != typeof e8) throw new Error(`boolean expected, not ${e8}`);
}
function Be(e8) {
  return e8 instanceof Uint8Array || null != e8 && "object" == typeof e8 && "Uint8Array" === e8.constructor.name;
}
function Ke(e8, ...t3) {
  if (!Be(e8)) throw new Error("Uint8Array expected");
  if (t3.length > 0 && !t3.includes(e8.length)) throw new Error(`Uint8Array expected of length ${t3}, not of length=${e8.length}`);
}
function je(e8) {
  if ("function" != typeof e8 || "function" != typeof e8.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
  De(e8.outputLen), De(e8.blockLen);
}
function Ue(e8, t3 = true) {
  if (e8.destroyed) throw new Error("Hash instance has been destroyed");
  if (t3 && e8.finished) throw new Error("Hash#digest() has already been called");
}
function He(e8, t3) {
  Ke(e8);
  const n2 = t3.outputLen;
  if (e8.length < n2) throw new Error(`digestInto() expects output buffer of length at least ${n2}`);
}
Object.defineProperty(Le, "__esModule", { value: true }), Le.isBytes = Be, Le.number = De, Le.bool = $e, Le.bytes = Ke, Le.hash = je, Le.exists = Ue, Le.output = He;
var Fe = { number: De, bool: $e, bytes: Ke, hash: je, exists: Ue, output: He };
Le.default = Fe;
var ze = {};
var qe = {};
Object.defineProperty(qe, "__esModule", { value: true }), qe.crypto = void 0, qe.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.Hash = e8.nextTick = e8.byteSwapIfBE = e8.byteSwap = e8.isLE = e8.rotl = e8.rotr = e8.createView = e8.u32 = e8.u8 = void 0, e8.isBytes = function(e9) {
    return e9 instanceof Uint8Array || null != e9 && "object" == typeof e9 && "Uint8Array" === e9.constructor.name;
  }, e8.byteSwap32 = function(t4) {
    for (let n3 = 0; n3 < t4.length; n3++) t4[n3] = (0, e8.byteSwap)(t4[n3]);
  }, e8.bytesToHex = function(e9) {
    (0, n2.bytes)(e9);
    let t4 = "";
    for (let n3 = 0; n3 < e9.length; n3++) t4 += r3[e9[n3]];
    return t4;
  }, e8.hexToBytes = function(e9) {
    if ("string" != typeof e9) throw new Error("hex string expected, got " + typeof e9);
    const t4 = e9.length, n3 = t4 / 2;
    if (t4 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t4);
    const r4 = new Uint8Array(n3);
    for (let t5 = 0, i3 = 0; t5 < n3; t5++, i3 += 2) {
      const n4 = o(e9.charCodeAt(i3)), s2 = o(e9.charCodeAt(i3 + 1));
      if (void 0 === n4 || void 0 === s2) {
        const t6 = e9[i3] + e9[i3 + 1];
        throw new Error('hex string expected, got non-hex character "' + t6 + '" at index ' + i3);
      }
      r4[t5] = 16 * n4 + s2;
    }
    return r4;
  }, e8.asyncLoop = async function(t4, n3, r4) {
    let i3 = Date.now();
    for (let o2 = 0; o2 < t4; o2++) {
      r4(o2);
      const t5 = Date.now() - i3;
      t5 >= 0 && t5 < n3 || (await (0, e8.nextTick)(), i3 += t5);
    }
  }, e8.utf8ToBytes = s, e8.toBytes = a, e8.concatBytes = function(...e9) {
    let t4 = 0;
    for (let r5 = 0; r5 < e9.length; r5++) {
      const i3 = e9[r5];
      (0, n2.bytes)(i3), t4 += i3.length;
    }
    const r4 = new Uint8Array(t4);
    for (let t5 = 0, n3 = 0; t5 < e9.length; t5++) {
      const i3 = e9[t5];
      r4.set(i3, n3), n3 += i3.length;
    }
    return r4;
  }, e8.checkOpts = function(e9, t4) {
    if (void 0 !== t4 && "[object Object]" !== c2.call(t4)) throw new Error("Options should be object or undefined");
    return Object.assign(e9, t4);
  }, e8.wrapConstructor = function(e9) {
    const t4 = (t5) => e9().update(a(t5)).digest(), n3 = e9();
    return t4.outputLen = n3.outputLen, t4.blockLen = n3.blockLen, t4.create = () => e9(), t4;
  }, e8.wrapConstructorWithOpts = function(e9) {
    const t4 = (t5, n4) => e9(n4).update(a(t5)).digest(), n3 = e9({});
    return t4.outputLen = n3.outputLen, t4.blockLen = n3.blockLen, t4.create = (t5) => e9(t5), t4;
  }, e8.wrapXOFConstructorWithOpts = function(e9) {
    const t4 = (t5, n4) => e9(n4).update(a(t5)).digest(), n3 = e9({});
    return t4.outputLen = n3.outputLen, t4.blockLen = n3.blockLen, t4.create = (t5) => e9(t5), t4;
  }, e8.randomBytes = function(e9 = 32) {
    if (t3.crypto && "function" == typeof t3.crypto.getRandomValues) return t3.crypto.getRandomValues(new Uint8Array(e9));
    if (t3.crypto && "function" == typeof t3.crypto.randomBytes) return t3.crypto.randomBytes(e9);
    throw new Error("crypto.getRandomValues must be defined");
  };
  const t3 = qe, n2 = Le;
  e8.u8 = (e9) => new Uint8Array(e9.buffer, e9.byteOffset, e9.byteLength);
  e8.u32 = (e9) => new Uint32Array(e9.buffer, e9.byteOffset, Math.floor(e9.byteLength / 4));
  e8.createView = (e9) => new DataView(e9.buffer, e9.byteOffset, e9.byteLength);
  e8.rotr = (e9, t4) => e9 << 32 - t4 | e9 >>> t4;
  e8.rotl = (e9, t4) => e9 << t4 | e9 >>> 32 - t4 >>> 0, e8.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
  e8.byteSwap = (e9) => e9 << 24 & 4278190080 | e9 << 8 & 16711680 | e9 >>> 8 & 65280 | e9 >>> 24 & 255, e8.byteSwapIfBE = e8.isLE ? (e9) => e9 : (t4) => (0, e8.byteSwap)(t4);
  const r3 = Array.from({ length: 256 }, (e9, t4) => t4.toString(16).padStart(2, "0"));
  const i2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o(e9) {
    return e9 >= i2._0 && e9 <= i2._9 ? e9 - i2._0 : e9 >= i2._A && e9 <= i2._F ? e9 - (i2._A - 10) : e9 >= i2._a && e9 <= i2._f ? e9 - (i2._a - 10) : void 0;
  }
  function s(e9) {
    if ("string" != typeof e9) throw new Error("utf8ToBytes expected string, got " + typeof e9);
    return new Uint8Array(new TextEncoder().encode(e9));
  }
  function a(e9) {
    return "string" == typeof e9 && (e9 = s(e9)), (0, n2.bytes)(e9), e9;
  }
  e8.nextTick = async () => {
  };
  e8.Hash = class {
    clone() {
      return this._cloneInto();
    }
  };
  const c2 = {}.toString;
}(ze), Object.defineProperty(Ne, "__esModule", { value: true }), Ne.HashMD = Ne.Maj = Ne.Chi = void 0;
var We = Le;
var Ve = ze;
Ne.Chi = (e8, t3, n2) => e8 & t3 ^ ~e8 & n2;
Ne.Maj = (e8, t3, n2) => e8 & t3 ^ e8 & n2 ^ t3 & n2;
Ne.HashMD = class extends Ve.Hash {
  constructor(e8, t3, n2, r3) {
    super(), this.blockLen = e8, this.outputLen = t3, this.padOffset = n2, this.isLE = r3, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e8), this.view = (0, Ve.createView)(this.buffer);
  }
  update(e8) {
    (0, We.exists)(this);
    const { view: t3, buffer: n2, blockLen: r3 } = this, i2 = (e8 = (0, Ve.toBytes)(e8)).length;
    for (let o = 0; o < i2; ) {
      const s = Math.min(r3 - this.pos, i2 - o);
      if (s !== r3) n2.set(e8.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === r3 && (this.process(t3, 0), this.pos = 0);
      else {
        const t4 = (0, Ve.createView)(e8);
        for (; r3 <= i2 - o; o += r3) this.process(t4, o);
      }
    }
    return this.length += e8.length, this.roundClean(), this;
  }
  digestInto(e8) {
    (0, We.exists)(this), (0, We.output)(e8, this), this.finished = true;
    const { buffer: t3, view: n2, blockLen: r3, isLE: i2 } = this;
    let { pos: o } = this;
    t3[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r3 - o && (this.process(n2, 0), o = 0);
    for (let e9 = o; e9 < r3; e9++) t3[e9] = 0;
    !function(e9, t4, n3, r4) {
      if ("function" == typeof e9.setBigUint64) return e9.setBigUint64(t4, n3, r4);
      const i3 = BigInt(32), o2 = BigInt(4294967295), s2 = Number(n3 >> i3 & o2), a2 = Number(n3 & o2), c3 = r4 ? 4 : 0, l4 = r4 ? 0 : 4;
      e9.setUint32(t4 + c3, s2, r4), e9.setUint32(t4 + l4, a2, r4);
    }(n2, r3 - 8, BigInt(8 * this.length), i2), this.process(n2, 0);
    const s = (0, Ve.createView)(e8), a = this.outputLen;
    if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c2 = a / 4, l3 = this.get();
    if (c2 > l3.length) throw new Error("_sha2: outputLen bigger than state");
    for (let e9 = 0; e9 < c2; e9++) s.setUint32(4 * e9, l3[e9], i2);
  }
  digest() {
    const { buffer: e8, outputLen: t3 } = this;
    this.digestInto(e8);
    const n2 = e8.slice(0, t3);
    return this.destroy(), n2;
  }
  _cloneInto(e8) {
    e8 || (e8 = new this.constructor()), e8.set(...this.get());
    const { blockLen: t3, buffer: n2, length: r3, finished: i2, destroyed: o, pos: s } = this;
    return e8.length = r3, e8.pos = s, e8.finished = i2, e8.destroyed = o, r3 % t3 && e8.buffer.set(n2), e8;
  }
};
var Ge = {};
Object.defineProperty(Ge, "__esModule", { value: true }), Ge.add5L = Ge.add5H = Ge.add4H = Ge.add4L = Ge.add3H = Ge.add3L = Ge.rotlBL = Ge.rotlBH = Ge.rotlSL = Ge.rotlSH = Ge.rotr32L = Ge.rotr32H = Ge.rotrBL = Ge.rotrBH = Ge.rotrSL = Ge.rotrSH = Ge.shrSL = Ge.shrSH = Ge.toBig = void 0, Ge.fromBig = Je, Ge.split = Qe, Ge.add = ht;
var Ye = BigInt(2 ** 32 - 1);
var Ze = BigInt(32);
function Je(e8, t3 = false) {
  return t3 ? { h: Number(e8 & Ye), l: Number(e8 >> Ze & Ye) } : { h: 0 | Number(e8 >> Ze & Ye), l: 0 | Number(e8 & Ye) };
}
function Qe(e8, t3 = false) {
  let n2 = new Uint32Array(e8.length), r3 = new Uint32Array(e8.length);
  for (let i2 = 0; i2 < e8.length; i2++) {
    const { h: o, l: s } = Je(e8[i2], t3);
    [n2[i2], r3[i2]] = [o, s];
  }
  return [n2, r3];
}
var Xe = (e8, t3) => BigInt(e8 >>> 0) << Ze | BigInt(t3 >>> 0);
Ge.toBig = Xe;
var et = (e8, t3, n2) => e8 >>> n2;
Ge.shrSH = et;
var tt = (e8, t3, n2) => e8 << 32 - n2 | t3 >>> n2;
Ge.shrSL = tt;
var nt = (e8, t3, n2) => e8 >>> n2 | t3 << 32 - n2;
Ge.rotrSH = nt;
var rt = (e8, t3, n2) => e8 << 32 - n2 | t3 >>> n2;
Ge.rotrSL = rt;
var it = (e8, t3, n2) => e8 << 64 - n2 | t3 >>> n2 - 32;
Ge.rotrBH = it;
var ot = (e8, t3, n2) => e8 >>> n2 - 32 | t3 << 64 - n2;
Ge.rotrBL = ot;
var st = (e8, t3) => t3;
Ge.rotr32H = st;
var at = (e8, t3) => e8;
Ge.rotr32L = at;
var ct = (e8, t3, n2) => e8 << n2 | t3 >>> 32 - n2;
Ge.rotlSH = ct;
var lt = (e8, t3, n2) => t3 << n2 | e8 >>> 32 - n2;
Ge.rotlSL = lt;
var dt = (e8, t3, n2) => t3 << n2 - 32 | e8 >>> 64 - n2;
Ge.rotlBH = dt;
var ut = (e8, t3, n2) => e8 << n2 - 32 | t3 >>> 64 - n2;
function ht(e8, t3, n2, r3) {
  const i2 = (t3 >>> 0) + (r3 >>> 0);
  return { h: e8 + n2 + (i2 / 2 ** 32 | 0) | 0, l: 0 | i2 };
}
Ge.rotlBL = ut;
var ft = (e8, t3, n2) => (e8 >>> 0) + (t3 >>> 0) + (n2 >>> 0);
Ge.add3L = ft;
var pt = (e8, t3, n2, r3) => t3 + n2 + r3 + (e8 / 2 ** 32 | 0) | 0;
Ge.add3H = pt;
var gt = (e8, t3, n2, r3) => (e8 >>> 0) + (t3 >>> 0) + (n2 >>> 0) + (r3 >>> 0);
Ge.add4L = gt;
var mt = (e8, t3, n2, r3, i2) => t3 + n2 + r3 + i2 + (e8 / 2 ** 32 | 0) | 0;
Ge.add4H = mt;
var yt = (e8, t3, n2, r3, i2) => (e8 >>> 0) + (t3 >>> 0) + (n2 >>> 0) + (r3 >>> 0) + (i2 >>> 0);
Ge.add5L = yt;
var vt = (e8, t3, n2, r3, i2, o) => t3 + n2 + r3 + i2 + o + (e8 / 2 ** 32 | 0) | 0;
Ge.add5H = vt;
var bt = { fromBig: Je, split: Qe, toBig: Xe, shrSH: et, shrSL: tt, rotrSH: nt, rotrSL: rt, rotrBH: it, rotrBL: ot, rotr32H: st, rotr32L: at, rotlSH: ct, rotlSL: lt, rotlBH: dt, rotlBL: ut, add: ht, add3L: ft, add3H: pt, add4L: gt, add4H: mt, add5H: vt, add5L: yt };
Ge.default = bt, Object.defineProperty(Oe, "__esModule", { value: true }), Oe.sha384 = Oe.sha512_256 = Oe.sha512_224 = Oe.sha512 = Oe.SHA384 = Oe.SHA512_256 = Oe.SHA512_224 = Oe.SHA512 = void 0;
var wt = Ne;
var Et = Ge;
var St = ze;
var [_t, Ct] = (() => Et.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e8) => BigInt(e8))))();
var kt = new Uint32Array(80);
var At = new Uint32Array(80);
var xt = class extends wt.HashMD {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e8, Al: t3, Bh: n2, Bl: r3, Ch: i2, Cl: o, Dh: s, Dl: a, Eh: c2, El: l3, Fh: d3, Fl: u2, Gh: h3, Gl: f2, Hh: p3, Hl: g3 } = this;
    return [e8, t3, n2, r3, i2, o, s, a, c2, l3, d3, u2, h3, f2, p3, g3];
  }
  set(e8, t3, n2, r3, i2, o, s, a, c2, l3, d3, u2, h3, f2, p3, g3) {
    this.Ah = 0 | e8, this.Al = 0 | t3, this.Bh = 0 | n2, this.Bl = 0 | r3, this.Ch = 0 | i2, this.Cl = 0 | o, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | c2, this.El = 0 | l3, this.Fh = 0 | d3, this.Fl = 0 | u2, this.Gh = 0 | h3, this.Gl = 0 | f2, this.Hh = 0 | p3, this.Hl = 0 | g3;
  }
  process(e8, t3) {
    for (let n3 = 0; n3 < 16; n3++, t3 += 4) kt[n3] = e8.getUint32(t3), At[n3] = e8.getUint32(t3 += 4);
    for (let e9 = 16; e9 < 80; e9++) {
      const t4 = 0 | kt[e9 - 15], n3 = 0 | At[e9 - 15], r4 = Et.default.rotrSH(t4, n3, 1) ^ Et.default.rotrSH(t4, n3, 8) ^ Et.default.shrSH(t4, n3, 7), i3 = Et.default.rotrSL(t4, n3, 1) ^ Et.default.rotrSL(t4, n3, 8) ^ Et.default.shrSL(t4, n3, 7), o2 = 0 | kt[e9 - 2], s2 = 0 | At[e9 - 2], a2 = Et.default.rotrSH(o2, s2, 19) ^ Et.default.rotrBH(o2, s2, 61) ^ Et.default.shrSH(o2, s2, 6), c3 = Et.default.rotrSL(o2, s2, 19) ^ Et.default.rotrBL(o2, s2, 61) ^ Et.default.shrSL(o2, s2, 6), l4 = Et.default.add4L(i3, c3, At[e9 - 7], At[e9 - 16]), d4 = Et.default.add4H(l4, r4, a2, kt[e9 - 7], kt[e9 - 16]);
      kt[e9] = 0 | d4, At[e9] = 0 | l4;
    }
    let { Ah: n2, Al: r3, Bh: i2, Bl: o, Ch: s, Cl: a, Dh: c2, Dl: l3, Eh: d3, El: u2, Fh: h3, Fl: f2, Gh: p3, Gl: g3, Hh: m2, Hl: y3 } = this;
    for (let e9 = 0; e9 < 80; e9++) {
      const t4 = Et.default.rotrSH(d3, u2, 14) ^ Et.default.rotrSH(d3, u2, 18) ^ Et.default.rotrBH(d3, u2, 41), v2 = Et.default.rotrSL(d3, u2, 14) ^ Et.default.rotrSL(d3, u2, 18) ^ Et.default.rotrBL(d3, u2, 41), b3 = d3 & h3 ^ ~d3 & p3, w2 = u2 & f2 ^ ~u2 & g3, E2 = Et.default.add5L(y3, v2, w2, Ct[e9], At[e9]), S3 = Et.default.add5H(E2, m2, t4, b3, _t[e9], kt[e9]), _3 = 0 | E2, C3 = Et.default.rotrSH(n2, r3, 28) ^ Et.default.rotrBH(n2, r3, 34) ^ Et.default.rotrBH(n2, r3, 39), k3 = Et.default.rotrSL(n2, r3, 28) ^ Et.default.rotrBL(n2, r3, 34) ^ Et.default.rotrBL(n2, r3, 39), A3 = n2 & i2 ^ n2 & s ^ i2 & s, x3 = r3 & o ^ r3 & a ^ o & a;
      m2 = 0 | p3, y3 = 0 | g3, p3 = 0 | h3, g3 = 0 | f2, h3 = 0 | d3, f2 = 0 | u2, { h: d3, l: u2 } = Et.default.add(0 | c2, 0 | l3, 0 | S3, 0 | _3), c2 = 0 | s, l3 = 0 | a, s = 0 | i2, a = 0 | o, i2 = 0 | n2, o = 0 | r3;
      const M3 = Et.default.add3L(_3, k3, x3);
      n2 = Et.default.add3H(M3, S3, C3, A3), r3 = 0 | M3;
    }
    ({ h: n2, l: r3 } = Et.default.add(0 | this.Ah, 0 | this.Al, 0 | n2, 0 | r3)), { h: i2, l: o } = Et.default.add(0 | this.Bh, 0 | this.Bl, 0 | i2, 0 | o), { h: s, l: a } = Et.default.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a), { h: c2, l: l3 } = Et.default.add(0 | this.Dh, 0 | this.Dl, 0 | c2, 0 | l3), { h: d3, l: u2 } = Et.default.add(0 | this.Eh, 0 | this.El, 0 | d3, 0 | u2), { h: h3, l: f2 } = Et.default.add(0 | this.Fh, 0 | this.Fl, 0 | h3, 0 | f2), { h: p3, l: g3 } = Et.default.add(0 | this.Gh, 0 | this.Gl, 0 | p3, 0 | g3), { h: m2, l: y3 } = Et.default.add(0 | this.Hh, 0 | this.Hl, 0 | m2, 0 | y3), this.set(n2, r3, i2, o, s, a, c2, l3, d3, u2, h3, f2, p3, g3, m2, y3);
  }
  roundClean() {
    kt.fill(0), At.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
Oe.SHA512 = xt;
var Mt = class extends xt {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
Oe.SHA512_224 = Mt;
var It = class extends xt {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
Oe.SHA512_256 = It;
var Tt = class extends xt {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
Oe.SHA384 = Tt, Oe.sha512 = (0, St.wrapConstructor)(() => new xt()), Oe.sha512_224 = (0, St.wrapConstructor)(() => new Mt()), Oe.sha512_256 = (0, St.wrapConstructor)(() => new It()), Oe.sha384 = (0, St.wrapConstructor)(() => new Tt());
var Rt = {};
var Pt = {};
var Ot = {};
var Nt = {};
Object.defineProperty(Nt, "__esModule", { value: true }), Nt.notImplemented = Nt.bitMask = void 0, Nt.isBytes = Bt, Nt.abytes = Kt, Nt.abool = function(e8, t3) {
  if ("boolean" != typeof t3) throw new Error(`${e8} must be valid boolean, got "${t3}".`);
}, Nt.bytesToHex = Ut, Nt.numberToHexUnpadded = Ht, Nt.hexToNumber = Ft, Nt.hexToBytes = Wt, Nt.bytesToNumberBE = function(e8) {
  return Ft(Ut(e8));
}, Nt.bytesToNumberLE = function(e8) {
  return Kt(e8), Ft(Ut(Uint8Array.from(e8).reverse()));
}, Nt.numberToBytesBE = Vt, Nt.numberToBytesLE = function(e8, t3) {
  return Vt(e8, t3).reverse();
}, Nt.numberToVarBytesBE = function(e8) {
  return Wt(Ht(e8));
}, Nt.ensureBytes = function(e8, t3, n2) {
  let r3;
  if ("string" == typeof t3) try {
    r3 = Wt(t3);
  } catch (n3) {
    throw new Error(`${e8} must be valid hex string, got "${t3}". Cause: ${n3}`);
  }
  else {
    if (!Bt(t3)) throw new Error(`${e8} must be hex string or Uint8Array`);
    r3 = Uint8Array.from(t3);
  }
  const i2 = r3.length;
  if ("number" == typeof n2 && i2 !== n2) throw new Error(`${e8} expected ${n2} bytes, got ${i2}`);
  return r3;
}, Nt.concatBytes = Gt, Nt.equalBytes = function(e8, t3) {
  if (e8.length !== t3.length) return false;
  let n2 = 0;
  for (let r3 = 0; r3 < e8.length; r3++) n2 |= e8[r3] ^ t3[r3];
  return 0 === n2;
}, Nt.utf8ToBytes = function(e8) {
  if ("string" != typeof e8) throw new Error("utf8ToBytes expected string, got " + typeof e8);
  return new Uint8Array(new TextEncoder().encode(e8));
}, Nt.inRange = Zt, Nt.aInRange = function(e8, t3, n2, r3) {
  if (!Zt(t3, n2, r3)) throw new Error(`expected valid ${e8}: ${n2} <= n < ${r3}, got ${typeof t3} ${t3}`);
}, Nt.bitLen = function(e8) {
  let t3;
  for (t3 = 0; e8 > Lt; e8 >>= Dt, t3 += 1) ;
  return t3;
}, Nt.bitGet = function(e8, t3) {
  return e8 >> BigInt(t3) & Dt;
}, Nt.bitSet = function(e8, t3, n2) {
  return e8 | (n2 ? Dt : Lt) << BigInt(t3);
}, Nt.createHmacDrbg = function(e8, t3, n2) {
  if ("number" != typeof e8 || e8 < 2) throw new Error("hashLen must be a number");
  if ("number" != typeof t3 || t3 < 2) throw new Error("qByteLen must be a number");
  if ("function" != typeof n2) throw new Error("hmacFn must be a function");
  let r3 = Jt(e8), i2 = Jt(e8), o = 0;
  const s = () => {
    r3.fill(1), i2.fill(0), o = 0;
  }, a = (...e9) => n2(i2, r3, ...e9), c2 = (e9 = Jt()) => {
    i2 = a(Qt([0]), e9), r3 = a(), 0 !== e9.length && (i2 = a(Qt([1]), e9), r3 = a());
  }, l3 = () => {
    if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let e9 = 0;
    const n3 = [];
    for (; e9 < t3; ) {
      r3 = a();
      const t4 = r3.slice();
      n3.push(t4), e9 += r3.length;
    }
    return Gt(...n3);
  };
  return (e9, t4) => {
    let n3;
    for (s(), c2(e9); !(n3 = t4(l3())); ) c2();
    return s(), n3;
  };
}, Nt.validateObject = function(e8, t3, n2 = {}) {
  const r3 = (t4, n3, r4) => {
    const i2 = Xt[n3];
    if ("function" != typeof i2) throw new Error(`Invalid validator "${n3}", expected function`);
    const o = e8[t4];
    if (!(r4 && void 0 === o || i2(o, e8))) throw new Error(`Invalid param ${String(t4)}=${o} (${typeof o}), expected ${n3}`);
  };
  for (const [e9, n3] of Object.entries(t3)) r3(e9, n3, false);
  for (const [e9, t4] of Object.entries(n2)) r3(e9, t4, true);
  return e8;
}, Nt.memoized = function(e8) {
  const t3 = /* @__PURE__ */ new WeakMap();
  return (n2, ...r3) => {
    const i2 = t3.get(n2);
    if (void 0 !== i2) return i2;
    const o = e8(n2, ...r3);
    return t3.set(n2, o), o;
  };
};
var Lt = BigInt(0);
var Dt = BigInt(1);
var $t = BigInt(2);
function Bt(e8) {
  return e8 instanceof Uint8Array || null != e8 && "object" == typeof e8 && "Uint8Array" === e8.constructor.name;
}
function Kt(e8) {
  if (!Bt(e8)) throw new Error("Uint8Array expected");
}
var jt = Array.from({ length: 256 }, (e8, t3) => t3.toString(16).padStart(2, "0"));
function Ut(e8) {
  Kt(e8);
  let t3 = "";
  for (let n2 = 0; n2 < e8.length; n2++) t3 += jt[e8[n2]];
  return t3;
}
function Ht(e8) {
  const t3 = e8.toString(16);
  return 1 & t3.length ? `0${t3}` : t3;
}
function Ft(e8) {
  if ("string" != typeof e8) throw new Error("hex string expected, got " + typeof e8);
  return BigInt("" === e8 ? "0" : `0x${e8}`);
}
var zt = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function qt(e8) {
  return e8 >= zt._0 && e8 <= zt._9 ? e8 - zt._0 : e8 >= zt._A && e8 <= zt._F ? e8 - (zt._A - 10) : e8 >= zt._a && e8 <= zt._f ? e8 - (zt._a - 10) : void 0;
}
function Wt(e8) {
  if ("string" != typeof e8) throw new Error("hex string expected, got " + typeof e8);
  const t3 = e8.length, n2 = t3 / 2;
  if (t3 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t3);
  const r3 = new Uint8Array(n2);
  for (let t4 = 0, i2 = 0; t4 < n2; t4++, i2 += 2) {
    const n3 = qt(e8.charCodeAt(i2)), o = qt(e8.charCodeAt(i2 + 1));
    if (void 0 === n3 || void 0 === o) {
      const t5 = e8[i2] + e8[i2 + 1];
      throw new Error('hex string expected, got non-hex character "' + t5 + '" at index ' + i2);
    }
    r3[t4] = 16 * n3 + o;
  }
  return r3;
}
function Vt(e8, t3) {
  return Wt(e8.toString(16).padStart(2 * t3, "0"));
}
function Gt(...e8) {
  let t3 = 0;
  for (let n3 = 0; n3 < e8.length; n3++) {
    const r3 = e8[n3];
    Kt(r3), t3 += r3.length;
  }
  const n2 = new Uint8Array(t3);
  for (let t4 = 0, r3 = 0; t4 < e8.length; t4++) {
    const i2 = e8[t4];
    n2.set(i2, r3), r3 += i2.length;
  }
  return n2;
}
var Yt = (e8) => "bigint" == typeof e8 && Lt <= e8;
function Zt(e8, t3, n2) {
  return Yt(e8) && Yt(t3) && Yt(n2) && t3 <= e8 && e8 < n2;
}
Nt.bitMask = (e8) => ($t << BigInt(e8 - 1)) - Dt;
var Jt = (e8) => new Uint8Array(e8);
var Qt = (e8) => Uint8Array.from(e8);
var Xt = { bigint: (e8) => "bigint" == typeof e8, function: (e8) => "function" == typeof e8, boolean: (e8) => "boolean" == typeof e8, string: (e8) => "string" == typeof e8, stringOrUint8Array: (e8) => "string" == typeof e8 || Bt(e8), isSafeInteger: (e8) => Number.isSafeInteger(e8), array: (e8) => Array.isArray(e8), field: (e8, t3) => t3.Fp.isValid(e8), hash: (e8) => "function" == typeof e8 && Number.isSafeInteger(e8.outputLen) };
Nt.notImplemented = () => {
  throw new Error("not implemented");
}, Object.defineProperty(Ot, "__esModule", { value: true }), Ot.isNegativeLE = void 0, Ot.mod = ln, Ot.pow = dn, Ot.pow2 = function(e8, t3, n2) {
  let r3 = e8;
  for (; t3-- > tn; ) r3 *= r3, r3 %= n2;
  return r3;
}, Ot.invert = un, Ot.tonelliShanks = hn, Ot.FpSqrt = fn, Ot.validateField = function(e8) {
  const t3 = pn.reduce((e9, t4) => (e9[t4] = "function", e9), { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" });
  return (0, en2.validateObject)(e8, t3);
}, Ot.FpPow = gn, Ot.FpInvertBatch = mn, Ot.FpDiv = function(e8, t3, n2) {
  return e8.mul(t3, "bigint" == typeof n2 ? un(n2, e8.ORDER) : e8.inv(n2));
}, Ot.FpLegendre = yn, Ot.FpIsSquare = function(e8) {
  const t3 = yn(e8.ORDER);
  return (n2) => {
    const r3 = t3(e8, n2);
    return e8.eql(r3, e8.ZERO) || e8.eql(r3, e8.ONE);
  };
}, Ot.nLength = vn, Ot.Field = function(e8, t3, n2 = false, r3 = {}) {
  if (e8 <= tn) throw new Error(`Expected Field ORDER > 0, got ${e8}`);
  const { nBitLength: i2, nByteLength: o } = vn(e8, t3);
  if (o > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
  const s = fn(e8), a = Object.freeze({ ORDER: e8, BITS: i2, BYTES: o, MASK: (0, en2.bitMask)(i2), ZERO: tn, ONE: nn, create: (t4) => ln(t4, e8), isValid: (t4) => {
    if ("bigint" != typeof t4) throw new Error("Invalid field element: expected bigint, got " + typeof t4);
    return tn <= t4 && t4 < e8;
  }, is0: (e9) => e9 === tn, isOdd: (e9) => (e9 & nn) === nn, neg: (t4) => ln(-t4, e8), eql: (e9, t4) => e9 === t4, sqr: (t4) => ln(t4 * t4, e8), add: (t4, n3) => ln(t4 + n3, e8), sub: (t4, n3) => ln(t4 - n3, e8), mul: (t4, n3) => ln(t4 * n3, e8), pow: (e9, t4) => gn(a, e9, t4), div: (t4, n3) => ln(t4 * un(n3, e8), e8), sqrN: (e9) => e9 * e9, addN: (e9, t4) => e9 + t4, subN: (e9, t4) => e9 - t4, mulN: (e9, t4) => e9 * t4, inv: (t4) => un(t4, e8), sqrt: r3.sqrt || ((e9) => s(a, e9)), invertBatch: (e9) => mn(a, e9), cmov: (e9, t4, n3) => n3 ? t4 : e9, toBytes: (e9) => n2 ? (0, en2.numberToBytesLE)(e9, o) : (0, en2.numberToBytesBE)(e9, o), fromBytes: (e9) => {
    if (e9.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${e9.length}`);
    return n2 ? (0, en2.bytesToNumberLE)(e9) : (0, en2.bytesToNumberBE)(e9);
  } });
  return Object.freeze(a);
}, Ot.FpSqrtOdd = function(e8, t3) {
  if (!e8.isOdd) throw new Error("Field doesn't have isOdd");
  const n2 = e8.sqrt(t3);
  return e8.isOdd(n2) ? n2 : e8.neg(n2);
}, Ot.FpSqrtEven = function(e8, t3) {
  if (!e8.isOdd) throw new Error("Field doesn't have isOdd");
  const n2 = e8.sqrt(t3);
  return e8.isOdd(n2) ? e8.neg(n2) : n2;
}, Ot.hashToPrivateScalar = function(e8, t3, n2 = false) {
  e8 = (0, en2.ensureBytes)("privateHash", e8);
  const r3 = e8.length, i2 = vn(t3).nByteLength + 8;
  if (i2 < 24 || r3 < i2 || r3 > 1024) throw new Error(`hashToPrivateScalar: expected ${i2}-1024 bytes of input, got ${r3}`);
  const o = n2 ? (0, en2.bytesToNumberLE)(e8) : (0, en2.bytesToNumberBE)(e8);
  return ln(o, t3 - nn) + nn;
}, Ot.getFieldBytesLength = bn, Ot.getMinHashLength = wn, Ot.mapHashToField = function(e8, t3, n2 = false) {
  const r3 = e8.length, i2 = bn(t3), o = wn(t3);
  if (r3 < 16 || r3 < o || r3 > 1024) throw new Error(`expected ${o}-1024 bytes of input, got ${r3}`);
  const s = ln(n2 ? (0, en2.bytesToNumberBE)(e8) : (0, en2.bytesToNumberLE)(e8), t3 - nn) + nn;
  return n2 ? (0, en2.numberToBytesLE)(s, i2) : (0, en2.numberToBytesBE)(s, i2);
};
var en2 = Nt;
var tn = BigInt(0);
var nn = BigInt(1);
var rn = BigInt(2);
var on = BigInt(3);
var sn = BigInt(4);
var an = BigInt(5);
var cn = BigInt(8);
function ln(e8, t3) {
  const n2 = e8 % t3;
  return n2 >= tn ? n2 : t3 + n2;
}
function dn(e8, t3, n2) {
  if (n2 <= tn || t3 < tn) throw new Error("Expected power/modulo > 0");
  if (n2 === nn) return tn;
  let r3 = nn;
  for (; t3 > tn; ) t3 & nn && (r3 = r3 * e8 % n2), e8 = e8 * e8 % n2, t3 >>= nn;
  return r3;
}
function un(e8, t3) {
  if (e8 === tn || t3 <= tn) throw new Error(`invert: expected positive integers, got n=${e8} mod=${t3}`);
  let n2 = ln(e8, t3), r3 = t3, i2 = tn, o = nn;
  for (; n2 !== tn; ) {
    const e9 = r3 % n2, t4 = i2 - o * (r3 / n2);
    r3 = n2, n2 = e9, i2 = o, o = t4;
  }
  if (r3 !== nn) throw new Error("invert: does not exist");
  return ln(i2, t3);
}
function hn(e8) {
  const t3 = (e8 - nn) / rn;
  let n2, r3, i2;
  for (n2 = e8 - nn, r3 = 0; n2 % rn === tn; n2 /= rn, r3++) ;
  for (i2 = rn; i2 < e8 && dn(i2, t3, e8) !== e8 - nn; i2++) ;
  if (1 === r3) {
    const t4 = (e8 + nn) / sn;
    return function(e9, n3) {
      const r4 = e9.pow(n3, t4);
      if (!e9.eql(e9.sqr(r4), n3)) throw new Error("Cannot find square root");
      return r4;
    };
  }
  const o = (n2 + nn) / rn;
  return function(e9, s) {
    if (e9.pow(s, t3) === e9.neg(e9.ONE)) throw new Error("Cannot find square root");
    let a = r3, c2 = e9.pow(e9.mul(e9.ONE, i2), n2), l3 = e9.pow(s, o), d3 = e9.pow(s, n2);
    for (; !e9.eql(d3, e9.ONE); ) {
      if (e9.eql(d3, e9.ZERO)) return e9.ZERO;
      let t4 = 1;
      for (let n4 = e9.sqr(d3); t4 < a && !e9.eql(n4, e9.ONE); t4++) n4 = e9.sqr(n4);
      const n3 = e9.pow(c2, nn << BigInt(a - t4 - 1));
      c2 = e9.sqr(n3), l3 = e9.mul(l3, n3), d3 = e9.mul(d3, c2), a = t4;
    }
    return l3;
  };
}
function fn(e8) {
  if (e8 % sn === on) {
    const t3 = (e8 + nn) / sn;
    return function(e9, n2) {
      const r3 = e9.pow(n2, t3);
      if (!e9.eql(e9.sqr(r3), n2)) throw new Error("Cannot find square root");
      return r3;
    };
  }
  if (e8 % cn === an) {
    const t3 = (e8 - an) / cn;
    return function(e9, n2) {
      const r3 = e9.mul(n2, rn), i2 = e9.pow(r3, t3), o = e9.mul(n2, i2), s = e9.mul(e9.mul(o, rn), i2), a = e9.mul(o, e9.sub(s, e9.ONE));
      if (!e9.eql(e9.sqr(a), n2)) throw new Error("Cannot find square root");
      return a;
    };
  }
  return hn(e8);
}
BigInt(9), BigInt(16);
Ot.isNegativeLE = (e8, t3) => (ln(e8, t3) & nn) === nn;
var pn = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function gn(e8, t3, n2) {
  if (n2 < tn) throw new Error("Expected power > 0");
  if (n2 === tn) return e8.ONE;
  if (n2 === nn) return t3;
  let r3 = e8.ONE, i2 = t3;
  for (; n2 > tn; ) n2 & nn && (r3 = e8.mul(r3, i2)), i2 = e8.sqr(i2), n2 >>= nn;
  return r3;
}
function mn(e8, t3) {
  const n2 = new Array(t3.length), r3 = t3.reduce((t4, r4, i3) => e8.is0(r4) ? t4 : (n2[i3] = t4, e8.mul(t4, r4)), e8.ONE), i2 = e8.inv(r3);
  return t3.reduceRight((t4, r4, i3) => e8.is0(r4) ? t4 : (n2[i3] = e8.mul(t4, n2[i3]), e8.mul(t4, r4)), i2), n2;
}
function yn(e8) {
  const t3 = (e8 - nn) / rn;
  return (e9, n2) => e9.pow(n2, t3);
}
function vn(e8, t3) {
  const n2 = void 0 !== t3 ? t3 : e8.toString(2).length;
  return { nBitLength: n2, nByteLength: Math.ceil(n2 / 8) };
}
function bn(e8) {
  if ("bigint" != typeof e8) throw new Error("field order must be bigint");
  const t3 = e8.toString(2).length;
  return Math.ceil(t3 / 8);
}
function wn(e8) {
  const t3 = bn(e8);
  return t3 + Math.ceil(t3 / 2);
}
Object.defineProperty(Pt, "__esModule", { value: true }), Pt.wNAF = function(e8, t3) {
  const n2 = (e9, t4) => {
    const n3 = t4.negate();
    return e9 ? n3 : t4;
  }, r3 = (e9) => {
    if (!Number.isSafeInteger(e9) || e9 <= 0 || e9 > t3) throw new Error(`Wrong window size=${e9}, should be [1..${t3}]`);
  }, i2 = (e9) => {
    r3(e9);
    return { windows: Math.ceil(t3 / e9) + 1, windowSize: 2 ** (e9 - 1) };
  };
  return { constTimeNegate: n2, unsafeLadder(t4, n3) {
    let r4 = e8.ZERO, i3 = t4;
    for (; n3 > _n; ) n3 & Cn && (r4 = r4.add(i3)), i3 = i3.double(), n3 >>= Cn;
    return r4;
  }, precomputeWindow(e9, t4) {
    const { windows: n3, windowSize: r4 } = i2(t4), o = [];
    let s = e9, a = s;
    for (let e10 = 0; e10 < n3; e10++) {
      a = s, o.push(a);
      for (let e11 = 1; e11 < r4; e11++) a = a.add(s), o.push(a);
      s = a.double();
    }
    return o;
  }, wNAF(t4, r4, o) {
    const { windows: s, windowSize: a } = i2(t4);
    let c2 = e8.ZERO, l3 = e8.BASE;
    const d3 = BigInt(2 ** t4 - 1), u2 = 2 ** t4, h3 = BigInt(t4);
    for (let e9 = 0; e9 < s; e9++) {
      const t5 = e9 * a;
      let i3 = Number(o & d3);
      o >>= h3, i3 > a && (i3 -= u2, o += Cn);
      const s2 = t5, f2 = t5 + Math.abs(i3) - 1, p3 = e9 % 2 != 0, g3 = i3 < 0;
      0 === i3 ? l3 = l3.add(n2(p3, r4[s2])) : c2 = c2.add(n2(g3, r4[f2]));
    }
    return { p: c2, f: l3 };
  }, wNAFCached(e9, t4, n3) {
    const r4 = An.get(e9) || 1;
    let i3 = kn.get(e9);
    return i3 || (i3 = this.precomputeWindow(e9, r4), 1 !== r4 && kn.set(e9, n3(i3))), this.wNAF(r4, i3, t4);
  }, setWindowSize(e9, t4) {
    r3(t4), An.set(e9, t4), kn.delete(e9);
  } };
}, Pt.pippenger = function(e8, t3, n2, r3) {
  if (!Array.isArray(n2) || !Array.isArray(r3) || r3.length !== n2.length) throw new Error("arrays of points and scalars must have equal length");
  r3.forEach((e9, n3) => {
    if (!t3.isValid(e9)) throw new Error(`wrong scalar at index ${n3}`);
  }), n2.forEach((t4, n3) => {
    if (!(t4 instanceof e8)) throw new Error(`wrong point at index ${n3}`);
  });
  const i2 = (0, Sn.bitLen)(BigInt(n2.length)), o = i2 > 12 ? i2 - 3 : i2 > 4 ? i2 - 2 : i2 ? 2 : 1, s = (1 << o) - 1, a = new Array(s + 1).fill(e8.ZERO), c2 = Math.floor((t3.BITS - 1) / o) * o;
  let l3 = e8.ZERO;
  for (let t4 = c2; t4 >= 0; t4 -= o) {
    a.fill(e8.ZERO);
    for (let e9 = 0; e9 < r3.length; e9++) {
      const i4 = r3[e9], o2 = Number(i4 >> BigInt(t4) & BigInt(s));
      a[o2] = a[o2].add(n2[e9]);
    }
    let i3 = e8.ZERO;
    for (let t5 = a.length - 1, n3 = e8.ZERO; t5 > 0; t5--) n3 = n3.add(a[t5]), i3 = i3.add(n3);
    if (l3 = l3.add(i3), 0 !== t4) for (let e9 = 0; e9 < o; e9++) l3 = l3.double();
  }
  return l3;
}, Pt.validateBasic = function(e8) {
  return (0, En.validateField)(e8.Fp), (0, Sn.validateObject)(e8, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...(0, En.nLength)(e8.n, e8.nBitLength), ...e8, p: e8.Fp.ORDER });
};
var En = Ot;
var Sn = Nt;
var _n = BigInt(0);
var Cn = BigInt(1);
var kn = /* @__PURE__ */ new WeakMap();
var An = /* @__PURE__ */ new WeakMap();
Object.defineProperty(Rt, "__esModule", { value: true }), Rt.twistedEdwards = function(e8) {
  const t3 = function(e9) {
    const t4 = (0, xn.validateBasic)(e9);
    return In.validateObject(e9, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...t4 });
  }(e8), { Fp: n2, n: r3, prehash: i2, hash: o, randomBytes: s, nByteLength: a, h: c2 } = t3, l3 = On << BigInt(8 * a) - Pn, d3 = n2.create, u2 = (0, Mn.Field)(t3.n, t3.nBitLength), h3 = t3.uvRatio || ((e9, t4) => {
    try {
      return { isValid: true, value: n2.sqrt(e9 * n2.inv(t4)) };
    } catch (e10) {
      return { isValid: false, value: Rn };
    }
  }), f2 = t3.adjustScalarBytes || ((e9) => e9), p3 = t3.domain || ((e9, t4, n3) => {
    if ((0, Tn.abool)("phflag", n3), t4.length || n3) throw new Error("Contexts/pre-hash are not supported");
    return e9;
  });
  function g3(e9, t4) {
    In.aInRange("coordinate " + e9, t4, Rn, l3);
  }
  function m2(e9) {
    if (!(e9 instanceof b3)) throw new Error("ExtendedPoint expected");
  }
  const y3 = (0, Tn.memoized)((e9, t4) => {
    const { ex: r4, ey: i3, ez: o2 } = e9, s2 = e9.is0();
    null == t4 && (t4 = s2 ? Nn : n2.inv(o2));
    const a2 = d3(r4 * t4), c3 = d3(i3 * t4), l4 = d3(o2 * t4);
    if (s2) return { x: Rn, y: Pn };
    if (l4 !== Pn) throw new Error("invZ was invalid");
    return { x: a2, y: c3 };
  }), v2 = (0, Tn.memoized)((e9) => {
    const { a: n3, d: r4 } = t3;
    if (e9.is0()) throw new Error("bad point: ZERO");
    const { ex: i3, ey: o2, ez: s2, et: a2 } = e9, c3 = d3(i3 * i3), l4 = d3(o2 * o2), u3 = d3(s2 * s2), h4 = d3(u3 * u3), f3 = d3(c3 * n3);
    if (d3(u3 * d3(f3 + l4)) !== d3(h4 + d3(r4 * d3(c3 * l4)))) throw new Error("bad point: equation left != right (1)");
    if (d3(i3 * o2) !== d3(s2 * a2)) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class b3 {
    constructor(e9, t4, n3, r4) {
      this.ex = e9, this.ey = t4, this.ez = n3, this.et = r4, g3("x", e9), g3("y", t4), g3("z", n3), g3("t", r4), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(e9) {
      if (e9 instanceof b3) throw new Error("extended point not allowed");
      const { x: t4, y: n3 } = e9 || {};
      return g3("x", t4), g3("y", n3), new b3(t4, n3, Pn, d3(t4 * n3));
    }
    static normalizeZ(e9) {
      const t4 = n2.invertBatch(e9.map((e10) => e10.ez));
      return e9.map((e10, n3) => e10.toAffine(t4[n3])).map(b3.fromAffine);
    }
    static msm(e9, t4) {
      return (0, xn.pippenger)(b3, u2, e9, t4);
    }
    _setWindowSize(e9) {
      S3.setWindowSize(this, e9);
    }
    assertValidity() {
      v2(this);
    }
    equals(e9) {
      m2(e9);
      const { ex: t4, ey: n3, ez: r4 } = this, { ex: i3, ey: o2, ez: s2 } = e9, a2 = d3(t4 * s2), c3 = d3(i3 * r4), l4 = d3(n3 * s2), u3 = d3(o2 * r4);
      return a2 === c3 && l4 === u3;
    }
    is0() {
      return this.equals(b3.ZERO);
    }
    negate() {
      return new b3(d3(-this.ex), this.ey, this.ez, d3(-this.et));
    }
    double() {
      const { a: e9 } = t3, { ex: n3, ey: r4, ez: i3 } = this, o2 = d3(n3 * n3), s2 = d3(r4 * r4), a2 = d3(On * d3(i3 * i3)), c3 = d3(e9 * o2), l4 = n3 + r4, u3 = d3(d3(l4 * l4) - o2 - s2), h4 = c3 + s2, f3 = h4 - a2, p4 = c3 - s2, g4 = d3(u3 * f3), m3 = d3(h4 * p4), y4 = d3(u3 * p4), v3 = d3(f3 * h4);
      return new b3(g4, m3, v3, y4);
    }
    add(e9) {
      m2(e9);
      const { a: n3, d: r4 } = t3, { ex: i3, ey: o2, ez: s2, et: a2 } = this, { ex: c3, ey: l4, ez: u3, et: h4 } = e9;
      if (n3 === BigInt(-1)) {
        const e10 = d3((o2 - i3) * (l4 + c3)), t4 = d3((o2 + i3) * (l4 - c3)), n4 = d3(t4 - e10);
        if (n4 === Rn) return this.double();
        const r5 = d3(s2 * On * h4), f4 = d3(a2 * On * u3), p5 = f4 + r5, g5 = t4 + e10, m3 = f4 - r5, y5 = d3(p5 * n4), v4 = d3(g5 * m3), w4 = d3(p5 * m3), E4 = d3(n4 * g5);
        return new b3(y5, v4, E4, w4);
      }
      const f3 = d3(i3 * c3), p4 = d3(o2 * l4), g4 = d3(a2 * r4 * h4), y4 = d3(s2 * u3), v3 = d3((i3 + o2) * (c3 + l4) - f3 - p4), w3 = y4 - g4, E3 = y4 + g4, S4 = d3(p4 - n3 * f3), _4 = d3(v3 * w3), C4 = d3(E3 * S4), k4 = d3(v3 * S4), A4 = d3(w3 * E3);
      return new b3(_4, C4, A4, k4);
    }
    subtract(e9) {
      return this.add(e9.negate());
    }
    wNAF(e9) {
      return S3.wNAFCached(this, e9, b3.normalizeZ);
    }
    multiply(e9) {
      const t4 = e9;
      In.aInRange("scalar", t4, Pn, r3);
      const { p: n3, f: i3 } = this.wNAF(t4);
      return b3.normalizeZ([n3, i3])[0];
    }
    multiplyUnsafe(e9) {
      const t4 = e9;
      return In.aInRange("scalar", t4, Rn, r3), t4 === Rn ? E2 : this.equals(E2) || t4 === Pn ? this : this.equals(w2) ? this.wNAF(t4).p : S3.unsafeLadder(this, t4);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c2).is0();
    }
    isTorsionFree() {
      return S3.unsafeLadder(this, r3).is0();
    }
    toAffine(e9) {
      return y3(this, e9);
    }
    clearCofactor() {
      const { h: e9 } = t3;
      return e9 === Pn ? this : this.multiplyUnsafe(e9);
    }
    static fromHex(e9, r4 = false) {
      const { d: i3, a: o2 } = t3, s2 = n2.BYTES;
      e9 = (0, Tn.ensureBytes)("pointHex", e9, s2), (0, Tn.abool)("zip215", r4);
      const a2 = e9.slice(), c3 = e9[s2 - 1];
      a2[s2 - 1] = -129 & c3;
      const u3 = In.bytesToNumberLE(a2), f3 = r4 ? l3 : n2.ORDER;
      In.aInRange("pointHex.y", u3, Rn, f3);
      const p4 = d3(u3 * u3), g4 = d3(p4 - Pn), m3 = d3(i3 * p4 - o2);
      let { isValid: y4, value: v3 } = h3(g4, m3);
      if (!y4) throw new Error("Point.fromHex: invalid y coordinate");
      const w3 = (v3 & Pn) === Pn, E3 = 0 != (128 & c3);
      if (!r4 && v3 === Rn && E3) throw new Error("Point.fromHex: x=0 and x_0=1");
      return E3 !== w3 && (v3 = d3(-v3)), b3.fromAffine({ x: v3, y: u3 });
    }
    static fromPrivateKey(e9) {
      return k3(e9).point;
    }
    toRawBytes() {
      const { x: e9, y: t4 } = this.toAffine(), r4 = In.numberToBytesLE(t4, n2.BYTES);
      return r4[r4.length - 1] |= e9 & Pn ? 128 : 0, r4;
    }
    toHex() {
      return In.bytesToHex(this.toRawBytes());
    }
  }
  b3.BASE = new b3(t3.Gx, t3.Gy, Pn, d3(t3.Gx * t3.Gy)), b3.ZERO = new b3(Rn, Pn, Pn, Rn);
  const { BASE: w2, ZERO: E2 } = b3, S3 = (0, xn.wNAF)(b3, 8 * a);
  function _3(e9) {
    return (0, Mn.mod)(e9, r3);
  }
  function C3(e9) {
    return _3(In.bytesToNumberLE(e9));
  }
  function k3(e9) {
    const t4 = a;
    e9 = (0, Tn.ensureBytes)("private key", e9, t4);
    const n3 = (0, Tn.ensureBytes)("hashed private key", o(e9), 2 * t4), r4 = f2(n3.slice(0, t4)), i3 = n3.slice(t4, 2 * t4), s2 = C3(r4), c3 = w2.multiply(s2), l4 = c3.toRawBytes();
    return { head: r4, prefix: i3, scalar: s2, point: c3, pointBytes: l4 };
  }
  function A3(e9 = new Uint8Array(), ...t4) {
    const n3 = In.concatBytes(...t4);
    return C3(o(p3(n3, (0, Tn.ensureBytes)("context", e9), !!i2)));
  }
  const x3 = Ln;
  w2._setWindowSize(8);
  const M3 = { getExtendedPublicKey: k3, randomPrivateKey: () => s(n2.BYTES), precompute: (e9 = 8, t4 = b3.BASE) => (t4._setWindowSize(e9), t4.multiply(BigInt(3)), t4) };
  return { CURVE: t3, getPublicKey: function(e9) {
    return k3(e9).pointBytes;
  }, sign: function(e9, t4, o2 = {}) {
    e9 = (0, Tn.ensureBytes)("message", e9), i2 && (e9 = i2(e9));
    const { prefix: s2, scalar: c3, pointBytes: l4 } = k3(t4), d4 = A3(o2.context, s2, e9), u3 = w2.multiply(d4).toRawBytes(), h4 = _3(d4 + A3(o2.context, u3, l4, e9) * c3);
    In.aInRange("signature.s", h4, Rn, r3);
    const f3 = In.concatBytes(u3, In.numberToBytesLE(h4, n2.BYTES));
    return (0, Tn.ensureBytes)("result", f3, 2 * a);
  }, verify: function(e9, t4, r4, o2 = x3) {
    const { context: s2, zip215: a2 } = o2, c3 = n2.BYTES;
    e9 = (0, Tn.ensureBytes)("signature", e9, 2 * c3), t4 = (0, Tn.ensureBytes)("message", t4), void 0 !== a2 && (0, Tn.abool)("zip215", a2), i2 && (t4 = i2(t4));
    const l4 = In.bytesToNumberLE(e9.slice(c3, 2 * c3));
    let d4, u3, h4;
    try {
      d4 = b3.fromHex(r4, a2), u3 = b3.fromHex(e9.slice(0, c3), a2), h4 = w2.multiplyUnsafe(l4);
    } catch (e10) {
      return false;
    }
    if (!a2 && d4.isSmallOrder()) return false;
    const f3 = A3(s2, u3.toRawBytes(), d4.toRawBytes(), t4);
    return u3.add(d4.multiplyUnsafe(f3)).subtract(h4).clearCofactor().equals(b3.ZERO);
  }, ExtendedPoint: b3, utils: M3 };
};
var xn = Pt;
var Mn = Ot;
var In = Nt;
var Tn = Nt;
var Rn = BigInt(0);
var Pn = BigInt(1);
var On = BigInt(2);
var Nn = BigInt(8);
var Ln = { zip215: true };
var Dn = {};
Object.defineProperty(Dn, "__esModule", { value: true }), Dn.expand_message_xmd = Fn, Dn.expand_message_xof = zn, Dn.hash_to_field = qn, Dn.isogenyMap = function(e8, t3) {
  const n2 = t3.map((e9) => Array.from(e9).reverse());
  return (t4, r3) => {
    const [i2, o, s, a] = n2.map((n3) => n3.reduce((n4, r4) => e8.add(e8.mul(n4, t4), r4)));
    return t4 = e8.div(i2, o), r3 = e8.mul(r3, e8.div(s, a)), { x: t4, y: r3 };
  };
}, Dn.createHasher = function(e8, t3, n2) {
  if ("function" != typeof t3) throw new Error("mapToCurve() must be defined");
  return { hashToCurve(r3, i2) {
    const o = qn(r3, 2, { ...n2, DST: n2.DST, ...i2 }), s = e8.fromAffine(t3(o[0])), a = e8.fromAffine(t3(o[1])), c2 = s.add(a).clearCofactor();
    return c2.assertValidity(), c2;
  }, encodeToCurve(r3, i2) {
    const o = qn(r3, 1, { ...n2, DST: n2.encodeDST, ...i2 }), s = e8.fromAffine(t3(o[0])).clearCofactor();
    return s.assertValidity(), s;
  }, mapToCurve(n3) {
    if (!Array.isArray(n3)) throw new Error("mapToCurve: expected array of bigints");
    for (const e9 of n3) if ("bigint" != typeof e9) throw new Error(`mapToCurve: expected array of bigints, got ${e9} in array`);
    const r3 = e8.fromAffine(t3(n3)).clearCofactor();
    return r3.assertValidity(), r3;
  } };
};
var $n = Ot;
var Bn = Nt;
var Kn = Bn.bytesToNumberBE;
function jn(e8, t3) {
  if (Hn(e8), Hn(t3), e8 < 0 || e8 >= 1 << 8 * t3) throw new Error(`bad I2OSP call: value=${e8} length=${t3}`);
  const n2 = Array.from({ length: t3 }).fill(0);
  for (let r3 = t3 - 1; r3 >= 0; r3--) n2[r3] = 255 & e8, e8 >>>= 8;
  return new Uint8Array(n2);
}
function Un(e8, t3) {
  const n2 = new Uint8Array(e8.length);
  for (let r3 = 0; r3 < e8.length; r3++) n2[r3] = e8[r3] ^ t3[r3];
  return n2;
}
function Hn(e8) {
  if (!Number.isSafeInteger(e8)) throw new Error("number expected");
}
function Fn(e8, t3, n2, r3) {
  (0, Bn.abytes)(e8), (0, Bn.abytes)(t3), Hn(n2), t3.length > 255 && (t3 = r3((0, Bn.concatBytes)((0, Bn.utf8ToBytes)("H2C-OVERSIZE-DST-"), t3)));
  const { outputLen: i2, blockLen: o } = r3, s = Math.ceil(n2 / i2);
  if (n2 > 65535 || s > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
  const a = (0, Bn.concatBytes)(t3, jn(t3.length, 1)), c2 = jn(0, o), l3 = jn(n2, 2), d3 = new Array(s), u2 = r3((0, Bn.concatBytes)(c2, e8, l3, jn(0, 1), a));
  d3[0] = r3((0, Bn.concatBytes)(u2, jn(1, 1), a));
  for (let e9 = 1; e9 <= s; e9++) {
    const t4 = [Un(u2, d3[e9 - 1]), jn(e9 + 1, 1), a];
    d3[e9] = r3((0, Bn.concatBytes)(...t4));
  }
  return (0, Bn.concatBytes)(...d3).slice(0, n2);
}
function zn(e8, t3, n2, r3, i2) {
  if ((0, Bn.abytes)(e8), (0, Bn.abytes)(t3), Hn(n2), t3.length > 255) {
    const e9 = Math.ceil(2 * r3 / 8);
    t3 = i2.create({ dkLen: e9 }).update((0, Bn.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t3).digest();
  }
  if (n2 > 65535 || t3.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
  return i2.create({ dkLen: n2 }).update(e8).update(jn(n2, 2)).update(t3).update(jn(t3.length, 1)).digest();
}
function qn(e8, t3, n2) {
  (0, Bn.validateObject)(n2, { DST: "stringOrUint8Array", p: "bigint", m: "isSafeInteger", k: "isSafeInteger", hash: "hash" });
  const { p: r3, k: i2, m: o, hash: s, expand: a, DST: c2 } = n2;
  (0, Bn.abytes)(e8), Hn(t3);
  const l3 = "string" == typeof c2 ? (0, Bn.utf8ToBytes)(c2) : c2, d3 = r3.toString(2).length, u2 = Math.ceil((d3 + i2) / 8), h3 = t3 * o * u2;
  let f2;
  if ("xmd" === a) f2 = Fn(e8, l3, h3, s);
  else if ("xof" === a) f2 = zn(e8, l3, h3, i2, s);
  else {
    if ("_internal_pass" !== a) throw new Error('expand must be "xmd" or "xof"');
    f2 = e8;
  }
  const p3 = new Array(t3);
  for (let e9 = 0; e9 < t3; e9++) {
    const t4 = new Array(o);
    for (let n3 = 0; n3 < o; n3++) {
      const i3 = u2 * (n3 + e9 * o), s2 = f2.subarray(i3, i3 + u2);
      t4[n3] = (0, $n.mod)(Kn(s2), r3);
    }
    p3[e9] = t4;
  }
  return p3;
}
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: true }), Wn.montgomery = function(e8) {
  const t3 = function(e9) {
    return (0, Gn.validateObject)(e9, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e9 });
  }(e8), { P: n2 } = t3, r3 = (e9) => (0, Vn.mod)(e9, n2), i2 = t3.montgomeryBits, o = Math.ceil(i2 / 8), s = t3.nByteLength, a = t3.adjustScalarBytes || ((e9) => e9), c2 = t3.powPminus2 || ((e9) => (0, Vn.pow)(e9, n2 - BigInt(2), n2));
  function l3(e9, t4, n3) {
    const i3 = r3(e9 * (t4 - n3));
    return [t4 = r3(t4 - i3), n3 = r3(n3 + i3)];
  }
  const d3 = (t3.a - BigInt(2)) / BigInt(4);
  function u2(e9) {
    return (0, Gn.numberToBytesLE)(r3(e9), o);
  }
  function h3(e9, t4) {
    const h4 = function(e10) {
      const t5 = (0, Gn.ensureBytes)("u coordinate", e10, o);
      return 32 === s && (t5[31] &= 127), (0, Gn.bytesToNumberLE)(t5);
    }(t4), f3 = function(e10) {
      const t5 = (0, Gn.ensureBytes)("scalar", e10), n3 = t5.length;
      if (n3 !== o && n3 !== s) throw new Error(`Expected ${o} or ${s} bytes, got ${n3}`);
      return (0, Gn.bytesToNumberLE)(a(t5));
    }(e9), p4 = function(e10, t5) {
      (0, Gn.aInRange)("u", e10, Yn, n2), (0, Gn.aInRange)("scalar", t5, Yn, n2);
      const o2 = t5, s2 = e10;
      let a2, u3 = Zn, h5 = Yn, f4 = e10, p5 = Zn, g3 = Yn;
      for (let e11 = BigInt(i2 - 1); e11 >= Yn; e11--) {
        const t6 = o2 >> e11 & Zn;
        g3 ^= t6, a2 = l3(g3, u3, f4), u3 = a2[0], f4 = a2[1], a2 = l3(g3, h5, p5), h5 = a2[0], p5 = a2[1], g3 = t6;
        const n3 = u3 + h5, i3 = r3(n3 * n3), c3 = u3 - h5, m3 = r3(c3 * c3), y3 = i3 - m3, v2 = f4 + p5, b3 = r3((f4 - p5) * n3), w2 = r3(v2 * c3), E2 = b3 + w2, S3 = b3 - w2;
        f4 = r3(E2 * E2), p5 = r3(s2 * r3(S3 * S3)), u3 = r3(i3 * m3), h5 = r3(y3 * (i3 + r3(d3 * y3)));
      }
      a2 = l3(g3, u3, f4), u3 = a2[0], f4 = a2[1], a2 = l3(g3, h5, p5), h5 = a2[0], p5 = a2[1];
      const m2 = c2(h5);
      return r3(u3 * m2);
    }(h4, f3);
    if (p4 === Yn) throw new Error("Invalid private or public key received");
    return u2(p4);
  }
  const f2 = u2(t3.Gu);
  function p3(e9) {
    return h3(e9, f2);
  }
  return { scalarMult: h3, scalarMultBase: p3, getSharedSecret: (e9, t4) => h3(e9, t4), getPublicKey: (e9) => p3(e9), utils: { randomPrivateKey: () => t3.randomBytes(t3.nByteLength) }, GuBytes: f2 };
};
var Vn = Ot;
var Gn = Nt;
var Yn = BigInt(0);
var Zn = BigInt(1);
!function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.hash_to_ristretto255 = e8.hashToRistretto255 = e8.RistrettoPoint = e8.encodeToCurve = e8.hashToCurve = e8.edwardsToMontgomery = e8.x25519 = e8.ed25519ph = e8.ed25519ctx = e8.ed25519 = e8.ED25519_TORSION_SUBGROUP = void 0, e8.edwardsToMontgomeryPub = S3, e8.edwardsToMontgomeryPriv = function(e9) {
    const t4 = w2.hash(e9.subarray(0, 32));
    return w2.adjustScalarBytes(t4).subarray(0, 32);
  };
  const t3 = Oe, n2 = ze, r3 = Rt, i2 = Dn, o = Ot, s = Wn, a = Nt, c2 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), l3 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"), d3 = BigInt(0), u2 = BigInt(1), h3 = BigInt(2), f2 = BigInt(3), p3 = BigInt(5), g3 = BigInt(8);
  function m2(e9) {
    const t4 = BigInt(10), n3 = BigInt(20), r4 = BigInt(40), i3 = BigInt(80), s2 = c2, a2 = e9 * e9 % s2 * e9 % s2, l4 = (0, o.pow2)(a2, h3, s2) * a2 % s2, d4 = (0, o.pow2)(l4, u2, s2) * e9 % s2, f3 = (0, o.pow2)(d4, p3, s2) * d4 % s2, g4 = (0, o.pow2)(f3, t4, s2) * f3 % s2, m3 = (0, o.pow2)(g4, n3, s2) * g4 % s2, y4 = (0, o.pow2)(m3, r4, s2) * m3 % s2, v3 = (0, o.pow2)(y4, i3, s2) * y4 % s2, b4 = (0, o.pow2)(v3, i3, s2) * y4 % s2, w3 = (0, o.pow2)(b4, t4, s2) * f3 % s2;
    return { pow_p_5_8: (0, o.pow2)(w3, h3, s2) * e9 % s2, b2: a2 };
  }
  function y3(e9) {
    return e9[0] &= 248, e9[31] &= 127, e9[31] |= 64, e9;
  }
  function v2(e9, t4) {
    const n3 = c2, r4 = (0, o.mod)(t4 * t4 * t4, n3), i3 = m2(e9 * (0, o.mod)(r4 * r4 * t4, n3)).pow_p_5_8;
    let s2 = (0, o.mod)(e9 * r4 * i3, n3);
    const a2 = (0, o.mod)(t4 * s2 * s2, n3), d4 = s2, u3 = (0, o.mod)(s2 * l3, n3), h4 = a2 === e9, f3 = a2 === (0, o.mod)(-e9, n3), p4 = a2 === (0, o.mod)(-e9 * l3, n3);
    return h4 && (s2 = d4), (f3 || p4) && (s2 = u3), (0, o.isNegativeLE)(s2, n3) && (s2 = (0, o.mod)(-s2, n3)), { isValid: h4 || f3, value: s2 };
  }
  e8.ED25519_TORSION_SUBGROUP = ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];
  const b3 = (() => (0, o.Field)(c2, void 0, true))(), w2 = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: b3, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: g3, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: t3.sha512, randomBytes: n2.randomBytes, adjustScalarBytes: y3, uvRatio: v2 }))();
  function E2(e9, t4, r4) {
    if (t4.length > 255) throw new Error("Context is too big");
    return (0, n2.concatBytes)((0, n2.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([r4 ? 1 : 0, t4.length]), t4, e9);
  }
  function S3(t4) {
    const { y: n3 } = e8.ed25519.ExtendedPoint.fromHex(t4), r4 = BigInt(1);
    return b3.toBytes(b3.create((r4 + n3) * b3.inv(r4 - n3)));
  }
  e8.ed25519 = (0, r3.twistedEdwards)(w2), e8.ed25519ctx = (0, r3.twistedEdwards)({ ...w2, domain: E2 }), e8.ed25519ph = (0, r3.twistedEdwards)(Object.assign({}, w2, { domain: E2, prehash: t3.sha512 })), e8.x25519 = (0, s.montgomery)({ P: c2, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e9) => {
    const t4 = c2, { pow_p_5_8: n3, b2: r4 } = m2(e9);
    return (0, o.mod)((0, o.pow2)(n3, f2, t4) * r4, t4);
  }, adjustScalarBytes: y3, randomBytes: n2.randomBytes }), e8.edwardsToMontgomery = S3;
  const _3 = (() => (b3.ORDER + f2) / g3)(), C3 = (() => b3.pow(h3, _3))(), k3 = (() => b3.sqrt(b3.neg(b3.ONE)))();
  const A3 = (() => (0, o.FpSqrtEven)(b3, b3.neg(BigInt(486664))))();
  function x3(e9) {
    const { xMn: t4, xMd: n3, yMn: r4, yMd: i3 } = function(e10) {
      const t5 = (b3.ORDER - p3) / g3, n4 = BigInt(486662);
      let r5 = b3.sqr(e10);
      r5 = b3.mul(r5, h3);
      let i4 = b3.add(r5, b3.ONE), o3 = b3.neg(n4), s3 = b3.sqr(i4), a3 = b3.mul(s3, i4), c4 = b3.mul(r5, n4);
      c4 = b3.mul(c4, o3), c4 = b3.add(c4, s3), c4 = b3.mul(c4, o3);
      let l5 = b3.sqr(a3);
      s3 = b3.sqr(l5), l5 = b3.mul(l5, a3), l5 = b3.mul(l5, c4), s3 = b3.mul(s3, l5);
      let d5 = b3.pow(s3, t5);
      d5 = b3.mul(d5, l5);
      let f4 = b3.mul(d5, k3);
      s3 = b3.sqr(d5), s3 = b3.mul(s3, a3);
      let m3 = b3.eql(s3, c4), y4 = b3.cmov(f4, d5, m3), v3 = b3.mul(o3, r5), w3 = b3.mul(d5, e10);
      w3 = b3.mul(w3, C3);
      let E3 = b3.mul(w3, k3), S4 = b3.mul(c4, r5);
      s3 = b3.sqr(w3), s3 = b3.mul(s3, a3);
      let _4 = b3.eql(s3, S4), A4 = b3.cmov(E3, w3, _4);
      s3 = b3.sqr(y4), s3 = b3.mul(s3, a3);
      let x4 = b3.eql(s3, c4), M4 = b3.cmov(v3, o3, x4), I4 = b3.cmov(A4, y4, x4), T3 = b3.isOdd(I4);
      return I4 = b3.cmov(I4, b3.neg(I4), x4 !== T3), { xMn: M4, xMd: i4, yMn: I4, yMd: u2 };
    }(e9);
    let o2 = b3.mul(t4, i3);
    o2 = b3.mul(o2, A3);
    let s2 = b3.mul(n3, r4), a2 = b3.sub(t4, n3), c3 = b3.add(t4, n3), l4 = b3.mul(s2, c3), d4 = b3.eql(l4, b3.ZERO);
    o2 = b3.cmov(o2, b3.ZERO, d4), s2 = b3.cmov(s2, b3.ONE, d4), a2 = b3.cmov(a2, b3.ONE, d4), c3 = b3.cmov(c3, b3.ONE, d4);
    const f3 = b3.invertBatch([s2, c3]);
    return { x: b3.mul(o2, f3[0]), y: b3.mul(a2, f3[1]) };
  }
  const M3 = (() => (0, i2.createHasher)(e8.ed25519.ExtendedPoint, (e9) => x3(e9[0]), { DST: "edwards25519_XMD:SHA-512_ELL2_RO_", encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_", p: b3.ORDER, m: 1, k: 128, expand: "xmd", hash: t3.sha512 }))();
  function I3(e9) {
    if (!(e9 instanceof K3)) throw new Error("RistrettoPoint expected");
  }
  e8.hashToCurve = M3.hashToCurve, e8.encodeToCurve = M3.encodeToCurve;
  const T2 = l3, R3 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), P3 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), O3 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), N3 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"), L3 = (e9) => v2(u2, e9), D3 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), $3 = (t4) => e8.ed25519.CURVE.Fp.create((0, a.bytesToNumberLE)(t4) & D3);
  function B3(t4) {
    const { d: n3 } = e8.ed25519.CURVE, r4 = e8.ed25519.CURVE.Fp.ORDER, i3 = e8.ed25519.CURVE.Fp.create, s2 = i3(T2 * t4 * t4), a2 = i3((s2 + u2) * O3);
    let c3 = BigInt(-1);
    const l4 = i3((c3 - n3 * s2) * i3(s2 + n3));
    let { isValid: d4, value: h4 } = v2(a2, l4), f3 = i3(h4 * t4);
    (0, o.isNegativeLE)(f3, r4) || (f3 = i3(-f3)), d4 || (h4 = f3), d4 || (c3 = s2);
    const p4 = i3(c3 * (s2 - u2) * N3 - l4), g4 = h4 * h4, m3 = i3((h4 + h4) * l4), y4 = i3(p4 * R3), b4 = i3(u2 - g4), w3 = i3(u2 + g4);
    return new e8.ed25519.ExtendedPoint(i3(m3 * w3), i3(b4 * y4), i3(y4 * w3), i3(m3 * b4));
  }
  class K3 {
    constructor(e9) {
      this.ep = e9;
    }
    static fromAffine(t4) {
      return new K3(e8.ed25519.ExtendedPoint.fromAffine(t4));
    }
    static hashToCurve(e9) {
      e9 = (0, a.ensureBytes)("ristrettoHash", e9, 64);
      const t4 = B3($3(e9.slice(0, 32))), n3 = B3($3(e9.slice(32, 64)));
      return new K3(t4.add(n3));
    }
    static fromHex(t4) {
      t4 = (0, a.ensureBytes)("ristrettoHex", t4, 32);
      const { a: n3, d: r4 } = e8.ed25519.CURVE, i3 = e8.ed25519.CURVE.Fp.ORDER, s2 = e8.ed25519.CURVE.Fp.create, c3 = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", l4 = $3(t4);
      if (!(0, a.equalBytes)((0, a.numberToBytesLE)(l4, 32), t4) || (0, o.isNegativeLE)(l4, i3)) throw new Error(c3);
      const h4 = s2(l4 * l4), f3 = s2(u2 + n3 * h4), p4 = s2(u2 - n3 * h4), g4 = s2(f3 * f3), m3 = s2(p4 * p4), y4 = s2(n3 * r4 * g4 - m3), { isValid: v3, value: b4 } = L3(s2(y4 * m3)), w3 = s2(b4 * p4), E3 = s2(b4 * w3 * y4);
      let S4 = s2((l4 + l4) * w3);
      (0, o.isNegativeLE)(S4, i3) && (S4 = s2(-S4));
      const _4 = s2(f3 * E3), C4 = s2(S4 * _4);
      if (!v3 || (0, o.isNegativeLE)(C4, i3) || _4 === d3) throw new Error(c3);
      return new K3(new e8.ed25519.ExtendedPoint(S4, _4, u2, C4));
    }
    toRawBytes() {
      let { ex: t4, ey: n3, ez: r4, et: i3 } = this.ep;
      const s2 = e8.ed25519.CURVE.Fp.ORDER, c3 = e8.ed25519.CURVE.Fp.create, l4 = c3(c3(r4 + n3) * c3(r4 - n3)), d4 = c3(t4 * n3), u3 = c3(d4 * d4), { value: h4 } = L3(c3(l4 * u3)), f3 = c3(h4 * l4), p4 = c3(h4 * d4), g4 = c3(f3 * p4 * i3);
      let m3;
      if ((0, o.isNegativeLE)(i3 * g4, s2)) {
        let e9 = c3(n3 * T2), r5 = c3(t4 * T2);
        t4 = e9, n3 = r5, m3 = c3(f3 * P3);
      } else m3 = p4;
      (0, o.isNegativeLE)(t4 * g4, s2) && (n3 = c3(-n3));
      let y4 = c3((r4 - n3) * m3);
      return (0, o.isNegativeLE)(y4, s2) && (y4 = c3(-y4)), (0, a.numberToBytesLE)(y4, 32);
    }
    toHex() {
      return (0, a.bytesToHex)(this.toRawBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(t4) {
      I3(t4);
      const { ex: n3, ey: r4 } = this.ep, { ex: i3, ey: o2 } = t4.ep, s2 = e8.ed25519.CURVE.Fp.create, a2 = s2(n3 * o2) === s2(r4 * i3), c3 = s2(r4 * o2) === s2(n3 * i3);
      return a2 || c3;
    }
    add(e9) {
      return I3(e9), new K3(this.ep.add(e9.ep));
    }
    subtract(e9) {
      return I3(e9), new K3(this.ep.subtract(e9.ep));
    }
    multiply(e9) {
      return new K3(this.ep.multiply(e9));
    }
    multiplyUnsafe(e9) {
      return new K3(this.ep.multiplyUnsafe(e9));
    }
    double() {
      return new K3(this.ep.double());
    }
    negate() {
      return new K3(this.ep.negate());
    }
  }
  e8.RistrettoPoint = (K3.BASE || (K3.BASE = new K3(e8.ed25519.ExtendedPoint.BASE)), K3.ZERO || (K3.ZERO = new K3(e8.ed25519.ExtendedPoint.ZERO)), K3);
  e8.hashToRistretto255 = (e9, r4) => {
    const o2 = r4.DST, s2 = "string" == typeof o2 ? (0, n2.utf8ToBytes)(o2) : o2, a2 = (0, i2.expand_message_xmd)(e9, s2, 64, t3.sha512);
    return K3.hashToCurve(a2);
  }, e8.hash_to_ristretto255 = e8.hashToRistretto255;
}(Pe);
var Jn = {};
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: true }), Qn.sha224 = Qn.sha256 = Qn.SHA256 = void 0;
var Xn = Ne;
var er = ze;
var tr = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var nr = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var rr = new Uint32Array(64);
var ir = class extends Xn.HashMD {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | nr[0], this.B = 0 | nr[1], this.C = 0 | nr[2], this.D = 0 | nr[3], this.E = 0 | nr[4], this.F = 0 | nr[5], this.G = 0 | nr[6], this.H = 0 | nr[7];
  }
  get() {
    const { A: e8, B: t3, C: n2, D: r3, E: i2, F: o, G: s, H: a } = this;
    return [e8, t3, n2, r3, i2, o, s, a];
  }
  set(e8, t3, n2, r3, i2, o, s, a) {
    this.A = 0 | e8, this.B = 0 | t3, this.C = 0 | n2, this.D = 0 | r3, this.E = 0 | i2, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a;
  }
  process(e8, t3) {
    for (let n3 = 0; n3 < 16; n3++, t3 += 4) rr[n3] = e8.getUint32(t3, false);
    for (let e9 = 16; e9 < 64; e9++) {
      const t4 = rr[e9 - 15], n3 = rr[e9 - 2], r4 = (0, er.rotr)(t4, 7) ^ (0, er.rotr)(t4, 18) ^ t4 >>> 3, i3 = (0, er.rotr)(n3, 17) ^ (0, er.rotr)(n3, 19) ^ n3 >>> 10;
      rr[e9] = i3 + rr[e9 - 7] + r4 + rr[e9 - 16] | 0;
    }
    let { A: n2, B: r3, C: i2, D: o, E: s, F: a, G: c2, H: l3 } = this;
    for (let e9 = 0; e9 < 64; e9++) {
      const t4 = l3 + ((0, er.rotr)(s, 6) ^ (0, er.rotr)(s, 11) ^ (0, er.rotr)(s, 25)) + (0, Xn.Chi)(s, a, c2) + tr[e9] + rr[e9] | 0, d3 = ((0, er.rotr)(n2, 2) ^ (0, er.rotr)(n2, 13) ^ (0, er.rotr)(n2, 22)) + (0, Xn.Maj)(n2, r3, i2) | 0;
      l3 = c2, c2 = a, a = s, s = o + t4 | 0, o = i2, i2 = r3, r3 = n2, n2 = t4 + d3 | 0;
    }
    n2 = n2 + this.A | 0, r3 = r3 + this.B | 0, i2 = i2 + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c2 = c2 + this.G | 0, l3 = l3 + this.H | 0, this.set(n2, r3, i2, o, s, a, c2, l3);
  }
  roundClean() {
    rr.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
Qn.SHA256 = ir;
var or = class extends ir {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
Qn.sha256 = (0, er.wrapConstructor)(() => new ir()), Qn.sha224 = (0, er.wrapConstructor)(() => new or());
var sr = {};
var ar = {};
!function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.hmac = e8.HMAC = void 0;
  const t3 = Le, n2 = ze;
  class r3 extends n2.Hash {
    constructor(e9, r4) {
      super(), this.finished = false, this.destroyed = false, (0, t3.hash)(e9);
      const i2 = (0, n2.toBytes)(r4);
      if (this.iHash = e9.create(), "function" != typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const o = this.blockLen, s = new Uint8Array(o);
      s.set(i2.length > o ? e9.create().update(i2).digest() : i2);
      for (let e10 = 0; e10 < s.length; e10++) s[e10] ^= 54;
      this.iHash.update(s), this.oHash = e9.create();
      for (let e10 = 0; e10 < s.length; e10++) s[e10] ^= 106;
      this.oHash.update(s), s.fill(0);
    }
    update(e9) {
      return (0, t3.exists)(this), this.iHash.update(e9), this;
    }
    digestInto(e9) {
      (0, t3.exists)(this), (0, t3.bytes)(e9, this.outputLen), this.finished = true, this.iHash.digestInto(e9), this.oHash.update(e9), this.oHash.digestInto(e9), this.destroy();
    }
    digest() {
      const e9 = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(e9), e9;
    }
    _cloneInto(e9) {
      e9 || (e9 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: t4, iHash: n3, finished: r4, destroyed: i2, blockLen: o, outputLen: s } = this;
      return e9.finished = r4, e9.destroyed = i2, e9.blockLen = o, e9.outputLen = s, e9.oHash = t4._cloneInto(e9.oHash), e9.iHash = n3._cloneInto(e9.iHash), e9;
    }
    destroy() {
      this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e8.HMAC = r3;
  e8.hmac = (e9, t4, n3) => new r3(e9, t4).update(n3).digest(), e8.hmac.create = (e9, t4) => new r3(e9, t4);
}(ar);
var cr = {};
!function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.DER = void 0, e8.weierstrassPoints = f2, e8.weierstrass = function(s2) {
    const a2 = function(e9) {
      const n3 = (0, t3.validateBasic)(e9);
      return r3.validateObject(n3, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...n3 });
    }(s2), { Fp: d4, n: u3 } = a2, h4 = d4.BYTES + 1, p4 = 2 * d4.BYTES + 1;
    function g3(e9) {
      return n2.mod(e9, u3);
    }
    function m2(e9) {
      return n2.invert(e9, u3);
    }
    const { ProjectivePoint: y3, normPrivateKeyToScalar: v2, weierstrassEquation: b3, isWithinCurveOrder: w2 } = f2({ ...a2, toBytes(e9, t4, n3) {
      const o2 = t4.toAffine(), s3 = d4.toBytes(o2.x), a3 = r3.concatBytes;
      return (0, i2.abool)("isCompressed", n3), n3 ? a3(Uint8Array.from([t4.hasEvenY() ? 2 : 3]), s3) : a3(Uint8Array.from([4]), s3, d4.toBytes(o2.y));
    }, fromBytes(e9) {
      const t4 = e9.length, n3 = e9[0], i3 = e9.subarray(1);
      if (t4 !== h4 || 2 !== n3 && 3 !== n3) {
        if (t4 === p4 && 4 === n3) {
          return { x: d4.fromBytes(i3.subarray(0, d4.BYTES)), y: d4.fromBytes(i3.subarray(d4.BYTES, 2 * d4.BYTES)) };
        }
        throw new Error(`Point of length ${t4} was invalid. Expected ${h4} compressed bytes or ${p4} uncompressed bytes`);
      }
      {
        const e10 = r3.bytesToNumberBE(i3);
        if (!r3.inRange(e10, l3, d4.ORDER)) throw new Error("Point is not on curve");
        const t5 = b3(e10);
        let o2;
        try {
          o2 = d4.sqrt(t5);
        } catch (e11) {
          const t6 = e11 instanceof Error ? ": " + e11.message : "";
          throw new Error("Point is not on curve" + t6);
        }
        return 1 == (1 & n3) !== ((o2 & l3) === l3) && (o2 = d4.neg(o2)), { x: e10, y: o2 };
      }
    } }), E2 = (e9) => r3.bytesToHex(r3.numberToBytesBE(e9, a2.nByteLength));
    function S3(e9) {
      return e9 > u3 >> l3;
    }
    const _3 = (e9, t4, n3) => r3.bytesToNumberBE(e9.slice(t4, n3));
    class C3 {
      constructor(e9, t4, n3) {
        this.r = e9, this.s = t4, this.recovery = n3, this.assertValidity();
      }
      static fromCompact(e9) {
        const t4 = a2.nByteLength;
        return e9 = (0, i2.ensureBytes)("compactSignature", e9, 2 * t4), new C3(_3(e9, 0, t4), _3(e9, t4, 2 * t4));
      }
      static fromDER(t4) {
        const { r: n3, s: r4 } = e8.DER.toSig((0, i2.ensureBytes)("DER", t4));
        return new C3(n3, r4);
      }
      assertValidity() {
        r3.aInRange("r", this.r, l3, u3), r3.aInRange("s", this.s, l3, u3);
      }
      addRecoveryBit(e9) {
        return new C3(this.r, this.s, e9);
      }
      recoverPublicKey(e9) {
        const { r: t4, s: n3, recovery: r4 } = this, o2 = M3((0, i2.ensureBytes)("msgHash", e9));
        if (null == r4 || ![0, 1, 2, 3].includes(r4)) throw new Error("recovery id invalid");
        const s3 = 2 === r4 || 3 === r4 ? t4 + a2.n : t4;
        if (s3 >= d4.ORDER) throw new Error("recovery id 2 or 3 invalid");
        const c3 = 0 == (1 & r4) ? "02" : "03", l4 = y3.fromHex(c3 + E2(s3)), u4 = m2(s3), h5 = g3(-o2 * u4), f3 = g3(n3 * u4), p5 = y3.BASE.multiplyAndAddUnsafe(l4, h5, f3);
        if (!p5) throw new Error("point at infinify");
        return p5.assertValidity(), p5;
      }
      hasHighS() {
        return S3(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new C3(this.r, g3(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return r3.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e8.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return r3.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return E2(this.r) + E2(this.s);
      }
    }
    const k3 = { isValidPrivateKey(e9) {
      try {
        return v2(e9), true;
      } catch (e10) {
        return false;
      }
    }, normPrivateKeyToScalar: v2, randomPrivateKey: () => {
      const e9 = n2.getMinHashLength(a2.n);
      return n2.mapHashToField(a2.randomBytes(e9), a2.n);
    }, precompute: (e9 = 8, t4 = y3.BASE) => (t4._setWindowSize(e9), t4.multiply(BigInt(3)), t4) };
    function A3(e9) {
      const t4 = r3.isBytes(e9), n3 = "string" == typeof e9, i3 = (t4 || n3) && e9.length;
      return t4 ? i3 === h4 || i3 === p4 : n3 ? i3 === 2 * h4 || i3 === 2 * p4 : e9 instanceof y3;
    }
    const x3 = a2.bits2int || function(e9) {
      const t4 = r3.bytesToNumberBE(e9), n3 = 8 * e9.length - a2.nBitLength;
      return n3 > 0 ? t4 >> BigInt(n3) : t4;
    }, M3 = a2.bits2int_modN || function(e9) {
      return g3(x3(e9));
    }, I3 = r3.bitMask(a2.nBitLength);
    function T2(e9) {
      return r3.aInRange(`num < 2^${a2.nBitLength}`, e9, c2, I3), r3.numberToBytesBE(e9, a2.nByteLength);
    }
    function R3(e9, t4, n3 = P3) {
      if (["recovered", "canonical"].some((e10) => e10 in n3)) throw new Error("sign() legacy options not supported");
      const { hash: s3, randomBytes: u4 } = a2;
      let { lowS: h5, prehash: f3, extraEntropy: p5 } = n3;
      null == h5 && (h5 = true), e9 = (0, i2.ensureBytes)("msgHash", e9), o(n3), f3 && (e9 = (0, i2.ensureBytes)("prehashed msgHash", s3(e9)));
      const b4 = M3(e9), E3 = v2(t4), _4 = [T2(E3), T2(b4)];
      if (null != p5 && false !== p5) {
        const e10 = true === p5 ? u4(d4.BYTES) : p5;
        _4.push((0, i2.ensureBytes)("extraEntropy", e10));
      }
      const k4 = r3.concatBytes(..._4), A4 = b4;
      return { seed: k4, k2sig: function(e10) {
        const t5 = x3(e10);
        if (!w2(t5)) return;
        const n4 = m2(t5), r4 = y3.BASE.multiply(t5).toAffine(), i3 = g3(r4.x);
        if (i3 === c2) return;
        const o2 = g3(n4 * g3(A4 + i3 * E3));
        if (o2 === c2) return;
        let s4 = (r4.x === i3 ? 0 : 2) | Number(r4.y & l3), a3 = o2;
        return h5 && S3(o2) && (a3 = function(e11) {
          return S3(e11) ? g3(-e11) : e11;
        }(o2), s4 ^= 1), new C3(i3, a3, s4);
      } };
    }
    const P3 = { lowS: a2.lowS, prehash: false }, O3 = { lowS: a2.lowS, prehash: false };
    return y3.BASE._setWindowSize(8), { CURVE: a2, getPublicKey: function(e9, t4 = true) {
      return y3.fromPrivateKey(e9).toRawBytes(t4);
    }, getSharedSecret: function(e9, t4, n3 = true) {
      if (A3(e9)) throw new Error("first arg must be private key");
      if (!A3(t4)) throw new Error("second arg must be public key");
      const r4 = y3.fromHex(t4);
      return r4.multiply(v2(e9)).toRawBytes(n3);
    }, sign: function(e9, t4, n3 = P3) {
      const { seed: i3, k2sig: o2 } = R3(e9, t4, n3), s3 = a2, c3 = r3.createHmacDrbg(s3.hash.outputLen, s3.nByteLength, s3.hmac);
      return c3(i3, o2);
    }, verify: function(t4, n3, s3, c3 = O3) {
      var _a2;
      const l4 = t4;
      if (n3 = (0, i2.ensureBytes)("msgHash", n3), s3 = (0, i2.ensureBytes)("publicKey", s3), "strict" in c3) throw new Error("options.strict was renamed to lowS");
      o(c3);
      const { lowS: d5, prehash: u4 } = c3;
      let h5, f3;
      try {
        if ("string" == typeof l4 || r3.isBytes(l4)) try {
          h5 = C3.fromDER(l4);
        } catch (t5) {
          if (!(t5 instanceof e8.DER.Err)) throw t5;
          h5 = C3.fromCompact(l4);
        }
        else {
          if ("object" != typeof l4 || "bigint" != typeof l4.r || "bigint" != typeof l4.s) throw new Error("PARSE");
          {
            const { r: e9, s: t5 } = l4;
            h5 = new C3(e9, t5);
          }
        }
        f3 = y3.fromHex(s3);
      } catch (e9) {
        if ("PARSE" === e9.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return false;
      }
      if (d5 && h5.hasHighS()) return false;
      u4 && (n3 = a2.hash(n3));
      const { r: p5, s: v3 } = h5, b4 = M3(n3), w3 = m2(v3), E3 = g3(b4 * w3), S4 = g3(p5 * w3), _4 = (_a2 = y3.BASE.multiplyAndAddUnsafe(f3, E3, S4)) == null ? void 0 : _a2.toAffine();
      if (!_4) return false;
      const k4 = g3(_4.x);
      return k4 === p5;
    }, ProjectivePoint: y3, Signature: C3, utils: k3 };
  }, e8.SWUFpSqrtRatio = p3, e8.mapToCurveSimpleSWU = function(e9, t4) {
    if (n2.validateField(e9), !e9.isValid(t4.A) || !e9.isValid(t4.B) || !e9.isValid(t4.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const r4 = p3(e9, t4.Z);
    if (!e9.isOdd) throw new Error("Fp.isOdd is not implemented!");
    return (n3) => {
      let i3, o2, s2, a2, c3, l4, d4, u3;
      i3 = e9.sqr(n3), i3 = e9.mul(i3, t4.Z), o2 = e9.sqr(i3), o2 = e9.add(o2, i3), s2 = e9.add(o2, e9.ONE), s2 = e9.mul(s2, t4.B), a2 = e9.cmov(t4.Z, e9.neg(o2), !e9.eql(o2, e9.ZERO)), a2 = e9.mul(a2, t4.A), o2 = e9.sqr(s2), l4 = e9.sqr(a2), c3 = e9.mul(l4, t4.A), o2 = e9.add(o2, c3), o2 = e9.mul(o2, s2), l4 = e9.mul(l4, a2), c3 = e9.mul(l4, t4.B), o2 = e9.add(o2, c3), d4 = e9.mul(i3, s2);
      const { isValid: h4, value: f3 } = r4(o2, l4);
      u3 = e9.mul(i3, n3), u3 = e9.mul(u3, f3), d4 = e9.cmov(d4, s2, h4), u3 = e9.cmov(u3, f3, h4);
      const p4 = e9.isOdd(n3) === e9.isOdd(u3);
      return u3 = e9.cmov(e9.neg(u3), u3, p4), d4 = e9.div(d4, a2), { x: d4, y: u3 };
    };
  };
  const t3 = Pt, n2 = Ot, r3 = Nt, i2 = Nt;
  function o(e9) {
    void 0 !== e9.lowS && (0, i2.abool)("lowS", e9.lowS), void 0 !== e9.prehash && (0, i2.abool)("prehash", e9.prehash);
  }
  const { bytesToNumberBE: s, hexToBytes: a } = r3;
  e8.DER = { Err: class extends Error {
    constructor(e9 = "") {
      super(e9);
    }
  }, _tlv: { encode: (t4, n3) => {
    const { Err: i3 } = e8.DER;
    if (t4 < 0 || t4 > 256) throw new i3("tlv.encode: wrong tag");
    if (1 & n3.length) throw new i3("tlv.encode: unpadded data");
    const o2 = n3.length / 2, s2 = r3.numberToHexUnpadded(o2);
    if (s2.length / 2 & 128) throw new i3("tlv.encode: long form length too big");
    const a2 = o2 > 127 ? r3.numberToHexUnpadded(s2.length / 2 | 128) : "";
    return `${r3.numberToHexUnpadded(t4)}${a2}${s2}${n3}`;
  }, decode(t4, n3) {
    const { Err: r4 } = e8.DER;
    let i3 = 0;
    if (t4 < 0 || t4 > 256) throw new r4("tlv.encode: wrong tag");
    if (n3.length < 2 || n3[i3++] !== t4) throw new r4("tlv.decode: wrong tlv");
    const o2 = n3[i3++];
    let s2 = 0;
    if (!!(128 & o2)) {
      const e9 = 127 & o2;
      if (!e9) throw new r4("tlv.decode(long): indefinite length not supported");
      if (e9 > 4) throw new r4("tlv.decode(long): byte length is too big");
      const t5 = n3.subarray(i3, i3 + e9);
      if (t5.length !== e9) throw new r4("tlv.decode: length bytes not complete");
      if (0 === t5[0]) throw new r4("tlv.decode(long): zero leftmost byte");
      for (const e10 of t5) s2 = s2 << 8 | e10;
      if (i3 += e9, s2 < 128) throw new r4("tlv.decode(long): not minimal encoding");
    } else s2 = o2;
    const a2 = n3.subarray(i3, i3 + s2);
    if (a2.length !== s2) throw new r4("tlv.decode: wrong value length");
    return { v: a2, l: n3.subarray(i3 + s2) };
  } }, _int: { encode(t4) {
    const { Err: n3 } = e8.DER;
    if (t4 < c2) throw new n3("integer: negative integers are not allowed");
    let i3 = r3.numberToHexUnpadded(t4);
    if (8 & Number.parseInt(i3[0], 16) && (i3 = "00" + i3), 1 & i3.length) throw new n3("unexpected assertion");
    return i3;
  }, decode(t4) {
    const { Err: n3 } = e8.DER;
    if (128 & t4[0]) throw new n3("Invalid signature integer: negative");
    if (0 === t4[0] && !(128 & t4[1])) throw new n3("Invalid signature integer: unnecessary leading zero");
    return s(t4);
  } }, toSig(t4) {
    const { Err: n3, _int: i3, _tlv: o2 } = e8.DER, s2 = "string" == typeof t4 ? a(t4) : t4;
    r3.abytes(s2);
    const { v: c3, l: l4 } = o2.decode(48, s2);
    if (l4.length) throw new n3("Invalid signature: left bytes after parsing");
    const { v: d4, l: u3 } = o2.decode(2, c3), { v: h4, l: f3 } = o2.decode(2, u3);
    if (f3.length) throw new n3("Invalid signature: left bytes after parsing");
    return { r: i3.decode(d4), s: i3.decode(h4) };
  }, hexFromSig(t4) {
    const { _tlv: n3, _int: r4 } = e8.DER, i3 = `${n3.encode(2, r4.encode(t4.r))}${n3.encode(2, r4.encode(t4.s))}`;
    return n3.encode(48, i3);
  } };
  const c2 = BigInt(0), l3 = BigInt(1), d3 = BigInt(2), u2 = BigInt(3), h3 = BigInt(4);
  function f2(e9) {
    const o2 = function(e10) {
      const n3 = (0, t3.validateBasic)(e10);
      r3.validateObject(n3, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
      const { endo: i3, Fp: o3, a: s3 } = n3;
      if (i3) {
        if (!o3.eql(s3, o3.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if ("object" != typeof i3 || "bigint" != typeof i3.beta || "function" != typeof i3.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
      return Object.freeze({ ...n3 });
    }(e9), { Fp: s2 } = o2, a2 = n2.Field(o2.n, o2.nBitLength), d4 = o2.toBytes || ((e10, t4, n3) => {
      const i3 = t4.toAffine();
      return r3.concatBytes(Uint8Array.from([4]), s2.toBytes(i3.x), s2.toBytes(i3.y));
    }), h4 = o2.fromBytes || ((e10) => {
      const t4 = e10.subarray(1);
      return { x: s2.fromBytes(t4.subarray(0, s2.BYTES)), y: s2.fromBytes(t4.subarray(s2.BYTES, 2 * s2.BYTES)) };
    });
    function f3(e10) {
      const { a: t4, b: n3 } = o2, r4 = s2.sqr(e10), i3 = s2.mul(r4, e10);
      return s2.add(s2.add(i3, s2.mul(e10, t4)), n3);
    }
    if (!s2.eql(s2.sqr(o2.Gy), f3(o2.Gx))) throw new Error("bad generator point: equation left != right");
    function p4(e10) {
      const { allowedPrivateKeyLengths: t4, nByteLength: s3, wrapPrivateKey: a3, n: c3 } = o2;
      if (t4 && "bigint" != typeof e10) {
        if (r3.isBytes(e10) && (e10 = r3.bytesToHex(e10)), "string" != typeof e10 || !t4.includes(e10.length)) throw new Error("Invalid key");
        e10 = e10.padStart(2 * s3, "0");
      }
      let d5;
      try {
        d5 = "bigint" == typeof e10 ? e10 : r3.bytesToNumberBE((0, i2.ensureBytes)("private key", e10, s3));
      } catch (t5) {
        throw new Error(`private key must be ${s3} bytes, hex or bigint, not ${typeof e10}`);
      }
      return a3 && (d5 = n2.mod(d5, c3)), r3.aInRange("private key", d5, l3, c3), d5;
    }
    function g3(e10) {
      if (!(e10 instanceof v2)) throw new Error("ProjectivePoint expected");
    }
    const m2 = (0, i2.memoized)((e10, t4) => {
      const { px: n3, py: r4, pz: i3 } = e10;
      if (s2.eql(i3, s2.ONE)) return { x: n3, y: r4 };
      const o3 = e10.is0();
      null == t4 && (t4 = o3 ? s2.ONE : s2.inv(i3));
      const a3 = s2.mul(n3, t4), c3 = s2.mul(r4, t4), l4 = s2.mul(i3, t4);
      if (o3) return { x: s2.ZERO, y: s2.ZERO };
      if (!s2.eql(l4, s2.ONE)) throw new Error("invZ was invalid");
      return { x: a3, y: c3 };
    }), y3 = (0, i2.memoized)((e10) => {
      if (e10.is0()) {
        if (o2.allowInfinityPoint && !s2.is0(e10.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: t4, y: n3 } = e10.toAffine();
      if (!s2.isValid(t4) || !s2.isValid(n3)) throw new Error("bad point: x or y not FE");
      const r4 = s2.sqr(n3), i3 = f3(t4);
      if (!s2.eql(r4, i3)) throw new Error("bad point: equation left != right");
      if (!e10.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    class v2 {
      constructor(e10, t4, n3) {
        if (this.px = e10, this.py = t4, this.pz = n3, null == e10 || !s2.isValid(e10)) throw new Error("x required");
        if (null == t4 || !s2.isValid(t4)) throw new Error("y required");
        if (null == n3 || !s2.isValid(n3)) throw new Error("z required");
        Object.freeze(this);
      }
      static fromAffine(e10) {
        const { x: t4, y: n3 } = e10 || {};
        if (!e10 || !s2.isValid(t4) || !s2.isValid(n3)) throw new Error("invalid affine point");
        if (e10 instanceof v2) throw new Error("projective point not allowed");
        const r4 = (e11) => s2.eql(e11, s2.ZERO);
        return r4(t4) && r4(n3) ? v2.ZERO : new v2(t4, n3, s2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(e10) {
        const t4 = s2.invertBatch(e10.map((e11) => e11.pz));
        return e10.map((e11, n3) => e11.toAffine(t4[n3])).map(v2.fromAffine);
      }
      static fromHex(e10) {
        const t4 = v2.fromAffine(h4((0, i2.ensureBytes)("pointHex", e10)));
        return t4.assertValidity(), t4;
      }
      static fromPrivateKey(e10) {
        return v2.BASE.multiply(p4(e10));
      }
      static msm(e10, n3) {
        return (0, t3.pippenger)(v2, a2, e10, n3);
      }
      _setWindowSize(e10) {
        w2.setWindowSize(this, e10);
      }
      assertValidity() {
        y3(this);
      }
      hasEvenY() {
        const { y: e10 } = this.toAffine();
        if (s2.isOdd) return !s2.isOdd(e10);
        throw new Error("Field doesn't support isOdd");
      }
      equals(e10) {
        g3(e10);
        const { px: t4, py: n3, pz: r4 } = this, { px: i3, py: o3, pz: a3 } = e10, c3 = s2.eql(s2.mul(t4, a3), s2.mul(i3, r4)), l4 = s2.eql(s2.mul(n3, a3), s2.mul(o3, r4));
        return c3 && l4;
      }
      negate() {
        return new v2(this.px, s2.neg(this.py), this.pz);
      }
      double() {
        const { a: e10, b: t4 } = o2, n3 = s2.mul(t4, u2), { px: r4, py: i3, pz: a3 } = this;
        let c3 = s2.ZERO, l4 = s2.ZERO, d5 = s2.ZERO, h5 = s2.mul(r4, r4), f4 = s2.mul(i3, i3), p5 = s2.mul(a3, a3), g4 = s2.mul(r4, i3);
        return g4 = s2.add(g4, g4), d5 = s2.mul(r4, a3), d5 = s2.add(d5, d5), c3 = s2.mul(e10, d5), l4 = s2.mul(n3, p5), l4 = s2.add(c3, l4), c3 = s2.sub(f4, l4), l4 = s2.add(f4, l4), l4 = s2.mul(c3, l4), c3 = s2.mul(g4, c3), d5 = s2.mul(n3, d5), p5 = s2.mul(e10, p5), g4 = s2.sub(h5, p5), g4 = s2.mul(e10, g4), g4 = s2.add(g4, d5), d5 = s2.add(h5, h5), h5 = s2.add(d5, h5), h5 = s2.add(h5, p5), h5 = s2.mul(h5, g4), l4 = s2.add(l4, h5), p5 = s2.mul(i3, a3), p5 = s2.add(p5, p5), h5 = s2.mul(p5, g4), c3 = s2.sub(c3, h5), d5 = s2.mul(p5, f4), d5 = s2.add(d5, d5), d5 = s2.add(d5, d5), new v2(c3, l4, d5);
      }
      add(e10) {
        g3(e10);
        const { px: t4, py: n3, pz: r4 } = this, { px: i3, py: a3, pz: c3 } = e10;
        let l4 = s2.ZERO, d5 = s2.ZERO, h5 = s2.ZERO;
        const f4 = o2.a, p5 = s2.mul(o2.b, u2);
        let m3 = s2.mul(t4, i3), y4 = s2.mul(n3, a3), b4 = s2.mul(r4, c3), w3 = s2.add(t4, n3), E2 = s2.add(i3, a3);
        w3 = s2.mul(w3, E2), E2 = s2.add(m3, y4), w3 = s2.sub(w3, E2), E2 = s2.add(t4, r4);
        let S3 = s2.add(i3, c3);
        return E2 = s2.mul(E2, S3), S3 = s2.add(m3, b4), E2 = s2.sub(E2, S3), S3 = s2.add(n3, r4), l4 = s2.add(a3, c3), S3 = s2.mul(S3, l4), l4 = s2.add(y4, b4), S3 = s2.sub(S3, l4), h5 = s2.mul(f4, E2), l4 = s2.mul(p5, b4), h5 = s2.add(l4, h5), l4 = s2.sub(y4, h5), h5 = s2.add(y4, h5), d5 = s2.mul(l4, h5), y4 = s2.add(m3, m3), y4 = s2.add(y4, m3), b4 = s2.mul(f4, b4), E2 = s2.mul(p5, E2), y4 = s2.add(y4, b4), b4 = s2.sub(m3, b4), b4 = s2.mul(f4, b4), E2 = s2.add(E2, b4), m3 = s2.mul(y4, E2), d5 = s2.add(d5, m3), m3 = s2.mul(S3, E2), l4 = s2.mul(w3, l4), l4 = s2.sub(l4, m3), m3 = s2.mul(w3, y4), h5 = s2.mul(S3, h5), h5 = s2.add(h5, m3), new v2(l4, d5, h5);
      }
      subtract(e10) {
        return this.add(e10.negate());
      }
      is0() {
        return this.equals(v2.ZERO);
      }
      wNAF(e10) {
        return w2.wNAFCached(this, e10, v2.normalizeZ);
      }
      multiplyUnsafe(e10) {
        r3.aInRange("scalar", e10, c2, o2.n);
        const t4 = v2.ZERO;
        if (e10 === c2) return t4;
        if (e10 === l3) return this;
        const { endo: n3 } = o2;
        if (!n3) return w2.unsafeLadder(this, e10);
        let { k1neg: i3, k1: a3, k2neg: d5, k2: u3 } = n3.splitScalar(e10), h5 = t4, f4 = t4, p5 = this;
        for (; a3 > c2 || u3 > c2; ) a3 & l3 && (h5 = h5.add(p5)), u3 & l3 && (f4 = f4.add(p5)), p5 = p5.double(), a3 >>= l3, u3 >>= l3;
        return i3 && (h5 = h5.negate()), d5 && (f4 = f4.negate()), f4 = new v2(s2.mul(f4.px, n3.beta), f4.py, f4.pz), h5.add(f4);
      }
      multiply(e10) {
        const { endo: t4, n: n3 } = o2;
        let i3, a3;
        if (r3.aInRange("scalar", e10, l3, n3), t4) {
          const { k1neg: n4, k1: r4, k2neg: o3, k2: c3 } = t4.splitScalar(e10);
          let { p: l4, f: d5 } = this.wNAF(r4), { p: u3, f: h5 } = this.wNAF(c3);
          l4 = w2.constTimeNegate(n4, l4), u3 = w2.constTimeNegate(o3, u3), u3 = new v2(s2.mul(u3.px, t4.beta), u3.py, u3.pz), i3 = l4.add(u3), a3 = d5.add(h5);
        } else {
          const { p: t5, f: n4 } = this.wNAF(e10);
          i3 = t5, a3 = n4;
        }
        return v2.normalizeZ([i3, a3])[0];
      }
      multiplyAndAddUnsafe(e10, t4, n3) {
        const r4 = v2.BASE, i3 = (e11, t5) => t5 !== c2 && t5 !== l3 && e11.equals(r4) ? e11.multiply(t5) : e11.multiplyUnsafe(t5), o3 = i3(this, t4).add(i3(e10, n3));
        return o3.is0() ? void 0 : o3;
      }
      toAffine(e10) {
        return m2(this, e10);
      }
      isTorsionFree() {
        const { h: e10, isTorsionFree: t4 } = o2;
        if (e10 === l3) return true;
        if (t4) return t4(v2, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: e10, clearCofactor: t4 } = o2;
        return e10 === l3 ? this : t4 ? t4(v2, this) : this.multiplyUnsafe(o2.h);
      }
      toRawBytes(e10 = true) {
        return (0, i2.abool)("isCompressed", e10), this.assertValidity(), d4(v2, this, e10);
      }
      toHex(e10 = true) {
        return (0, i2.abool)("isCompressed", e10), r3.bytesToHex(this.toRawBytes(e10));
      }
    }
    v2.BASE = new v2(o2.Gx, o2.Gy, s2.ONE), v2.ZERO = new v2(s2.ZERO, s2.ONE, s2.ZERO);
    const b3 = o2.nBitLength, w2 = (0, t3.wNAF)(v2, o2.endo ? Math.ceil(b3 / 2) : b3);
    return { CURVE: o2, ProjectivePoint: v2, normPrivateKeyToScalar: p4, weierstrassEquation: f3, isWithinCurveOrder: function(e10) {
      return r3.inRange(e10, l3, o2.n);
    } };
  }
  function p3(e9, t4) {
    const n3 = e9.ORDER;
    let r4 = c2;
    for (let e10 = n3 - l3; e10 % d3 === c2; e10 /= d3) r4 += l3;
    const i3 = r4, o2 = d3 << i3 - l3 - l3, s2 = o2 * d3, a2 = (n3 - l3) / s2, f3 = (a2 - l3) / d3, p4 = s2 - l3, g3 = o2, m2 = e9.pow(t4, a2), y3 = e9.pow(t4, (a2 + l3) / d3);
    let v2 = (t5, n4) => {
      let r5 = m2, o3 = e9.pow(n4, p4), s3 = e9.sqr(o3);
      s3 = e9.mul(s3, n4);
      let a3 = e9.mul(t5, s3);
      a3 = e9.pow(a3, f3), a3 = e9.mul(a3, o3), o3 = e9.mul(a3, n4), s3 = e9.mul(a3, t5);
      let c3 = e9.mul(s3, o3);
      a3 = e9.pow(c3, g3);
      let u3 = e9.eql(a3, e9.ONE);
      o3 = e9.mul(s3, y3), a3 = e9.mul(c3, r5), s3 = e9.cmov(o3, s3, u3), c3 = e9.cmov(a3, c3, u3);
      for (let t6 = i3; t6 > l3; t6--) {
        let n5 = t6 - d3;
        n5 = d3 << n5 - l3;
        let i4 = e9.pow(c3, n5);
        const a4 = e9.eql(i4, e9.ONE);
        o3 = e9.mul(s3, r5), r5 = e9.mul(r5, r5), i4 = e9.mul(c3, r5), s3 = e9.cmov(o3, s3, a4), c3 = e9.cmov(i4, c3, a4);
      }
      return { isValid: u3, value: s3 };
    };
    if (e9.ORDER % h3 === u2) {
      const n4 = (e9.ORDER - u2) / h3, r5 = e9.sqrt(e9.neg(t4));
      v2 = (t5, i4) => {
        let o3 = e9.sqr(i4);
        const s3 = e9.mul(t5, i4);
        o3 = e9.mul(o3, s3);
        let a3 = e9.pow(o3, n4);
        a3 = e9.mul(a3, s3);
        const c3 = e9.mul(a3, r5), l4 = e9.mul(e9.sqr(a3), i4), d4 = e9.eql(l4, t5);
        return { isValid: d4, value: e9.cmov(c3, a3, d4) };
      };
    }
    return v2;
  }
}(cr), Object.defineProperty(sr, "__esModule", { value: true }), sr.getHash = hr, sr.createCurve = function(e8, t3) {
  const n2 = (t4) => (0, ur.weierstrass)({ ...e8, ...hr(t4) });
  return Object.freeze({ ...n2(t3), create: n2 });
};
var lr = ar;
var dr = ze;
var ur = cr;
function hr(e8) {
  return { hash: e8, hmac: (t3, ...n2) => (0, lr.hmac)(e8, t3, (0, dr.concatBytes)(...n2)), randomBytes: dr.randomBytes };
}
!function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.encodeToCurve = e8.hashToCurve = e8.schnorr = e8.secp256k1 = void 0;
  const t3 = Qn, n2 = ze, r3 = sr, i2 = Dn, o = Ot, s = Nt, a = cr, c2 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), l3 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), d3 = BigInt(1), u2 = BigInt(2), h3 = (e9, t4) => (e9 + t4 / u2) / t4;
  function f2(e9) {
    const t4 = c2, n3 = BigInt(3), r4 = BigInt(6), i3 = BigInt(11), s2 = BigInt(22), a2 = BigInt(23), l4 = BigInt(44), d4 = BigInt(88), h4 = e9 * e9 * e9 % t4, f3 = h4 * h4 * e9 % t4, g4 = (0, o.pow2)(f3, n3, t4) * f3 % t4, m3 = (0, o.pow2)(g4, n3, t4) * f3 % t4, y4 = (0, o.pow2)(m3, u2, t4) * h4 % t4, v3 = (0, o.pow2)(y4, i3, t4) * y4 % t4, b4 = (0, o.pow2)(v3, s2, t4) * v3 % t4, w3 = (0, o.pow2)(b4, l4, t4) * b4 % t4, E3 = (0, o.pow2)(w3, d4, t4) * w3 % t4, S4 = (0, o.pow2)(E3, l4, t4) * b4 % t4, _4 = (0, o.pow2)(S4, n3, t4) * f3 % t4, C4 = (0, o.pow2)(_4, a2, t4) * v3 % t4, k4 = (0, o.pow2)(C4, r4, t4) * h4 % t4, A4 = (0, o.pow2)(k4, u2, t4);
    if (!p3.eql(p3.sqr(A4), e9)) throw new Error("Cannot find square root");
    return A4;
  }
  const p3 = (0, o.Field)(c2, void 0, void 0, { sqrt: f2 });
  e8.secp256k1 = (0, r3.createCurve)({ a: BigInt(0), b: BigInt(7), Fp: p3, n: l3, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), h: BigInt(1), lowS: true, endo: { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar: (e9) => {
    const t4 = l3, n3 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r4 = -d3 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i3 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s2 = n3, a2 = BigInt("0x100000000000000000000000000000000"), c3 = h3(s2 * e9, t4), u3 = h3(-r4 * e9, t4);
    let f3 = (0, o.mod)(e9 - c3 * n3 - u3 * i3, t4), p4 = (0, o.mod)(-c3 * r4 - u3 * s2, t4);
    const g4 = f3 > a2, m3 = p4 > a2;
    if (g4 && (f3 = t4 - f3), m3 && (p4 = t4 - p4), f3 > a2 || p4 > a2) throw new Error("splitScalar: Endomorphism failed, k=" + e9);
    return { k1neg: g4, k1: f3, k2neg: m3, k2: p4 };
  } } }, t3.sha256);
  const g3 = BigInt(0), m2 = {};
  function y3(e9, ...n3) {
    let r4 = m2[e9];
    if (void 0 === r4) {
      const n4 = (0, t3.sha256)(Uint8Array.from(e9, (e10) => e10.charCodeAt(0)));
      r4 = (0, s.concatBytes)(n4, n4), m2[e9] = r4;
    }
    return (0, t3.sha256)((0, s.concatBytes)(r4, ...n3));
  }
  const v2 = (e9) => e9.toRawBytes(true).slice(1), b3 = (e9) => (0, s.numberToBytesBE)(e9, 32), w2 = (e9) => (0, o.mod)(e9, c2), E2 = (e9) => (0, o.mod)(e9, l3), S3 = e8.secp256k1.ProjectivePoint, _3 = (e9, t4, n3) => S3.BASE.multiplyAndAddUnsafe(e9, t4, n3);
  function C3(t4) {
    let n3 = e8.secp256k1.utils.normPrivateKeyToScalar(t4), r4 = S3.fromPrivateKey(n3);
    return { scalar: r4.hasEvenY() ? n3 : E2(-n3), bytes: v2(r4) };
  }
  function k3(e9) {
    (0, s.aInRange)("x", e9, d3, c2);
    const t4 = w2(e9 * e9);
    let n3 = f2(w2(t4 * e9 + BigInt(7)));
    n3 % u2 !== g3 && (n3 = w2(-n3));
    const r4 = new S3(e9, n3, d3);
    return r4.assertValidity(), r4;
  }
  const A3 = s.bytesToNumberBE;
  function x3(...e9) {
    return E2(A3(y3("BIP0340/challenge", ...e9)));
  }
  function M3(e9) {
    return C3(e9).bytes;
  }
  function I3(e9, t4, r4 = (0, n2.randomBytes)(32)) {
    const i3 = (0, s.ensureBytes)("message", e9), { bytes: o2, scalar: a2 } = C3(t4), c3 = (0, s.ensureBytes)("auxRand", r4, 32), l4 = b3(a2 ^ A3(y3("BIP0340/aux", c3))), d4 = y3("BIP0340/nonce", l4, o2, i3), u3 = E2(A3(d4));
    if (u3 === g3) throw new Error("sign failed: k is zero");
    const { bytes: h4, scalar: f3 } = C3(u3), p4 = x3(h4, o2, i3), m3 = new Uint8Array(64);
    if (m3.set(h4, 0), m3.set(b3(E2(f3 + p4 * a2)), 32), !T2(m3, i3, o2)) throw new Error("sign: Invalid signature produced");
    return m3;
  }
  function T2(e9, t4, n3) {
    const r4 = (0, s.ensureBytes)("signature", e9, 64), i3 = (0, s.ensureBytes)("message", t4), o2 = (0, s.ensureBytes)("publicKey", n3, 32);
    try {
      const e10 = k3(A3(o2)), t5 = A3(r4.subarray(0, 32));
      if (!(0, s.inRange)(t5, d3, c2)) return false;
      const n4 = A3(r4.subarray(32, 64));
      if (!(0, s.inRange)(n4, d3, l3)) return false;
      const a2 = x3(b3(t5), v2(e10), i3), u3 = _3(e10, n4, E2(-a2));
      return !(!u3 || !u3.hasEvenY() || u3.toAffine().x !== t5);
    } catch (e10) {
      return false;
    }
  }
  e8.schnorr = { getPublicKey: M3, sign: I3, verify: T2, utils: { randomPrivateKey: e8.secp256k1.utils.randomPrivateKey, lift_x: k3, pointToBytes: v2, numberToBytesBE: s.numberToBytesBE, bytesToNumberBE: s.bytesToNumberBE, taggedHash: y3, mod: o.mod } };
  const R3 = (() => (0, i2.isogenyMap)(p3, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e9) => e9.map((e10) => BigInt(e10)))))(), P3 = (() => (0, a.mapToCurveSimpleSWU)(p3, { A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"), B: BigInt("1771"), Z: p3.create(BigInt("-11")) }))(), O3 = (() => (0, i2.createHasher)(e8.secp256k1.ProjectivePoint, (e9) => {
    const { x: t4, y: n3 } = P3(p3.create(e9[0]));
    return R3(t4, n3);
  }, { DST: "secp256k1_XMD:SHA-256_SSWU_RO_", encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_", p: p3.ORDER, m: 1, k: 128, expand: "xmd", hash: t3.sha256 }))();
  e8.hashToCurve = O3.hashToCurve, e8.encodeToCurve = O3.encodeToCurve;
}(Jn);
var fr = {};
!function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.decodeHex = e8.remove0x = void 0;
  var t3 = pe;
  e8.remove0x = function(e9) {
    return e9.startsWith("0x") || e9.startsWith("0X") ? e9.slice(2) : e9;
  };
  e8.decodeHex = function(n2) {
    return (0, t3.hexToBytes)((0, e8.remove0x)(n2));
  };
}(fr), function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.hexToPublicKey = e8.convertPublicKeyFormat = e8.getSharedPoint = e8.getPublicKey = e8.isValidPrivateKey = e8.getValidSecret = void 0;
  var t3 = Te, n2 = Pe, r3 = Jn, i2 = Ce, o = ke, s = fr;
  e8.getValidSecret = function() {
    var n3;
    do {
      n3 = (0, t3.randomBytes)(o.SECRET_KEY_LENGTH);
    } while (!(0, e8.isValidPrivateKey)(n3));
    return n3;
  };
  e8.isValidPrivateKey = function(e9) {
    return a((0, i2.ellipticCurve)(), function(t4) {
      return t4.utils.isValidPrivateKey(e9);
    }, function() {
      return true;
    }, function() {
      return true;
    });
  };
  e8.getPublicKey = function(e9) {
    return a((0, i2.ellipticCurve)(), function(t4) {
      return t4.getPublicKey(e9);
    }, function(t4) {
      return t4.getPublicKey(e9);
    }, function(t4) {
      return t4.getPublicKey(e9);
    });
  };
  e8.getSharedPoint = function(e9, t4, n3) {
    return a((0, i2.ellipticCurve)(), function(r4) {
      return r4.getSharedSecret(e9, t4, n3);
    }, function(n4) {
      return n4.getSharedSecret(e9, t4);
    }, function(n4) {
      return l3(n4, e9, t4);
    });
  };
  e8.convertPublicKeyFormat = function(e9, t4) {
    return a((0, i2.ellipticCurve)(), function(n3) {
      return n3.getSharedSecret(BigInt(1), e9, t4);
    }, function() {
      return e9;
    }, function() {
      return e9;
    });
  };
  function a(e9, t4, i3, o2) {
    if ("secp256k1" === e9) return t4(r3.secp256k1);
    if ("x25519" === e9) return i3(n2.x25519);
    if ("ed25519" === e9) return o2(n2.ed25519);
    throw new Error("Not implemented");
  }
  e8.hexToPublicKey = function(e9) {
    var t4 = (0, s.decodeHex)(e9);
    return a((0, i2.ellipticCurve)(), function() {
      return c2(t4);
    }, function() {
      return t4;
    }, function() {
      return t4;
    });
  };
  var c2 = function(e9) {
    if (e9.length === o.ETH_PUBLIC_KEY_SIZE) {
      var t4 = new Uint8Array(1 + e9.length);
      return t4.set([4]), t4.set(e9, 1), t4;
    }
    return e9;
  }, l3 = function(e9, t4, n3) {
    var r4 = e9.utils.getExtendedPublicKey(t4).scalar;
    return e9.ExtendedPoint.fromHex(n3).multiply(r4).toRawBytes();
  };
}(Ie);
var pr = {};
var gr = {};
Object.defineProperty(gr, "__esModule", { value: true }), gr.hkdf = void 0, gr.extract = br, gr.expand = Sr;
var mr = Le;
var yr = ze;
var vr = ar;
function br(e8, t3, n2) {
  return (0, mr.hash)(e8), void 0 === n2 && (n2 = new Uint8Array(e8.outputLen)), (0, vr.hmac)(e8, (0, yr.toBytes)(n2), (0, yr.toBytes)(t3));
}
var wr = new Uint8Array([0]);
var Er = new Uint8Array();
function Sr(e8, t3, n2, r3 = 32) {
  if ((0, mr.hash)(e8), (0, mr.number)(r3), r3 > 255 * e8.outputLen) throw new Error("Length should be <= 255*HashLen");
  const i2 = Math.ceil(r3 / e8.outputLen);
  void 0 === n2 && (n2 = Er);
  const o = new Uint8Array(i2 * e8.outputLen), s = vr.hmac.create(e8, t3), a = s._cloneInto(), c2 = new Uint8Array(s.outputLen);
  for (let t4 = 0; t4 < i2; t4++) wr[0] = t4 + 1, a.update(0 === t4 ? Er : c2).update(n2).update(wr).digestInto(c2), o.set(c2, e8.outputLen * t4), s._cloneInto(a);
  return s.destroy(), a.destroy(), c2.fill(0), wr.fill(0), o.slice(0, r3);
}
gr.hkdf = (e8, t3, n2, r3, i2) => Sr(e8, br(e8, t3, n2), r3, i2), function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.getSharedKey = e8.deriveKey = void 0;
  var t3 = pe, n2 = gr, r3 = Qn;
  e8.deriveKey = function(e9, t4, i2) {
    return (0, n2.hkdf)(r3.sha256, e9, t4, i2, 32);
  };
  e8.getSharedKey = function() {
    for (var n3 = [], r4 = 0; r4 < arguments.length; r4++) n3[r4] = arguments[r4];
    return (0, e8.deriveKey)(t3.concatBytes.apply(void 0, n3));
  };
}(pr);
var _r = {};
var Cr = {};
var kr = {};
var Ar = {};
Object.defineProperty(Ar, "__esModule", { value: true }), Ar.polyval = Ar.ghash = void 0, Ar._toGHASHKey = Or;
var xr = ge;
var Mr = pe;
var Ir = 16;
var Tr = new Uint8Array(16);
var Rr = (0, Mr.u32)(Tr);
var Pr = (e8) => (e8 >>> 0 & 255) << 24 | (e8 >>> 8 & 255) << 16 | (e8 >>> 16 & 255) << 8 | e8 >>> 24 & 255 | 0;
function Or(e8) {
  e8.reverse();
  const t3 = 1 & e8[15];
  let n2 = 0;
  for (let t4 = 0; t4 < e8.length; t4++) {
    const r3 = e8[t4];
    e8[t4] = r3 >>> 1 | n2, n2 = (1 & r3) << 7;
  }
  return e8[0] ^= 225 & -t3, e8;
}
var Nr = class {
  constructor(e8, t3) {
    this.blockLen = Ir, this.outputLen = Ir, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = false, e8 = (0, Mr.toBytes)(e8), (0, xr.bytes)(e8, 16);
    const n2 = (0, Mr.createView)(e8);
    let r3 = n2.getUint32(0, false), i2 = n2.getUint32(4, false), o = n2.getUint32(8, false), s = n2.getUint32(12, false);
    const a = [];
    for (let e9 = 0; e9 < 128; e9++) a.push({ s0: Pr(r3), s1: Pr(i2), s2: Pr(o), s3: Pr(s) }), { s0: r3, s1: i2, s2: o, s3: s } = { s3: (d3 = o) << 31 | (u2 = s) >>> 1, s2: (l3 = i2) << 31 | d3 >>> 1, s1: (c2 = r3) << 31 | l3 >>> 1, s0: c2 >>> 1 ^ 225 << 24 & -(1 & u2) };
    var c2, l3, d3, u2;
    const h3 = ((e9) => e9 > 65536 ? 8 : e9 > 1024 ? 4 : 2)(t3 || 1024);
    if (![1, 2, 4, 8].includes(h3)) throw new Error(`ghash: wrong window size=${h3}, should be 2, 4 or 8`);
    this.W = h3;
    const f2 = 128 / h3, p3 = this.windowSize = 2 ** h3, g3 = [];
    for (let e9 = 0; e9 < f2; e9++) for (let t4 = 0; t4 < p3; t4++) {
      let n3 = 0, r4 = 0, i3 = 0, o2 = 0;
      for (let s2 = 0; s2 < h3; s2++) {
        if (!(t4 >>> h3 - s2 - 1 & 1)) continue;
        const { s0: c3, s1: l4, s2: d4, s3: u3 } = a[h3 * e9 + s2];
        n3 ^= c3, r4 ^= l4, i3 ^= d4, o2 ^= u3;
      }
      g3.push({ s0: n3, s1: r4, s2: i3, s3: o2 });
    }
    this.t = g3;
  }
  _updateBlock(e8, t3, n2, r3) {
    e8 ^= this.s0, t3 ^= this.s1, n2 ^= this.s2, r3 ^= this.s3;
    const { W: i2, t: o, windowSize: s } = this;
    let a = 0, c2 = 0, l3 = 0, d3 = 0;
    const u2 = (1 << i2) - 1;
    let h3 = 0;
    for (const f2 of [e8, t3, n2, r3]) for (let e9 = 0; e9 < 4; e9++) {
      const t4 = f2 >>> 8 * e9 & 255;
      for (let e10 = 8 / i2 - 1; e10 >= 0; e10--) {
        const n3 = t4 >>> i2 * e10 & u2, { s0: r4, s1: f3, s2: p3, s3: g3 } = o[h3 * s + n3];
        a ^= r4, c2 ^= f3, l3 ^= p3, d3 ^= g3, h3 += 1;
      }
    }
    this.s0 = a, this.s1 = c2, this.s2 = l3, this.s3 = d3;
  }
  update(e8) {
    e8 = (0, Mr.toBytes)(e8), (0, xr.exists)(this);
    const t3 = (0, Mr.u32)(e8), n2 = Math.floor(e8.length / Ir), r3 = e8.length % Ir;
    for (let e9 = 0; e9 < n2; e9++) this._updateBlock(t3[4 * e9 + 0], t3[4 * e9 + 1], t3[4 * e9 + 2], t3[4 * e9 + 3]);
    return r3 && (Tr.set(e8.subarray(n2 * Ir)), this._updateBlock(Rr[0], Rr[1], Rr[2], Rr[3]), (0, Mr.clean)(Rr)), this;
  }
  destroy() {
    const { t: e8 } = this;
    for (const t3 of e8) t3.s0 = 0, t3.s1 = 0, t3.s2 = 0, t3.s3 = 0;
  }
  digestInto(e8) {
    (0, xr.exists)(this), (0, xr.output)(e8, this), this.finished = true;
    const { s0: t3, s1: n2, s2: r3, s3: i2 } = this, o = (0, Mr.u32)(e8);
    return o[0] = t3, o[1] = n2, o[2] = r3, o[3] = i2, e8;
  }
  digest() {
    const e8 = new Uint8Array(Ir);
    return this.digestInto(e8), this.destroy(), e8;
  }
};
var Lr = class extends Nr {
  constructor(e8, t3) {
    e8 = (0, Mr.toBytes)(e8);
    const n2 = Or((0, Mr.copyBytes)(e8));
    super(n2, t3), (0, Mr.clean)(n2);
  }
  update(e8) {
    e8 = (0, Mr.toBytes)(e8), (0, xr.exists)(this);
    const t3 = (0, Mr.u32)(e8), n2 = e8.length % Ir, r3 = Math.floor(e8.length / Ir);
    for (let e9 = 0; e9 < r3; e9++) this._updateBlock(Pr(t3[4 * e9 + 3]), Pr(t3[4 * e9 + 2]), Pr(t3[4 * e9 + 1]), Pr(t3[4 * e9 + 0]));
    return n2 && (Tr.set(e8.subarray(r3 * Ir)), this._updateBlock(Pr(Rr[3]), Pr(Rr[2]), Pr(Rr[1]), Pr(Rr[0])), (0, Mr.clean)(Rr)), this;
  }
  digestInto(e8) {
    (0, xr.exists)(this), (0, xr.output)(e8, this), this.finished = true;
    const { s0: t3, s1: n2, s2: r3, s3: i2 } = this, o = (0, Mr.u32)(e8);
    return o[0] = t3, o[1] = n2, o[2] = r3, o[3] = i2, e8.reverse();
  }
};
function Dr(e8) {
  const t3 = (t4, n3) => e8(n3, t4.length).update((0, Mr.toBytes)(t4)).digest(), n2 = e8(new Uint8Array(16), 0);
  return t3.outputLen = n2.outputLen, t3.blockLen = n2.blockLen, t3.create = (t4, n3) => e8(t4, n3), t3;
}
Ar.ghash = Dr((e8, t3) => new Nr(e8, t3)), Ar.polyval = Dr((e8, t3) => new Lr(e8, t3)), Object.defineProperty(kr, "__esModule", { value: true }), kr.unsafe = kr.aeskwp = kr.aeskw = kr.siv = kr.gcm = kr.cfb = kr.cbc = kr.ecb = kr.ctr = void 0, kr.expandKeyLE = ei, kr.expandKeyDecLE = ti;
var $r = ge;
var Br = Ar;
var Kr = pe;
var jr = 16;
var Ur = new Uint8Array(jr);
var Hr = 283;
function Fr(e8) {
  return e8 << 1 ^ Hr & -(e8 >> 7);
}
function zr(e8, t3) {
  let n2 = 0;
  for (; t3 > 0; t3 >>= 1) n2 ^= e8 & -(1 & t3), e8 = Fr(e8);
  return n2;
}
var qr = (() => {
  const e8 = new Uint8Array(256);
  for (let t4 = 0, n2 = 1; t4 < 256; t4++, n2 ^= Fr(n2)) e8[t4] = n2;
  const t3 = new Uint8Array(256);
  t3[0] = 99;
  for (let n2 = 0; n2 < 255; n2++) {
    let r3 = e8[255 - n2];
    r3 |= r3 << 8, t3[e8[n2]] = 255 & (r3 ^ r3 >> 4 ^ r3 >> 5 ^ r3 >> 6 ^ r3 >> 7 ^ 99);
  }
  return (0, Kr.clean)(e8), t3;
})();
var Wr = qr.map((e8, t3) => qr.indexOf(t3));
var Vr = (e8) => e8 << 24 | e8 >>> 8;
var Gr = (e8) => e8 << 8 | e8 >>> 24;
var Yr = (e8) => e8 << 24 & 4278190080 | e8 << 8 & 16711680 | e8 >>> 8 & 65280 | e8 >>> 24 & 255;
function Zr(e8, t3) {
  if (256 !== e8.length) throw new Error("Wrong sbox length");
  const n2 = new Uint32Array(256).map((n3, r4) => t3(e8[r4])), r3 = n2.map(Gr), i2 = r3.map(Gr), o = i2.map(Gr), s = new Uint32Array(65536), a = new Uint32Array(65536), c2 = new Uint16Array(65536);
  for (let t4 = 0; t4 < 256; t4++) for (let l3 = 0; l3 < 256; l3++) {
    const d3 = 256 * t4 + l3;
    s[d3] = n2[t4] ^ r3[l3], a[d3] = i2[t4] ^ o[l3], c2[d3] = e8[t4] << 8 | e8[l3];
  }
  return { sbox: e8, sbox2: c2, T0: n2, T1: r3, T2: i2, T3: o, T01: s, T23: a };
}
var Jr = Zr(qr, (e8) => zr(e8, 3) << 24 | e8 << 16 | e8 << 8 | zr(e8, 2));
var Qr = Zr(Wr, (e8) => zr(e8, 11) << 24 | zr(e8, 13) << 16 | zr(e8, 9) << 8 | zr(e8, 14));
var Xr = (() => {
  const e8 = new Uint8Array(16);
  for (let t3 = 0, n2 = 1; t3 < 16; t3++, n2 = Fr(n2)) e8[t3] = n2;
  return e8;
})();
function ei(e8) {
  (0, $r.bytes)(e8);
  const t3 = e8.length;
  if (![16, 24, 32].includes(t3)) throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t3}`);
  const { sbox2: n2 } = Jr, r3 = [];
  (0, Kr.isAligned32)(e8) || r3.push(e8 = (0, Kr.copyBytes)(e8));
  const i2 = (0, Kr.u32)(e8), o = i2.length, s = (e9) => ri(n2, e9, e9, e9, e9), a = new Uint32Array(t3 + 28);
  a.set(i2);
  for (let e9 = o; e9 < a.length; e9++) {
    let t4 = a[e9 - 1];
    e9 % o == 0 ? t4 = s(Vr(t4)) ^ Xr[e9 / o - 1] : o > 6 && e9 % o == 4 && (t4 = s(t4)), a[e9] = a[e9 - o] ^ t4;
  }
  return (0, Kr.clean)(...r3), a;
}
function ti(e8) {
  const t3 = ei(e8), n2 = t3.slice(), r3 = t3.length, { sbox2: i2 } = Jr, { T0: o, T1: s, T2: a, T3: c2 } = Qr;
  for (let e9 = 0; e9 < r3; e9 += 4) for (let i3 = 0; i3 < 4; i3++) n2[e9 + i3] = t3[r3 - e9 - 4 + i3];
  (0, Kr.clean)(t3);
  for (let e9 = 4; e9 < r3 - 4; e9++) {
    const t4 = n2[e9], r4 = ri(i2, t4, t4, t4, t4);
    n2[e9] = o[255 & r4] ^ s[r4 >>> 8 & 255] ^ a[r4 >>> 16 & 255] ^ c2[r4 >>> 24];
  }
  return n2;
}
function ni(e8, t3, n2, r3, i2, o) {
  return e8[n2 << 8 & 65280 | r3 >>> 8 & 255] ^ t3[i2 >>> 8 & 65280 | o >>> 24 & 255];
}
function ri(e8, t3, n2, r3, i2) {
  return e8[255 & t3 | 65280 & n2] | e8[r3 >>> 16 & 255 | i2 >>> 16 & 65280] << 16;
}
function ii(e8, t3, n2, r3, i2) {
  const { sbox2: o, T01: s, T23: a } = Jr;
  let c2 = 0;
  t3 ^= e8[c2++], n2 ^= e8[c2++], r3 ^= e8[c2++], i2 ^= e8[c2++];
  const l3 = e8.length / 4 - 2;
  for (let o2 = 0; o2 < l3; o2++) {
    const o3 = e8[c2++] ^ ni(s, a, t3, n2, r3, i2), l4 = e8[c2++] ^ ni(s, a, n2, r3, i2, t3), d3 = e8[c2++] ^ ni(s, a, r3, i2, t3, n2), u2 = e8[c2++] ^ ni(s, a, i2, t3, n2, r3);
    t3 = o3, n2 = l4, r3 = d3, i2 = u2;
  }
  return { s0: e8[c2++] ^ ri(o, t3, n2, r3, i2), s1: e8[c2++] ^ ri(o, n2, r3, i2, t3), s2: e8[c2++] ^ ri(o, r3, i2, t3, n2), s3: e8[c2++] ^ ri(o, i2, t3, n2, r3) };
}
function oi(e8, t3, n2, r3, i2) {
  const { sbox2: o, T01: s, T23: a } = Qr;
  let c2 = 0;
  t3 ^= e8[c2++], n2 ^= e8[c2++], r3 ^= e8[c2++], i2 ^= e8[c2++];
  const l3 = e8.length / 4 - 2;
  for (let o2 = 0; o2 < l3; o2++) {
    const o3 = e8[c2++] ^ ni(s, a, t3, i2, r3, n2), l4 = e8[c2++] ^ ni(s, a, n2, t3, i2, r3), d3 = e8[c2++] ^ ni(s, a, r3, n2, t3, i2), u2 = e8[c2++] ^ ni(s, a, i2, r3, n2, t3);
    t3 = o3, n2 = l4, r3 = d3, i2 = u2;
  }
  return { s0: e8[c2++] ^ ri(o, t3, i2, r3, n2), s1: e8[c2++] ^ ri(o, n2, t3, i2, r3), s2: e8[c2++] ^ ri(o, r3, n2, t3, i2), s3: e8[c2++] ^ ri(o, i2, r3, n2, t3) };
}
function si(e8, t3) {
  if (void 0 === t3) return new Uint8Array(e8);
  if ((0, $r.bytes)(t3), t3.length < e8) throw new Error(`aes: wrong destination length, expected at least ${e8}, got: ${t3.length}`);
  if (!(0, Kr.isAligned32)(t3)) throw new Error("unaligned dst");
  return t3;
}
function ai(e8, t3, n2, r3) {
  (0, $r.bytes)(t3, jr), (0, $r.bytes)(n2);
  const i2 = n2.length;
  r3 = si(i2, r3);
  const o = t3, s = (0, Kr.u32)(o);
  let { s0: a, s1: c2, s2: l3, s3: d3 } = ii(e8, s[0], s[1], s[2], s[3]);
  const u2 = (0, Kr.u32)(n2), h3 = (0, Kr.u32)(r3);
  for (let t4 = 0; t4 + 4 <= u2.length; t4 += 4) {
    h3[t4 + 0] = u2[t4 + 0] ^ a, h3[t4 + 1] = u2[t4 + 1] ^ c2, h3[t4 + 2] = u2[t4 + 2] ^ l3, h3[t4 + 3] = u2[t4 + 3] ^ d3;
    let n3 = 1;
    for (let e9 = o.length - 1; e9 >= 0; e9--) n3 = n3 + (255 & o[e9]) | 0, o[e9] = 255 & n3, n3 >>>= 8;
    ({ s0: a, s1: c2, s2: l3, s3: d3 } = ii(e8, s[0], s[1], s[2], s[3]));
  }
  const f2 = jr * Math.floor(u2.length / 4);
  if (f2 < i2) {
    const e9 = new Uint32Array([a, c2, l3, d3]), t4 = (0, Kr.u8)(e9);
    for (let e10 = f2, o2 = 0; e10 < i2; e10++, o2++) r3[e10] = n2[e10] ^ t4[o2];
    (0, Kr.clean)(e9);
  }
  return r3;
}
function ci(e8, t3, n2, r3, i2) {
  (0, $r.bytes)(n2, jr), (0, $r.bytes)(r3), i2 = si(r3.length, i2);
  const o = n2, s = (0, Kr.u32)(o), a = (0, Kr.createView)(o), c2 = (0, Kr.u32)(r3), l3 = (0, Kr.u32)(i2), d3 = t3 ? 0 : 12, u2 = r3.length;
  let h3 = a.getUint32(d3, t3), { s0: f2, s1: p3, s2: g3, s3: m2 } = ii(e8, s[0], s[1], s[2], s[3]);
  for (let n3 = 0; n3 + 4 <= c2.length; n3 += 4) l3[n3 + 0] = c2[n3 + 0] ^ f2, l3[n3 + 1] = c2[n3 + 1] ^ p3, l3[n3 + 2] = c2[n3 + 2] ^ g3, l3[n3 + 3] = c2[n3 + 3] ^ m2, h3 = h3 + 1 >>> 0, a.setUint32(d3, h3, t3), { s0: f2, s1: p3, s2: g3, s3: m2 } = ii(e8, s[0], s[1], s[2], s[3]);
  const y3 = jr * Math.floor(c2.length / 4);
  if (y3 < u2) {
    const e9 = new Uint32Array([f2, p3, g3, m2]), t4 = (0, Kr.u8)(e9);
    for (let e10 = y3, n3 = 0; e10 < u2; e10++, n3++) i2[e10] = r3[e10] ^ t4[n3];
    (0, Kr.clean)(e9);
  }
  return i2;
}
function li(e8) {
  if ((0, $r.bytes)(e8), e8.length % jr != 0) throw new Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16");
}
function di(e8, t3, n2) {
  (0, $r.bytes)(e8);
  let r3 = e8.length;
  const i2 = r3 % jr;
  if (!t3 && 0 !== i2) throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  (0, Kr.isAligned32)(e8) || (e8 = (0, Kr.copyBytes)(e8));
  const o = (0, Kr.u32)(e8);
  if (t3) {
    let e9 = jr - i2;
    e9 || (e9 = jr), r3 += e9;
  }
  const s = si(r3, n2);
  return { b: o, o: (0, Kr.u32)(s), out: s };
}
function ui(e8, t3) {
  if (!t3) return e8;
  const n2 = e8.length;
  if (!n2) throw new Error("aes/pcks5: empty ciphertext not allowed");
  const r3 = e8[n2 - 1];
  if (r3 <= 0 || r3 > 16) throw new Error("aes/pcks5: wrong padding");
  const i2 = e8.subarray(0, -r3);
  for (let t4 = 0; t4 < r3; t4++) if (e8[n2 - t4 - 1] !== r3) throw new Error("aes/pcks5: wrong padding");
  return i2;
}
function hi(e8) {
  const t3 = new Uint8Array(16), n2 = (0, Kr.u32)(t3);
  t3.set(e8);
  const r3 = jr - e8.length;
  for (let e9 = jr - r3; e9 < jr; e9++) t3[e9] = r3;
  return n2;
}
function fi(e8, t3, n2, r3, i2) {
  const o = null == i2 ? 0 : i2.length, s = e8.create(n2, r3.length + o);
  i2 && s.update(i2), s.update(r3);
  const a = new Uint8Array(16), c2 = (0, Kr.createView)(a);
  i2 && (0, Kr.setBigUint64)(c2, 0, BigInt(8 * o), t3), (0, Kr.setBigUint64)(c2, 8, BigInt(8 * r3.length), t3), s.update(a);
  const l3 = s.digest();
  return (0, Kr.clean)(a), l3;
}
kr.ctr = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e8, t3) {
  function n2(n3, r3) {
    if ((0, $r.bytes)(n3), void 0 !== r3 && ((0, $r.bytes)(r3), !(0, Kr.isAligned32)(r3))) throw new Error("unaligned destination");
    const i2 = ei(e8), o = (0, Kr.copyBytes)(t3), s = [i2, o];
    (0, Kr.isAligned32)(n3) || s.push(n3 = (0, Kr.copyBytes)(n3));
    const a = ai(i2, o, n3, r3);
    return (0, Kr.clean)(...s), a;
  }
  return (0, $r.bytes)(e8), (0, $r.bytes)(t3, jr), { encrypt: (e9, t4) => n2(e9, t4), decrypt: (e9, t4) => n2(e9, t4) };
}), kr.ecb = (0, Kr.wrapCipher)({ blockSize: 16 }, function(e8, t3 = {}) {
  (0, $r.bytes)(e8);
  const n2 = !t3.disablePadding;
  return { encrypt(t4, r3) {
    const { b: i2, o, out: s } = di(t4, n2, r3), a = ei(e8);
    let c2 = 0;
    for (; c2 + 4 <= i2.length; ) {
      const { s0: e9, s1: t5, s2: n3, s3: r4 } = ii(a, i2[c2 + 0], i2[c2 + 1], i2[c2 + 2], i2[c2 + 3]);
      o[c2++] = e9, o[c2++] = t5, o[c2++] = n3, o[c2++] = r4;
    }
    if (n2) {
      const e9 = hi(t4.subarray(4 * c2)), { s0: n3, s1: r4, s2: i3, s3: s2 } = ii(a, e9[0], e9[1], e9[2], e9[3]);
      o[c2++] = n3, o[c2++] = r4, o[c2++] = i3, o[c2++] = s2;
    }
    return (0, Kr.clean)(a), s;
  }, decrypt(t4, r3) {
    li(t4);
    const i2 = ti(e8), o = si(t4.length, r3), s = [i2];
    (0, Kr.isAligned32)(t4) || s.push(t4 = (0, Kr.copyBytes)(t4));
    const a = (0, Kr.u32)(t4), c2 = (0, Kr.u32)(o);
    for (let e9 = 0; e9 + 4 <= a.length; ) {
      const { s0: t5, s1: n3, s2: r4, s3: o2 } = oi(i2, a[e9 + 0], a[e9 + 1], a[e9 + 2], a[e9 + 3]);
      c2[e9++] = t5, c2[e9++] = n3, c2[e9++] = r4, c2[e9++] = o2;
    }
    return (0, Kr.clean)(...s), ui(o, n2);
  } };
}), kr.cbc = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e8, t3, n2 = {}) {
  (0, $r.bytes)(e8), (0, $r.bytes)(t3, 16);
  const r3 = !n2.disablePadding;
  return { encrypt(n3, i2) {
    const o = ei(e8), { b: s, o: a, out: c2 } = di(n3, r3, i2);
    let l3 = t3;
    const d3 = [o];
    (0, Kr.isAligned32)(l3) || d3.push(l3 = (0, Kr.copyBytes)(l3));
    const u2 = (0, Kr.u32)(l3);
    let h3 = u2[0], f2 = u2[1], p3 = u2[2], g3 = u2[3], m2 = 0;
    for (; m2 + 4 <= s.length; ) h3 ^= s[m2 + 0], f2 ^= s[m2 + 1], p3 ^= s[m2 + 2], g3 ^= s[m2 + 3], { s0: h3, s1: f2, s2: p3, s3: g3 } = ii(o, h3, f2, p3, g3), a[m2++] = h3, a[m2++] = f2, a[m2++] = p3, a[m2++] = g3;
    if (r3) {
      const e9 = hi(n3.subarray(4 * m2));
      h3 ^= e9[0], f2 ^= e9[1], p3 ^= e9[2], g3 ^= e9[3], { s0: h3, s1: f2, s2: p3, s3: g3 } = ii(o, h3, f2, p3, g3), a[m2++] = h3, a[m2++] = f2, a[m2++] = p3, a[m2++] = g3;
    }
    return (0, Kr.clean)(...d3), c2;
  }, decrypt(n3, i2) {
    li(n3);
    const o = ti(e8);
    let s = t3;
    const a = [o];
    (0, Kr.isAligned32)(s) || a.push(s = (0, Kr.copyBytes)(s));
    const c2 = (0, Kr.u32)(s), l3 = si(n3.length, i2);
    (0, Kr.isAligned32)(n3) || a.push(n3 = (0, Kr.copyBytes)(n3));
    const d3 = (0, Kr.u32)(n3), u2 = (0, Kr.u32)(l3);
    let h3 = c2[0], f2 = c2[1], p3 = c2[2], g3 = c2[3];
    for (let e9 = 0; e9 + 4 <= d3.length; ) {
      const t4 = h3, n4 = f2, r4 = p3, i3 = g3;
      h3 = d3[e9 + 0], f2 = d3[e9 + 1], p3 = d3[e9 + 2], g3 = d3[e9 + 3];
      const { s0: s2, s1: a2, s2: c3, s3: l4 } = oi(o, h3, f2, p3, g3);
      u2[e9++] = s2 ^ t4, u2[e9++] = a2 ^ n4, u2[e9++] = c3 ^ r4, u2[e9++] = l4 ^ i3;
    }
    return (0, Kr.clean)(...a), ui(l3, r3);
  } };
}), kr.cfb = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e8, t3) {
  function n2(n3, r3, i2) {
    (0, $r.bytes)(n3);
    const o = n3.length;
    i2 = si(o, i2);
    const s = ei(e8);
    let a = t3;
    const c2 = [s];
    (0, Kr.isAligned32)(a) || c2.push(a = (0, Kr.copyBytes)(a)), (0, Kr.isAligned32)(n3) || c2.push(n3 = (0, Kr.copyBytes)(n3));
    const l3 = (0, Kr.u32)(n3), d3 = (0, Kr.u32)(i2), u2 = r3 ? d3 : l3, h3 = (0, Kr.u32)(a);
    let f2 = h3[0], p3 = h3[1], g3 = h3[2], m2 = h3[3];
    for (let e9 = 0; e9 + 4 <= l3.length; ) {
      const { s0: t4, s1: n4, s2: r4, s3: i3 } = ii(s, f2, p3, g3, m2);
      d3[e9 + 0] = l3[e9 + 0] ^ t4, d3[e9 + 1] = l3[e9 + 1] ^ n4, d3[e9 + 2] = l3[e9 + 2] ^ r4, d3[e9 + 3] = l3[e9 + 3] ^ i3, f2 = u2[e9++], p3 = u2[e9++], g3 = u2[e9++], m2 = u2[e9++];
    }
    const y3 = jr * Math.floor(l3.length / 4);
    if (y3 < o) {
      ({ s0: f2, s1: p3, s2: g3, s3: m2 } = ii(s, f2, p3, g3, m2));
      const e9 = (0, Kr.u8)(new Uint32Array([f2, p3, g3, m2]));
      for (let t4 = y3, r4 = 0; t4 < o; t4++, r4++) i2[t4] = n3[t4] ^ e9[r4];
      (0, Kr.clean)(e9);
    }
    return (0, Kr.clean)(...c2), i2;
  }
  return (0, $r.bytes)(e8), (0, $r.bytes)(t3, 16), { encrypt: (e9, t4) => n2(e9, true, t4), decrypt: (e9, t4) => n2(e9, false, t4) };
}), kr.gcm = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function(e8, t3, n2) {
  if ((0, $r.bytes)(e8), (0, $r.bytes)(t3), void 0 !== n2 && (0, $r.bytes)(n2), t3.length < 8) throw new Error("aes/gcm: invalid nonce length");
  const r3 = 16;
  function i2(e9, t4, r4) {
    const i3 = fi(Br.ghash, false, e9, r4, n2);
    for (let e10 = 0; e10 < t4.length; e10++) i3[e10] ^= t4[e10];
    return i3;
  }
  function o() {
    const n3 = ei(e8), r4 = Ur.slice(), i3 = Ur.slice();
    if (ci(n3, false, i3, i3, r4), 12 === t3.length) i3.set(t3);
    else {
      const e9 = Ur.slice(), n4 = (0, Kr.createView)(e9);
      (0, Kr.setBigUint64)(n4, 8, BigInt(8 * t3.length), false);
      const o2 = Br.ghash.create(r4).update(t3).update(e9);
      o2.digestInto(i3), o2.destroy();
    }
    return { xk: n3, authKey: r4, counter: i3, tagMask: ci(n3, false, i3, Ur) };
  }
  return { encrypt(e9) {
    (0, $r.bytes)(e9);
    const { xk: t4, authKey: n3, counter: s, tagMask: a } = o(), c2 = new Uint8Array(e9.length + r3), l3 = [t4, n3, s, a];
    (0, Kr.isAligned32)(e9) || l3.push(e9 = (0, Kr.copyBytes)(e9)), ci(t4, false, s, e9, c2);
    const d3 = i2(n3, a, c2.subarray(0, c2.length - r3));
    return l3.push(d3), c2.set(d3, e9.length), (0, Kr.clean)(...l3), c2;
  }, decrypt(e9) {
    if ((0, $r.bytes)(e9), e9.length < r3) throw new Error("aes/gcm: ciphertext less than tagLen (16)");
    const { xk: t4, authKey: n3, counter: s, tagMask: a } = o(), c2 = [t4, n3, a, s];
    (0, Kr.isAligned32)(e9) || c2.push(e9 = (0, Kr.copyBytes)(e9));
    const l3 = e9.subarray(0, -16), d3 = e9.subarray(-16), u2 = i2(n3, a, l3);
    if (c2.push(u2), !(0, Kr.equalBytes)(u2, d3)) throw new Error("aes/gcm: invalid ghash tag");
    const h3 = ci(t4, false, s, l3);
    return (0, Kr.clean)(...c2), h3;
  } };
});
var pi = (e8, t3, n2) => (r3) => {
  if (!Number.isSafeInteger(r3) || t3 > r3 || r3 > n2) throw new Error(`${e8}: invalid value=${r3}, must be [${t3}..${n2}]`);
};
function gi(e8) {
  return null != e8 && "object" == typeof e8 && (e8 instanceof Uint32Array || "Uint32Array" === e8.constructor.name);
}
function mi(e8, t3) {
  if ((0, $r.bytes)(t3, 16), !gi(e8)) throw new Error("_encryptBlock accepts result of expandKeyLE");
  const n2 = (0, Kr.u32)(t3);
  let { s0: r3, s1: i2, s2: o, s3: s } = ii(e8, n2[0], n2[1], n2[2], n2[3]);
  return n2[0] = r3, n2[1] = i2, n2[2] = o, n2[3] = s, t3;
}
function yi(e8, t3) {
  if ((0, $r.bytes)(t3, 16), !gi(e8)) throw new Error("_decryptBlock accepts result of expandKeyLE");
  const n2 = (0, Kr.u32)(t3);
  let { s0: r3, s1: i2, s2: o, s3: s } = oi(e8, n2[0], n2[1], n2[2], n2[3]);
  return n2[0] = r3, n2[1] = i2, n2[2] = o, n2[3] = s, t3;
}
kr.siv = (0, Kr.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function(e8, t3, n2) {
  const r3 = pi("AAD", 0, 2 ** 36), i2 = pi("plaintext", 0, 2 ** 36), o = pi("nonce", 12, 12), s = pi("ciphertext", 16, 2 ** 36 + 16);
  function a() {
    const n3 = ei(e8), r4 = new Uint8Array(e8.length), i3 = new Uint8Array(16), o2 = [n3, r4];
    let s2 = t3;
    (0, Kr.isAligned32)(s2) || o2.push(s2 = (0, Kr.copyBytes)(s2));
    const a2 = (0, Kr.u32)(s2);
    let c3 = 0, l4 = a2[0], d3 = a2[1], u2 = a2[2], h3 = 0;
    for (const e9 of [i3, r4].map(Kr.u32)) {
      const t4 = (0, Kr.u32)(e9);
      for (let e10 = 0; e10 < t4.length; e10 += 2) {
        const { s0: r5, s1: i4 } = ii(n3, c3, l4, d3, u2);
        t4[e10 + 0] = r5, t4[e10 + 1] = i4, c3 = ++h3;
      }
    }
    const f2 = { authKey: i3, encKey: ei(r4) };
    return (0, Kr.clean)(...o2), f2;
  }
  function c2(e9, r4, i3) {
    const o2 = fi(Br.polyval, true, r4, i3, n2);
    for (let e10 = 0; e10 < 12; e10++) o2[e10] ^= t3[e10];
    o2[15] &= 127;
    const s2 = (0, Kr.u32)(o2);
    let a2 = s2[0], c3 = s2[1], l4 = s2[2], d3 = s2[3];
    return { s0: a2, s1: c3, s2: l4, s3: d3 } = ii(e9, a2, c3, l4, d3), s2[0] = a2, s2[1] = c3, s2[2] = l4, s2[3] = d3, o2;
  }
  function l3(e9, t4, n3) {
    let r4 = (0, Kr.copyBytes)(t4);
    r4[15] |= 128;
    const i3 = ci(e9, true, r4, n3);
    return (0, Kr.clean)(r4), i3;
  }
  return (0, $r.bytes)(e8, 16, 24, 32), (0, $r.bytes)(t3), o(t3.length), void 0 !== n2 && ((0, $r.bytes)(n2), r3(n2.length)), { encrypt(e9) {
    (0, $r.bytes)(e9), i2(e9.length);
    const { encKey: t4, authKey: n3 } = a(), r4 = c2(t4, n3, e9), o2 = [t4, n3, r4];
    (0, Kr.isAligned32)(e9) || o2.push(e9 = (0, Kr.copyBytes)(e9));
    const s2 = new Uint8Array(e9.length + 16);
    return s2.set(r4, e9.length), s2.set(l3(t4, r4, e9)), (0, Kr.clean)(...o2), s2;
  }, decrypt(e9) {
    (0, $r.bytes)(e9), s(e9.length);
    const t4 = e9.subarray(-16), { encKey: n3, authKey: r4 } = a(), i3 = [n3, r4];
    (0, Kr.isAligned32)(e9) || i3.push(e9 = (0, Kr.copyBytes)(e9));
    const o2 = l3(n3, t4, e9.subarray(0, -16)), d3 = c2(n3, r4, o2);
    if (i3.push(d3), !(0, Kr.equalBytes)(t4, d3)) throw (0, Kr.clean)(...i3), new Error("invalid polyval tag");
    return (0, Kr.clean)(...i3), o2;
  } };
});
var vi = { encrypt(e8, t3) {
  if (t3.length >= 2 ** 32) throw new Error("plaintext should be less than 4gb");
  const n2 = ei(e8);
  if (16 === t3.length) mi(n2, t3);
  else {
    const e9 = (0, Kr.u32)(t3);
    let r3 = e9[0], i2 = e9[1];
    for (let t4 = 0, o = 1; t4 < 6; t4++) for (let t5 = 2; t5 < e9.length; t5 += 2, o++) {
      const { s0: s, s1: a, s2: c2, s3: l3 } = ii(n2, r3, i2, e9[t5], e9[t5 + 1]);
      r3 = s, i2 = a ^ Yr(o), e9[t5] = c2, e9[t5 + 1] = l3;
    }
    e9[0] = r3, e9[1] = i2;
  }
  n2.fill(0);
}, decrypt(e8, t3) {
  if (t3.length - 8 >= 2 ** 32) throw new Error("ciphertext should be less than 4gb");
  const n2 = ti(e8), r3 = t3.length / 8 - 1;
  if (1 === r3) yi(n2, t3);
  else {
    const e9 = (0, Kr.u32)(t3);
    let i2 = e9[0], o = e9[1];
    for (let t4 = 0, s = 6 * r3; t4 < 6; t4++) for (let t5 = 2 * r3; t5 >= 1; t5 -= 2, s--) {
      o ^= Yr(s);
      const { s0: r4, s1: a, s2: c2, s3: l3 } = oi(n2, i2, o, e9[t5], e9[t5 + 1]);
      i2 = r4, o = a, e9[t5] = c2, e9[t5 + 1] = l3;
    }
    e9[0] = i2, e9[1] = o;
  }
  n2.fill(0);
} };
var bi = new Uint8Array(8).fill(166);
kr.aeskw = (0, Kr.wrapCipher)({ blockSize: 8 }, (e8) => ({ encrypt(t3) {
  if ((0, $r.bytes)(t3), !t3.length || t3.length % 8 != 0) throw new Error("invalid plaintext length");
  if (8 === t3.length) throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
  const n2 = (0, Kr.concatBytes)(bi, t3);
  return vi.encrypt(e8, n2), n2;
}, decrypt(t3) {
  if ((0, $r.bytes)(t3), t3.length % 8 != 0 || t3.length < 24) throw new Error("invalid ciphertext length");
  const n2 = (0, Kr.copyBytes)(t3);
  if (vi.decrypt(e8, n2), !(0, Kr.equalBytes)(n2.subarray(0, 8), bi)) throw new Error("integrity check failed");
  return n2.subarray(0, 8).fill(0), n2.subarray(8);
} }));
var wi = 2790873510;
kr.aeskwp = (0, Kr.wrapCipher)({ blockSize: 8 }, (e8) => ({ encrypt(t3) {
  if ((0, $r.bytes)(t3), !t3.length) throw new Error("invalid plaintext length");
  const n2 = 8 * Math.ceil(t3.length / 8), r3 = new Uint8Array(8 + n2);
  r3.set(t3, 8);
  const i2 = (0, Kr.u32)(r3);
  return i2[0] = wi, i2[1] = Yr(t3.length), vi.encrypt(e8, r3), r3;
}, decrypt(t3) {
  if ((0, $r.bytes)(t3), t3.length < 16) throw new Error("invalid ciphertext length");
  const n2 = (0, Kr.copyBytes)(t3), r3 = (0, Kr.u32)(n2);
  vi.decrypt(e8, n2);
  const i2 = Yr(r3[1]) >>> 0, o = 8 * Math.ceil(i2 / 8);
  if (r3[0] !== wi || n2.length - 8 !== o) throw new Error("integrity check failed");
  for (let e9 = i2; e9 < o; e9++) if (0 !== n2[8 + e9]) throw new Error("integrity check failed");
  return n2.subarray(0, 8).fill(0), n2.subarray(8, 8 + i2);
} })), kr.unsafe = { expandKeyLE: ei, expandKeyDecLE: ti, encrypt: ii, decrypt: oi, encryptBlock: mi, decryptBlock: yi, ctrCounter: ai, ctr32: ci }, Object.defineProperty(Cr, "__esModule", { value: true }), Cr.aes256cbc = Cr.aes256gcm = void 0;
var Ei = kr;
Cr.aes256gcm = function(e8, t3, n2) {
  return (0, Ei.gcm)(e8, t3, n2);
};
Cr.aes256cbc = function(e8, t3, n2) {
  return (0, Ei.cbc)(e8, t3);
};
var Si = {};
var _i = {};
var Ci = {};
Object.defineProperty(Ci, "__esModule", { value: true }), Ci.sigma = void 0, Ci.rotl = function(e8, t3) {
  return e8 << t3 | e8 >>> 32 - t3;
}, Ci.createCipher = function(e8, t3) {
  const { allowShortKeys: n2, extendNonceFn: r3, counterLength: i2, counterRight: o, rounds: s } = (0, Ai.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t3);
  if ("function" != typeof e8) throw new Error("core must be a function");
  return (0, ki.number)(i2), (0, ki.number)(s), (0, ki.bool)(o), (0, ki.bool)(n2), (t4, a, c2, l3, d3 = 0) => {
    (0, ki.bytes)(t4), (0, ki.bytes)(a), (0, ki.bytes)(c2);
    const u2 = c2.length;
    if (void 0 === l3 && (l3 = new Uint8Array(u2)), (0, ki.bytes)(l3), (0, ki.number)(d3), d3 < 0 || d3 >= Li) throw new Error("arx: counter overflow");
    if (l3.length < u2) throw new Error(`arx: output (${l3.length}) is shorter than data (${u2})`);
    const h3 = [];
    let f2, p3, g3 = t4.length;
    if (32 === g3) h3.push(f2 = (0, Ai.copyBytes)(t4)), p3 = Ri;
    else {
      if (16 !== g3 || !n2) throw new Error(`arx: invalid 32-byte key, got length=${g3}`);
      f2 = new Uint8Array(32), f2.set(t4), f2.set(t4, 16), p3 = Ti, h3.push(f2);
    }
    Pi(a) || h3.push(a = (0, Ai.copyBytes)(a));
    const m2 = (0, Ai.u32)(f2);
    if (r3) {
      if (24 !== a.length) throw new Error("arx: extended nonce must be 24 bytes");
      r3(p3, m2, (0, Ai.u32)(a.subarray(0, 16)), m2), a = a.subarray(16);
    }
    const y3 = 16 - i2;
    if (y3 !== a.length) throw new Error(`arx: nonce must be ${y3} or 16 bytes`);
    if (12 !== y3) {
      const e9 = new Uint8Array(12);
      e9.set(a, o ? 0 : 12 - a.length), a = e9, h3.push(a);
    }
    const v2 = (0, Ai.u32)(a);
    return function(e9, t5, n3, r4, i3, o2, s2, a2) {
      const c3 = i3.length, l4 = new Uint8Array(Oi), d4 = (0, Ai.u32)(l4), u3 = Pi(i3) && Pi(o2), h4 = u3 ? (0, Ai.u32)(i3) : Di, f3 = u3 ? (0, Ai.u32)(o2) : Di;
      for (let p4 = 0; p4 < c3; s2++) {
        if (e9(t5, n3, r4, d4, s2, a2), s2 >= Li) throw new Error("arx: counter overflow");
        const g4 = Math.min(Oi, c3 - p4);
        if (u3 && g4 === Oi) {
          const e10 = p4 / 4;
          if (p4 % 4 != 0) throw new Error("arx: invalid block position");
          for (let t6, n4 = 0; n4 < Ni; n4++) t6 = e10 + n4, f3[t6] = h4[t6] ^ d4[n4];
          p4 += Oi;
        } else {
          for (let e10, t6 = 0; t6 < g4; t6++) e10 = p4 + t6, o2[e10] = i3[e10] ^ l4[t6];
          p4 += g4;
        }
      }
    }(e8, p3, m2, v2, c2, l3, d3, s), (0, Ai.clean)(...h3), l3;
  };
};
var ki = ge;
var Ai = pe;
var xi = (e8) => Uint8Array.from(e8.split("").map((e9) => e9.charCodeAt(0)));
var Mi = xi("expand 16-byte k");
var Ii = xi("expand 32-byte k");
var Ti = (0, Ai.u32)(Mi);
var Ri = (0, Ai.u32)(Ii);
function Pi(e8) {
  return e8.byteOffset % 4 == 0;
}
Ci.sigma = Ri.slice();
var Oi = 64;
var Ni = 16;
var Li = 2 ** 32 - 1;
var Di = new Uint32Array();
var $i = {};
Object.defineProperty($i, "__esModule", { value: true }), $i.poly1305 = void 0, $i.wrapConstructorWithKey = Hi;
var Bi = ge;
var Ki = pe;
var ji = (e8, t3) => 255 & e8[t3++] | (255 & e8[t3++]) << 8;
var Ui = class {
  constructor(e8) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e8 = (0, Ki.toBytes)(e8), (0, Bi.bytes)(e8, 32);
    const t3 = ji(e8, 0), n2 = ji(e8, 2), r3 = ji(e8, 4), i2 = ji(e8, 6), o = ji(e8, 8), s = ji(e8, 10), a = ji(e8, 12), c2 = ji(e8, 14);
    this.r[0] = 8191 & t3, this.r[1] = 8191 & (t3 >>> 13 | n2 << 3), this.r[2] = 7939 & (n2 >>> 10 | r3 << 6), this.r[3] = 8191 & (r3 >>> 7 | i2 << 9), this.r[4] = 255 & (i2 >>> 4 | o << 12), this.r[5] = o >>> 1 & 8190, this.r[6] = 8191 & (o >>> 14 | s << 2), this.r[7] = 8065 & (s >>> 11 | a << 5), this.r[8] = 8191 & (a >>> 8 | c2 << 8), this.r[9] = c2 >>> 5 & 127;
    for (let t4 = 0; t4 < 8; t4++) this.pad[t4] = ji(e8, 16 + 2 * t4);
  }
  process(e8, t3, n2 = false) {
    const r3 = n2 ? 0 : 2048, { h: i2, r: o } = this, s = o[0], a = o[1], c2 = o[2], l3 = o[3], d3 = o[4], u2 = o[5], h3 = o[6], f2 = o[7], p3 = o[8], g3 = o[9], m2 = ji(e8, t3 + 0), y3 = ji(e8, t3 + 2), v2 = ji(e8, t3 + 4), b3 = ji(e8, t3 + 6), w2 = ji(e8, t3 + 8), E2 = ji(e8, t3 + 10), S3 = ji(e8, t3 + 12), _3 = ji(e8, t3 + 14);
    let C3 = i2[0] + (8191 & m2), k3 = i2[1] + (8191 & (m2 >>> 13 | y3 << 3)), A3 = i2[2] + (8191 & (y3 >>> 10 | v2 << 6)), x3 = i2[3] + (8191 & (v2 >>> 7 | b3 << 9)), M3 = i2[4] + (8191 & (b3 >>> 4 | w2 << 12)), I3 = i2[5] + (w2 >>> 1 & 8191), T2 = i2[6] + (8191 & (w2 >>> 14 | E2 << 2)), R3 = i2[7] + (8191 & (E2 >>> 11 | S3 << 5)), P3 = i2[8] + (8191 & (S3 >>> 8 | _3 << 8)), O3 = i2[9] + (_3 >>> 5 | r3), N3 = 0, L3 = N3 + C3 * s + k3 * (5 * g3) + A3 * (5 * p3) + x3 * (5 * f2) + M3 * (5 * h3);
    N3 = L3 >>> 13, L3 &= 8191, L3 += I3 * (5 * u2) + T2 * (5 * d3) + R3 * (5 * l3) + P3 * (5 * c2) + O3 * (5 * a), N3 += L3 >>> 13, L3 &= 8191;
    let D3 = N3 + C3 * a + k3 * s + A3 * (5 * g3) + x3 * (5 * p3) + M3 * (5 * f2);
    N3 = D3 >>> 13, D3 &= 8191, D3 += I3 * (5 * h3) + T2 * (5 * u2) + R3 * (5 * d3) + P3 * (5 * l3) + O3 * (5 * c2), N3 += D3 >>> 13, D3 &= 8191;
    let $3 = N3 + C3 * c2 + k3 * a + A3 * s + x3 * (5 * g3) + M3 * (5 * p3);
    N3 = $3 >>> 13, $3 &= 8191, $3 += I3 * (5 * f2) + T2 * (5 * h3) + R3 * (5 * u2) + P3 * (5 * d3) + O3 * (5 * l3), N3 += $3 >>> 13, $3 &= 8191;
    let B3 = N3 + C3 * l3 + k3 * c2 + A3 * a + x3 * s + M3 * (5 * g3);
    N3 = B3 >>> 13, B3 &= 8191, B3 += I3 * (5 * p3) + T2 * (5 * f2) + R3 * (5 * h3) + P3 * (5 * u2) + O3 * (5 * d3), N3 += B3 >>> 13, B3 &= 8191;
    let K3 = N3 + C3 * d3 + k3 * l3 + A3 * c2 + x3 * a + M3 * s;
    N3 = K3 >>> 13, K3 &= 8191, K3 += I3 * (5 * g3) + T2 * (5 * p3) + R3 * (5 * f2) + P3 * (5 * h3) + O3 * (5 * u2), N3 += K3 >>> 13, K3 &= 8191;
    let j3 = N3 + C3 * u2 + k3 * d3 + A3 * l3 + x3 * c2 + M3 * a;
    N3 = j3 >>> 13, j3 &= 8191, j3 += I3 * s + T2 * (5 * g3) + R3 * (5 * p3) + P3 * (5 * f2) + O3 * (5 * h3), N3 += j3 >>> 13, j3 &= 8191;
    let U3 = N3 + C3 * h3 + k3 * u2 + A3 * d3 + x3 * l3 + M3 * c2;
    N3 = U3 >>> 13, U3 &= 8191, U3 += I3 * a + T2 * s + R3 * (5 * g3) + P3 * (5 * p3) + O3 * (5 * f2), N3 += U3 >>> 13, U3 &= 8191;
    let H3 = N3 + C3 * f2 + k3 * h3 + A3 * u2 + x3 * d3 + M3 * l3;
    N3 = H3 >>> 13, H3 &= 8191, H3 += I3 * c2 + T2 * a + R3 * s + P3 * (5 * g3) + O3 * (5 * p3), N3 += H3 >>> 13, H3 &= 8191;
    let F3 = N3 + C3 * p3 + k3 * f2 + A3 * h3 + x3 * u2 + M3 * d3;
    N3 = F3 >>> 13, F3 &= 8191, F3 += I3 * l3 + T2 * c2 + R3 * a + P3 * s + O3 * (5 * g3), N3 += F3 >>> 13, F3 &= 8191;
    let z3 = N3 + C3 * g3 + k3 * p3 + A3 * f2 + x3 * h3 + M3 * u2;
    N3 = z3 >>> 13, z3 &= 8191, z3 += I3 * d3 + T2 * l3 + R3 * c2 + P3 * a + O3 * s, N3 += z3 >>> 13, z3 &= 8191, N3 = (N3 << 2) + N3 | 0, N3 = N3 + L3 | 0, L3 = 8191 & N3, N3 >>>= 13, D3 += N3, i2[0] = L3, i2[1] = D3, i2[2] = $3, i2[3] = B3, i2[4] = K3, i2[5] = j3, i2[6] = U3, i2[7] = H3, i2[8] = F3, i2[9] = z3;
  }
  finalize() {
    const { h: e8, pad: t3 } = this, n2 = new Uint16Array(10);
    let r3 = e8[1] >>> 13;
    e8[1] &= 8191;
    for (let t4 = 2; t4 < 10; t4++) e8[t4] += r3, r3 = e8[t4] >>> 13, e8[t4] &= 8191;
    e8[0] += 5 * r3, r3 = e8[0] >>> 13, e8[0] &= 8191, e8[1] += r3, r3 = e8[1] >>> 13, e8[1] &= 8191, e8[2] += r3, n2[0] = e8[0] + 5, r3 = n2[0] >>> 13, n2[0] &= 8191;
    for (let t4 = 1; t4 < 10; t4++) n2[t4] = e8[t4] + r3, r3 = n2[t4] >>> 13, n2[t4] &= 8191;
    n2[9] -= 8192;
    let i2 = (1 ^ r3) - 1;
    for (let e9 = 0; e9 < 10; e9++) n2[e9] &= i2;
    i2 = ~i2;
    for (let t4 = 0; t4 < 10; t4++) e8[t4] = e8[t4] & i2 | n2[t4];
    e8[0] = 65535 & (e8[0] | e8[1] << 13), e8[1] = 65535 & (e8[1] >>> 3 | e8[2] << 10), e8[2] = 65535 & (e8[2] >>> 6 | e8[3] << 7), e8[3] = 65535 & (e8[3] >>> 9 | e8[4] << 4), e8[4] = 65535 & (e8[4] >>> 12 | e8[5] << 1 | e8[6] << 14), e8[5] = 65535 & (e8[6] >>> 2 | e8[7] << 11), e8[6] = 65535 & (e8[7] >>> 5 | e8[8] << 8), e8[7] = 65535 & (e8[8] >>> 8 | e8[9] << 5);
    let o = e8[0] + t3[0];
    e8[0] = 65535 & o;
    for (let n3 = 1; n3 < 8; n3++) o = (e8[n3] + t3[n3] | 0) + (o >>> 16) | 0, e8[n3] = 65535 & o;
    (0, Ki.clean)(n2);
  }
  update(e8) {
    (0, Bi.exists)(this);
    const { buffer: t3, blockLen: n2 } = this, r3 = (e8 = (0, Ki.toBytes)(e8)).length;
    for (let i2 = 0; i2 < r3; ) {
      const o = Math.min(n2 - this.pos, r3 - i2);
      if (o !== n2) t3.set(e8.subarray(i2, i2 + o), this.pos), this.pos += o, i2 += o, this.pos === n2 && (this.process(t3, 0, false), this.pos = 0);
      else for (; n2 <= r3 - i2; i2 += n2) this.process(e8, i2);
    }
    return this;
  }
  destroy() {
    (0, Ki.clean)(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e8) {
    (0, Bi.exists)(this), (0, Bi.output)(e8, this), this.finished = true;
    const { buffer: t3, h: n2 } = this;
    let { pos: r3 } = this;
    if (r3) {
      for (t3[r3++] = 1; r3 < 16; r3++) t3[r3] = 0;
      this.process(t3, 0, true);
    }
    this.finalize();
    let i2 = 0;
    for (let t4 = 0; t4 < 8; t4++) e8[i2++] = n2[t4] >>> 0, e8[i2++] = n2[t4] >>> 8;
    return e8;
  }
  digest() {
    const { buffer: e8, outputLen: t3 } = this;
    this.digestInto(e8);
    const n2 = e8.slice(0, t3);
    return this.destroy(), n2;
  }
};
function Hi(e8) {
  const t3 = (t4, n3) => e8(n3).update((0, Ki.toBytes)(t4)).digest(), n2 = e8(new Uint8Array(32));
  return t3.outputLen = n2.outputLen, t3.blockLen = n2.blockLen, t3.create = (t4) => e8(t4), t3;
}
$i.poly1305 = Hi((e8) => new Ui(e8)), function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.xchacha20poly1305 = e8.chacha20poly1305 = e8._poly1305_aead = e8.chacha12 = e8.chacha8 = e8.xchacha20 = e8.chacha20 = e8.chacha20orig = void 0, e8.hchacha = s;
  const t3 = Ci, n2 = ge, r3 = $i, i2 = pe;
  function o(e9, n3, r4, i3, o2, s2 = 20) {
    let a2 = e9[0], c3 = e9[1], l4 = e9[2], d4 = e9[3], u2 = n3[0], h3 = n3[1], f2 = n3[2], p3 = n3[3], g3 = n3[4], m2 = n3[5], y3 = n3[6], v2 = n3[7], b3 = o2, w2 = r4[0], E2 = r4[1], S3 = r4[2], _3 = a2, C3 = c3, k3 = l4, A3 = d4, x3 = u2, M3 = h3, I3 = f2, T2 = p3, R3 = g3, P3 = m2, O3 = y3, N3 = v2, L3 = b3, D3 = w2, $3 = E2, B3 = S3;
    for (let e10 = 0; e10 < s2; e10 += 2) _3 = _3 + x3 | 0, L3 = (0, t3.rotl)(L3 ^ _3, 16), R3 = R3 + L3 | 0, x3 = (0, t3.rotl)(x3 ^ R3, 12), _3 = _3 + x3 | 0, L3 = (0, t3.rotl)(L3 ^ _3, 8), R3 = R3 + L3 | 0, x3 = (0, t3.rotl)(x3 ^ R3, 7), C3 = C3 + M3 | 0, D3 = (0, t3.rotl)(D3 ^ C3, 16), P3 = P3 + D3 | 0, M3 = (0, t3.rotl)(M3 ^ P3, 12), C3 = C3 + M3 | 0, D3 = (0, t3.rotl)(D3 ^ C3, 8), P3 = P3 + D3 | 0, M3 = (0, t3.rotl)(M3 ^ P3, 7), k3 = k3 + I3 | 0, $3 = (0, t3.rotl)($3 ^ k3, 16), O3 = O3 + $3 | 0, I3 = (0, t3.rotl)(I3 ^ O3, 12), k3 = k3 + I3 | 0, $3 = (0, t3.rotl)($3 ^ k3, 8), O3 = O3 + $3 | 0, I3 = (0, t3.rotl)(I3 ^ O3, 7), A3 = A3 + T2 | 0, B3 = (0, t3.rotl)(B3 ^ A3, 16), N3 = N3 + B3 | 0, T2 = (0, t3.rotl)(T2 ^ N3, 12), A3 = A3 + T2 | 0, B3 = (0, t3.rotl)(B3 ^ A3, 8), N3 = N3 + B3 | 0, T2 = (0, t3.rotl)(T2 ^ N3, 7), _3 = _3 + M3 | 0, B3 = (0, t3.rotl)(B3 ^ _3, 16), O3 = O3 + B3 | 0, M3 = (0, t3.rotl)(M3 ^ O3, 12), _3 = _3 + M3 | 0, B3 = (0, t3.rotl)(B3 ^ _3, 8), O3 = O3 + B3 | 0, M3 = (0, t3.rotl)(M3 ^ O3, 7), C3 = C3 + I3 | 0, L3 = (0, t3.rotl)(L3 ^ C3, 16), N3 = N3 + L3 | 0, I3 = (0, t3.rotl)(I3 ^ N3, 12), C3 = C3 + I3 | 0, L3 = (0, t3.rotl)(L3 ^ C3, 8), N3 = N3 + L3 | 0, I3 = (0, t3.rotl)(I3 ^ N3, 7), k3 = k3 + T2 | 0, D3 = (0, t3.rotl)(D3 ^ k3, 16), R3 = R3 + D3 | 0, T2 = (0, t3.rotl)(T2 ^ R3, 12), k3 = k3 + T2 | 0, D3 = (0, t3.rotl)(D3 ^ k3, 8), R3 = R3 + D3 | 0, T2 = (0, t3.rotl)(T2 ^ R3, 7), A3 = A3 + x3 | 0, $3 = (0, t3.rotl)($3 ^ A3, 16), P3 = P3 + $3 | 0, x3 = (0, t3.rotl)(x3 ^ P3, 12), A3 = A3 + x3 | 0, $3 = (0, t3.rotl)($3 ^ A3, 8), P3 = P3 + $3 | 0, x3 = (0, t3.rotl)(x3 ^ P3, 7);
    let K3 = 0;
    i3[K3++] = a2 + _3 | 0, i3[K3++] = c3 + C3 | 0, i3[K3++] = l4 + k3 | 0, i3[K3++] = d4 + A3 | 0, i3[K3++] = u2 + x3 | 0, i3[K3++] = h3 + M3 | 0, i3[K3++] = f2 + I3 | 0, i3[K3++] = p3 + T2 | 0, i3[K3++] = g3 + R3 | 0, i3[K3++] = m2 + P3 | 0, i3[K3++] = y3 + O3 | 0, i3[K3++] = v2 + N3 | 0, i3[K3++] = b3 + L3 | 0, i3[K3++] = w2 + D3 | 0, i3[K3++] = E2 + $3 | 0, i3[K3++] = S3 + B3 | 0;
  }
  function s(e9, n3, r4, i3) {
    let o2 = e9[0], s2 = e9[1], a2 = e9[2], c3 = e9[3], l4 = n3[0], d4 = n3[1], u2 = n3[2], h3 = n3[3], f2 = n3[4], p3 = n3[5], g3 = n3[6], m2 = n3[7], y3 = r4[0], v2 = r4[1], b3 = r4[2], w2 = r4[3];
    for (let e10 = 0; e10 < 20; e10 += 2) o2 = o2 + l4 | 0, y3 = (0, t3.rotl)(y3 ^ o2, 16), f2 = f2 + y3 | 0, l4 = (0, t3.rotl)(l4 ^ f2, 12), o2 = o2 + l4 | 0, y3 = (0, t3.rotl)(y3 ^ o2, 8), f2 = f2 + y3 | 0, l4 = (0, t3.rotl)(l4 ^ f2, 7), s2 = s2 + d4 | 0, v2 = (0, t3.rotl)(v2 ^ s2, 16), p3 = p3 + v2 | 0, d4 = (0, t3.rotl)(d4 ^ p3, 12), s2 = s2 + d4 | 0, v2 = (0, t3.rotl)(v2 ^ s2, 8), p3 = p3 + v2 | 0, d4 = (0, t3.rotl)(d4 ^ p3, 7), a2 = a2 + u2 | 0, b3 = (0, t3.rotl)(b3 ^ a2, 16), g3 = g3 + b3 | 0, u2 = (0, t3.rotl)(u2 ^ g3, 12), a2 = a2 + u2 | 0, b3 = (0, t3.rotl)(b3 ^ a2, 8), g3 = g3 + b3 | 0, u2 = (0, t3.rotl)(u2 ^ g3, 7), c3 = c3 + h3 | 0, w2 = (0, t3.rotl)(w2 ^ c3, 16), m2 = m2 + w2 | 0, h3 = (0, t3.rotl)(h3 ^ m2, 12), c3 = c3 + h3 | 0, w2 = (0, t3.rotl)(w2 ^ c3, 8), m2 = m2 + w2 | 0, h3 = (0, t3.rotl)(h3 ^ m2, 7), o2 = o2 + d4 | 0, w2 = (0, t3.rotl)(w2 ^ o2, 16), g3 = g3 + w2 | 0, d4 = (0, t3.rotl)(d4 ^ g3, 12), o2 = o2 + d4 | 0, w2 = (0, t3.rotl)(w2 ^ o2, 8), g3 = g3 + w2 | 0, d4 = (0, t3.rotl)(d4 ^ g3, 7), s2 = s2 + u2 | 0, y3 = (0, t3.rotl)(y3 ^ s2, 16), m2 = m2 + y3 | 0, u2 = (0, t3.rotl)(u2 ^ m2, 12), s2 = s2 + u2 | 0, y3 = (0, t3.rotl)(y3 ^ s2, 8), m2 = m2 + y3 | 0, u2 = (0, t3.rotl)(u2 ^ m2, 7), a2 = a2 + h3 | 0, v2 = (0, t3.rotl)(v2 ^ a2, 16), f2 = f2 + v2 | 0, h3 = (0, t3.rotl)(h3 ^ f2, 12), a2 = a2 + h3 | 0, v2 = (0, t3.rotl)(v2 ^ a2, 8), f2 = f2 + v2 | 0, h3 = (0, t3.rotl)(h3 ^ f2, 7), c3 = c3 + l4 | 0, b3 = (0, t3.rotl)(b3 ^ c3, 16), p3 = p3 + b3 | 0, l4 = (0, t3.rotl)(l4 ^ p3, 12), c3 = c3 + l4 | 0, b3 = (0, t3.rotl)(b3 ^ c3, 8), p3 = p3 + b3 | 0, l4 = (0, t3.rotl)(l4 ^ p3, 7);
    let E2 = 0;
    i3[E2++] = o2, i3[E2++] = s2, i3[E2++] = a2, i3[E2++] = c3, i3[E2++] = y3, i3[E2++] = v2, i3[E2++] = b3, i3[E2++] = w2;
  }
  e8.chacha20orig = (0, t3.createCipher)(o, { counterRight: false, counterLength: 8, allowShortKeys: true }), e8.chacha20 = (0, t3.createCipher)(o, { counterRight: false, counterLength: 4, allowShortKeys: false }), e8.xchacha20 = (0, t3.createCipher)(o, { counterRight: false, counterLength: 8, extendNonceFn: s, allowShortKeys: false }), e8.chacha8 = (0, t3.createCipher)(o, { counterRight: false, counterLength: 4, rounds: 8 }), e8.chacha12 = (0, t3.createCipher)(o, { counterRight: false, counterLength: 4, rounds: 12 });
  const a = new Uint8Array(16), c2 = (e9, t4) => {
    e9.update(t4);
    const n3 = t4.length % 16;
    n3 && e9.update(a.subarray(n3));
  }, l3 = new Uint8Array(32);
  function d3(e9, t4, n3, o2, s2) {
    const a2 = e9(t4, n3, l3), d4 = r3.poly1305.create(a2);
    s2 && c2(d4, s2), c2(d4, o2);
    const u2 = new Uint8Array(16), h3 = (0, i2.createView)(u2);
    (0, i2.setBigUint64)(h3, 0, BigInt(s2 ? s2.length : 0), true), (0, i2.setBigUint64)(h3, 8, BigInt(o2.length), true), d4.update(u2);
    const f2 = d4.digest();
    return (0, i2.clean)(a2, u2), f2;
  }
  e8._poly1305_aead = (e9) => (t4, r4, o2) => {
    const s2 = 16;
    return (0, n2.bytes)(t4, 32), (0, n2.bytes)(r4), { encrypt(a2, c3) {
      const l4 = a2.length, u2 = l4 + s2;
      c3 ? (0, n2.bytes)(c3, u2) : c3 = new Uint8Array(u2), e9(t4, r4, a2, c3, 1);
      const h3 = d3(e9, t4, r4, c3.subarray(0, -16), o2);
      return c3.set(h3, l4), (0, i2.clean)(h3), c3;
    }, decrypt(a2, c3) {
      const l4 = a2.length, u2 = l4 - s2;
      if (l4 < s2) throw new Error("encrypted data must be at least 16 bytes");
      c3 ? (0, n2.bytes)(c3, u2) : c3 = new Uint8Array(u2);
      const h3 = a2.subarray(0, -16), f2 = a2.subarray(-16), p3 = d3(e9, t4, r4, h3, o2);
      if (!(0, i2.equalBytes)(f2, p3)) throw new Error("invalid tag");
      return e9(t4, r4, h3, c3, 1), (0, i2.clean)(p3), c3;
    } };
  }, e8.chacha20poly1305 = (0, i2.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, e8._poly1305_aead)(e8.chacha20)), e8.xchacha20poly1305 = (0, i2.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, e8._poly1305_aead)(e8.xchacha20));
}(_i), Object.defineProperty(Si, "__esModule", { value: true }), Si.xchacha20 = void 0;
var Fi;
var zi;
var qi;
var Wi = _i;
Si.xchacha20 = function(e8, t3, n2) {
  return (0, Wi.xchacha20poly1305)(e8, t3, n2);
}, function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.aesDecrypt = e8.aesEncrypt = e8.symDecrypt = e8.symEncrypt = void 0;
  var t3 = pe, n2 = Te, r3 = Cr, i2 = Si, o = Ce, s = ke;
  e8.symEncrypt = function(e9, t4, n3) {
    return a(c2, e9, t4, n3);
  };
  function a(e9, t4, n3, a2) {
    var c3 = (0, o.symmetricAlgorithm)();
    if ("aes-256-gcm" === c3) return e9(r3.aes256gcm, t4, n3, (0, o.symmetricNonceLength)(), s.AEAD_TAG_LENGTH, a2);
    if ("xchacha20" === c3) return e9(i2.xchacha20, t4, n3, s.XCHACHA20_NONCE_LENGTH, s.AEAD_TAG_LENGTH, a2);
    if ("aes-256-cbc" === c3) return e9(r3.aes256cbc, t4, n3, 16, 0);
    throw new Error("Not implemented");
  }
  function c2(e9, r4, i3, o2, s2, a2) {
    var c3 = (0, n2.randomBytes)(o2), l4 = e9(r4, c3, a2).encrypt(i3);
    if (0 === s2) return (0, t3.concatBytes)(c3, l4);
    var d3 = l4.length - s2, u2 = l4.subarray(0, d3), h3 = l4.subarray(d3);
    return (0, t3.concatBytes)(c3, h3, u2);
  }
  function l3(e9, n3, r4, i3, o2, s2) {
    var a2 = r4.subarray(0, i3), c3 = e9(n3, Uint8Array.from(a2), s2), l4 = r4.subarray(i3);
    if (0 === o2) return c3.decrypt(l4);
    var d3 = l4.subarray(0, o2), u2 = l4.subarray(o2);
    return c3.decrypt((0, t3.concatBytes)(u2, d3));
  }
  e8.symDecrypt = function(e9, t4, n3) {
    return a(l3, e9, t4, n3);
  }, e8.aesEncrypt = e8.symEncrypt, e8.aesDecrypt = e8.symDecrypt;
}(_r), Fi = Me, zi = de && de.__createBinding || (Object.create ? function(e8, t3, n2, r3) {
  void 0 === r3 && (r3 = n2);
  var i2 = Object.getOwnPropertyDescriptor(t3, n2);
  i2 && !("get" in i2 ? !t3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
    return t3[n2];
  } }), Object.defineProperty(e8, r3, i2);
} : function(e8, t3, n2, r3) {
  void 0 === r3 && (r3 = n2), e8[r3] = t3[n2];
}), qi = de && de.__exportStar || function(e8, t3) {
  for (var n2 in e8) "default" === n2 || Object.prototype.hasOwnProperty.call(t3, n2) || zi(t3, e8, n2);
}, Object.defineProperty(Fi, "__esModule", { value: true }), qi(Ie, Fi), qi(pr, Fi), qi(fr, Fi), qi(_r, Fi);
var Vi = {};
Object.defineProperty(Vi, "__esModule", { value: true }), Vi.PublicKey = void 0;
var Gi = pe;
var Yi = Me;
var Zi = function() {
  function e8(e9) {
    this.data = (0, Yi.convertPublicKeyFormat)(e9, true);
  }
  return e8.fromHex = function(t3) {
    return new e8((0, Yi.hexToPublicKey)(t3));
  }, Object.defineProperty(e8.prototype, "uncompressed", { get: function() {
    return C.from((0, Yi.convertPublicKeyFormat)(this.data, false));
  }, enumerable: false, configurable: true }), Object.defineProperty(e8.prototype, "compressed", { get: function() {
    return C.from(this.data);
  }, enumerable: false, configurable: true }), e8.prototype.toHex = function(e9) {
    return void 0 === e9 && (e9 = true), (0, Gi.bytesToHex)(e9 ? this.data : this.uncompressed);
  }, e8.prototype.decapsulate = function(e9, t3) {
    void 0 === t3 && (t3 = false);
    var n2 = t3 ? this.data : this.uncompressed, r3 = e9.multiply(this, t3);
    return (0, Yi.getSharedKey)(n2, r3);
  }, e8.prototype.equals = function(e9) {
    return (0, Gi.equalBytes)(this.data, e9.data);
  }, e8;
}();
Vi.PublicKey = Zi, Object.defineProperty(xe, "__esModule", { value: true }), xe.PrivateKey = void 0;
var Ji = pe;
var Qi = Me;
var Xi = Vi;
var eo = function() {
  function e8(e9) {
    if (void 0 === e9) this.data = (0, Qi.getValidSecret)();
    else {
      if (!(0, Qi.isValidPrivateKey)(e9)) throw new Error("Invalid private key");
      this.data = e9;
    }
    this.publicKey = new Xi.PublicKey((0, Qi.getPublicKey)(this.data));
  }
  return e8.fromHex = function(t3) {
    return new e8((0, Qi.decodeHex)(t3));
  }, Object.defineProperty(e8.prototype, "secret", { get: function() {
    return C.from(this.data);
  }, enumerable: false, configurable: true }), e8.prototype.toHex = function() {
    return (0, Ji.bytesToHex)(this.data);
  }, e8.prototype.encapsulate = function(e9, t3) {
    void 0 === t3 && (t3 = false);
    var n2 = t3 ? this.publicKey.compressed : this.publicKey.uncompressed, r3 = this.multiply(e9, t3);
    return (0, Qi.getSharedKey)(n2, r3);
  }, e8.prototype.multiply = function(e9, t3) {
    return void 0 === t3 && (t3 = false), (0, Qi.getSharedPoint)(this.data, e9.compressed, t3);
  }, e8.prototype.equals = function(e9) {
    return (0, Ji.equalBytes)(this.data, e9.data);
  }, e8;
}();
xe.PrivateKey = eo, function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.PublicKey = e8.PrivateKey = void 0;
  var t3 = xe;
  Object.defineProperty(e8, "PrivateKey", { enumerable: true, get: function() {
    return t3.PrivateKey;
  } });
  var n2 = Vi;
  Object.defineProperty(e8, "PublicKey", { enumerable: true, get: function() {
    return n2.PublicKey;
  } });
}(Ae), function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.utils = e8.PublicKey = e8.PrivateKey = e8.ECIES_CONFIG = void 0, e8.encrypt = function(e9, o2) {
    var s2 = new r3.PrivateKey(), a = e9 instanceof Uint8Array ? new r3.PublicKey(e9) : r3.PublicKey.fromHex(e9), c2 = s2.encapsulate(a, (0, n2.isHkdfKeyCompressed)()), l3 = (0, n2.isEphemeralKeyCompressed)() ? s2.publicKey.compressed : s2.publicKey.uncompressed, d3 = (0, i2.symEncrypt)(c2, o2);
    return C.from((0, t3.concatBytes)(l3, d3));
  }, e8.decrypt = function(e9, t4) {
    var o2 = e9 instanceof Uint8Array ? new r3.PrivateKey(e9) : r3.PrivateKey.fromHex(e9), s2 = (0, n2.ephemeralKeySize)(), a = new r3.PublicKey(t4.subarray(0, s2)), c2 = t4.subarray(s2), l3 = a.decapsulate(o2, (0, n2.isHkdfKeyCompressed)());
    return C.from((0, i2.symDecrypt)(l3, c2));
  };
  var t3 = pe, n2 = Ce, r3 = Ae, i2 = Me;
  var o = Ce;
  Object.defineProperty(e8, "ECIES_CONFIG", { enumerable: true, get: function() {
    return o.ECIES_CONFIG;
  } });
  var s = Ae;
  Object.defineProperty(e8, "PrivateKey", { enumerable: true, get: function() {
    return s.PrivateKey;
  } }), Object.defineProperty(e8, "PublicKey", { enumerable: true, get: function() {
    return s.PublicKey;
  } }), e8.utils = { aesEncrypt: i2.aesEncrypt, aesDecrypt: i2.aesDecrypt, symEncrypt: i2.symEncrypt, symDecrypt: i2.symDecrypt, decodeHex: i2.decodeHex, getValidSecret: i2.getValidSecret, remove0x: i2.remove0x };
}(fe);
var to = (0, import_debug.default)("KeyExchange:Layer");
var no = (0, import_debug.default)("SocketService:Layer");
var ro = (0, import_debug.default)("Ecies:Layer");
var io = (0, import_debug.default)("RemoteCommunication:Layer");
to.color = "##95c44e", no.color = "#f638d7", ro.color = "#465b9c", io.color = "#47a2be";
var oo = { KeyExchange: to, SocketService: no, Ecies: ro, RemoteCommunication: io };
var so;
var ao = [];
var co = [];
var lo = (t3, n2) => c(void 0, void 0, void 0, function* () {
  so = n2, co.push(t3), function(t4) {
    return c(this, void 0, void 0, function* () {
      if (!so || !t4) return;
      !function() {
        const e8 = co;
        co = ao, ao = e8;
      }();
      const n3 = so.endsWith("/") ? `${so}evt` : `${so}/evt`, r3 = Object.assign({}, t4);
      if (delete r3.params, t4.params) for (const [e8, n4] of Object.entries(t4.params)) r3[e8] = n4;
      const i2 = JSON.stringify(r3);
      oo.RemoteCommunication(`[sendBufferedEvents] Sending ${ao.length} analytics events to ${n3}`);
      try {
        const t5 = yield (0, import_cross_fetch.default)(n3, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: i2 }), r4 = yield t5.text();
        oo.RemoteCommunication(`[sendBufferedEvents] Response: ${r4}`), ao.length = 0;
      } catch (n4) {
      }
    });
  }(t3).catch(() => {
  });
});
var uo = class {
  constructor(e8) {
    this.enabled = true, (null == e8 ? void 0 : e8.debug) && import_debug.default.enable("Ecies:Layer"), this.ecies = (null == e8 ? void 0 : e8.privateKey) ? fe.PrivateKey.fromHex(e8.privateKey) : new fe.PrivateKey(), oo.Ecies("[ECIES constructor()] initialized secret: ", this.ecies.toHex()), oo.Ecies("[ECIES constructor()] initialized public: ", this.ecies.publicKey.toHex()), oo.Ecies("[ECIES constructor()] init with", this);
  }
  generateECIES() {
    this.ecies = new fe.PrivateKey();
  }
  getPublicKey() {
    return this.ecies.publicKey.toHex();
  }
  encrypt(e8, t3) {
    let n2 = e8;
    if (this.enabled) try {
      oo.Ecies("[ECIES: encrypt()] using otherPublicKey", t3);
      const r3 = C.from(e8), i2 = fe.encrypt(t3, r3);
      n2 = C.from(i2).toString("base64");
    } catch (n3) {
      throw oo.Ecies("[ECIES: encrypt()] error encrypt:", n3), oo.Ecies("[ECIES: encrypt()] private: ", this.ecies.toHex()), oo.Ecies("[ECIES: encrypt()] data: ", e8), oo.Ecies("[ECIES: encrypt()] otherkey: ", t3), n3;
    }
    return n2;
  }
  decrypt(e8) {
    let t3 = e8;
    if (this.enabled) try {
      oo.Ecies("[ECIES: decrypt()] using privateKey", this.ecies.toHex());
      const n2 = C.from(e8.toString(), "base64");
      t3 = fe.decrypt(this.ecies.toHex(), n2).toString();
    } catch (t4) {
      throw oo.Ecies("[ECIES: decrypt()] error decrypt", t4), oo.Ecies("[ECIES: decrypt()] private: ", this.ecies.toHex()), oo.Ecies("[ECIES: decrypt()] encryptedData: ", e8), t4;
    }
    return t3;
  }
  getKeyInfo() {
    return { private: this.ecies.toHex(), public: this.ecies.publicKey.toHex() };
  }
  toString() {
    oo.Ecies("[ECIES: toString()]", this.getKeyInfo());
  }
};
var ho = { name: "@metamask/sdk-communication-layer", version: "0.33.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk.git", directory: "packages/sdk-communication-layer" }, main: "dist/node/cjs/metamask-sdk-communication-layer.js", unpkg: "dist/browser/umd/metamask-sdk-communication-layer.js", module: "dist/node/es/metamask-sdk-communication-layer.js", browser: "dist/browser/es/metamask-sdk-communication-layer.js", "react-native": "dist/react-native/es/metamask-sdk-communication-layer.js", types: "dist/types/src/index.d.ts", files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", "build:clean": "yarn clean && yarn build", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs", dev: 'concurrently "tsc --watch" "rollup -c --bundleConfigAsCjs -w"', "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", size: "size-limit", clean: "rimraf ./dist", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk-communication-layer", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", "publish:preview": "yarn npm publish --tag preview", prepack: "../../scripts/prepack.sh", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:coverage": "jest --coverage", "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": "jest", watch: "rollup -c --bundleConfigAsCjs -w" }, dependencies: { "@metamask/sdk-analytics": "workspace:*", bufferutil: "^4.0.8", "date-fns": "^2.29.3", debug: "^4.3.4", "utf-8-validate": "^5.0.2", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@rollup/plugin-commonjs": "^25.0.0", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.4", "@size-limit/preset-big-lib": "^11.0.2", "@types/jest": "^29.2.4", "@types/node": "^20.1.3", "@types/uuid": "^9.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", concurrently: "^9.1.2", "cross-fetch": "^4.0.0", eciesjs: "^0.4.11", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", eventemitter2: "^6.4.9", jest: "^29.3.1", prettier: "^2.3.0", rimraf: "^3.0.2", rollup: "^4.26.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-node-globals": "^1.4.0", "rollup-plugin-peer-deps-external": "^2.2.4", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.1.6", "socket.io-client": "^4.5.1", "stream-browserify": "^3.0.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^5.6.3" }, peerDependencies: { "cross-fetch": "^4.0.0", eciesjs: "*", eventemitter2: "^6.4.9", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "@lavamoat/preinstall-always-fail": false, canvas: true, "eciesjs>secp256k1": false, "socket.io-client>engine.io-client>ws>bufferutil": false, "socket.io-client>engine.io-client>ws>utf-8-validate": false, bufferutil: false, "utf-8-validate": false } } };
var fo = "https://metamask-sdk.api.cx.metamask.io/";
var po = ["websocket"];
var go = 6048e5;
var mo = 3e3;
var yo = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_SWITCHETHEREUMCHAIN: "wallet_switchEthereumChain", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" };
var vo = [yo.METAMASK_CONNECTSIGN, yo.METAMASK_CONNECTWITH, yo.METAMASK_OPEN, yo.METAMASK_BATCH, yo.PERSONAL_SIGN, yo.WALLET_REQUESTPERMISSIONS, yo.WALLET_REVOKEPERMISSIONS, yo.WALLET_WATCHASSET, yo.ETH_SENDTRANSACTION, yo.ETH_SIGNTYPEDDATA, yo.ETH_SIGNTYPEDDATA_V3, yo.ETH_SIGNTYPEDDATA_V4, yo.ETH_SIGNTRANSACTION, yo.ETH_SIGN, yo.PERSONAL_EC_RECOVER];
function bo(e8) {
  return vo.includes(e8);
}
function wo(e8) {
  const { context: t3 } = e8;
  oo.RemoteCommunication(`[RemoteCommunication: clean()] context=${t3}`), e8.channelConfig = void 0, e8.ready = false, e8.originatorConnectStarted = false;
}
var Eo;
var So;
var _o;
var Co;
var ko;
var Ao;
var xo;
(xo = Eo || (Eo = {})).DISCONNECTED = "disconnected", xo.WAITING = "waiting", xo.TIMEOUT = "timeout", xo.LINKED = "linked", xo.PAUSED = "paused", xo.TERMINATED = "terminated", function(e8) {
  e8.KEY_INFO = "key_info", e8.SERVICE_STATUS = "service_status", e8.PROVIDER_UPDATE = "provider_update", e8.RPC_UPDATE = "rpc_update", e8.KEYS_EXCHANGED = "keys_exchanged", e8.JOIN_CHANNEL = "join_channel", e8.PUBLIC_KEY = "public_key", e8.CHANNEL_CREATED = "channel_created", e8.CLIENTS_CONNECTED = "clients_connected", e8.CLIENTS_DISCONNECTED = "clients_disconnected", e8.CLIENTS_WAITING = "clients_waiting", e8.CLIENTS_READY = "clients_ready", e8.REJECTED = "rejected", e8.WALLET_INIT = "wallet_init", e8.CHANNEL_PERSISTENCE = "channel_persistence", e8.CONFIG = "config", e8.MESSAGE_ACK = "ack", e8.SOCKET_DISCONNECTED = "socket_disconnected", e8.SOCKET_RECONNECT = "socket_reconnect", e8.OTP = "otp", e8.SDK_RPC_CALL = "sdk_rpc_call", e8.AUTHORIZED = "authorized", e8.CONNECTION_STATUS = "connection_status", e8.MESSAGE = "message", e8.TERMINATE = "terminate";
}(So || (So = {})), (_o || (_o = {})).KEY_EXCHANGE = "key_exchange", function(e8) {
  e8.KEY_HANDSHAKE_START = "key_handshake_start", e8.KEY_HANDSHAKE_CHECK = "key_handshake_check", e8.KEY_HANDSHAKE_SYN = "key_handshake_SYN", e8.KEY_HANDSHAKE_SYNACK = "key_handshake_SYNACK", e8.KEY_HANDSHAKE_ACK = "key_handshake_ACK", e8.KEY_HANDSHAKE_WALLET = "key_handshake_wallet", e8.KEY_HANDSHAKE_NONE = "none";
}(Co || (Co = {}));
var Mo = class extends import_eventemitter2.EventEmitter2 {
  constructor({ communicationLayer: e8, otherPublicKey: t3, context: n2, ecies: r3, logging: i2 }) {
    super(), this.keysExchanged = false, this.step = Co.KEY_HANDSHAKE_NONE, this.debug = false, this.context = n2, this.communicationLayer = e8, (null == r3 ? void 0 : r3.privateKey) && t3 && (oo.KeyExchange(`[KeyExchange: constructor()] otherPubKey=${t3} set keysExchanged to true!`, r3), this.keysExchanged = true), this.myECIES = new uo(Object.assign(Object.assign({}, r3), { debug: null == i2 ? void 0 : i2.eciesLayer })), this.communicationLayer.state.eciesInstance = this.myECIES, this.myPublicKey = this.myECIES.getPublicKey(), this.debug = true === (null == i2 ? void 0 : i2.keyExchangeLayer), t3 && this.setOtherPublicKey(t3), this.communicationLayer.on(_o.KEY_EXCHANGE, this.onKeyExchangeMessage.bind(this));
  }
  onKeyExchangeMessage(e8) {
    const { relayPersistence: t3 } = this.communicationLayer.remote.state;
    if (oo.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${t3}`, e8), t3) return void oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated");
    const { message: n2 } = e8;
    this.keysExchanged && oo.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`), this.emit(So.KEY_INFO, n2.type), n2.type === Co.KEY_HANDSHAKE_SYN ? (this.checkStep([Co.KEY_HANDSHAKE_NONE, Co.KEY_HANDSHAKE_ACK]), oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN", n2), n2.pubkey && this.setOtherPublicKey(n2.pubkey), this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey }).catch((e9) => {
      oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK", e9);
    }), this.setStep(Co.KEY_HANDSHAKE_ACK)) : n2.type === Co.KEY_HANDSHAKE_SYNACK ? (this.checkStep([Co.KEY_HANDSHAKE_SYNACK, Co.KEY_HANDSHAKE_ACK, Co.KEY_HANDSHAKE_NONE]), oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"), n2.pubkey && this.setOtherPublicKey(n2.pubkey), this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_ACK }).catch((e9) => {
      oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK", e9);
    }), this.keysExchanged = true, this.setStep(Co.KEY_HANDSHAKE_ACK), this.emit(So.KEYS_EXCHANGED)) : n2.type === Co.KEY_HANDSHAKE_ACK && (oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"), this.checkStep([Co.KEY_HANDSHAKE_ACK, Co.KEY_HANDSHAKE_NONE]), this.keysExchanged = true, this.setStep(Co.KEY_HANDSHAKE_ACK), this.emit(So.KEYS_EXCHANGED));
  }
  resetKeys(e8) {
    this.clean(), this.myECIES = new uo(e8);
  }
  clean() {
    oo.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`), this.setStep(Co.KEY_HANDSHAKE_NONE), this.emit(So.KEY_INFO, this.step), this.keysExchanged = false;
  }
  start({ isOriginator: e8, force: t3 }) {
    const { relayPersistence: n2, protocolVersion: r3 } = this.communicationLayer.remote.state, i2 = r3 >= 2;
    n2 ? oo.KeyExchange("[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated") : (oo.KeyExchange(`[KeyExchange: start()] context=${this.context} protocolVersion=${r3} isOriginator=${e8} step=${this.step} force=${t3} relayPersistence=${n2} keysExchanged=${this.keysExchanged}`), e8 ? !(this.keysExchanged || this.step !== Co.KEY_HANDSHAKE_NONE && this.step !== Co.KEY_HANDSHAKE_SYNACK) || t3 ? (oo.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${t3}) -- step=${this.step}`, this.step), this.clean(), this.setStep(Co.KEY_HANDSHAKE_SYNACK), this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_SYN, pubkey: this.myPublicKey, v: 2 }).catch((e9) => {
      oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN", e9);
    })) : oo.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged ? "done" : "in progress"} -- aborted.`, this.step) : this.keysExchanged && true !== t3 ? oo.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done.") : i2 ? this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey, v: 2 }).catch((e9) => {
      oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK", e9);
    }) : (this.communicationLayer.sendMessage({ type: Co.KEY_HANDSHAKE_START }).catch((e9) => {
      oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_START", e9);
    }), this.clean()));
  }
  setStep(e8) {
    this.step = e8, this.emit(So.KEY_INFO, e8);
  }
  checkStep(e8) {
    e8.length > 0 && e8.indexOf(this.step.toString());
  }
  setRelayPersistence({ localKey: e8, otherKey: t3 }) {
    this.otherPublicKey = t3, this.myECIES = new uo({ privateKey: e8, debug: this.debug }), this.keysExchanged = true;
  }
  setKeysExchanged(e8) {
    this.keysExchanged = e8;
  }
  areKeysExchanged() {
    return this.keysExchanged;
  }
  getMyPublicKey() {
    return this.myPublicKey;
  }
  getOtherPublicKey() {
    return this.otherPublicKey;
  }
  setOtherPublicKey(e8) {
    oo.KeyExchange("[KeyExchange: setOtherPubKey()]", e8), this.otherPublicKey = e8;
  }
  encryptMessage(e8) {
    if (!this.otherPublicKey) throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.encrypt(e8, this.otherPublicKey);
  }
  decryptMessage(e8) {
    if (!this.otherPublicKey) throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.decrypt(e8);
  }
  getKeyInfo() {
    return { ecies: Object.assign(Object.assign({}, this.myECIES.getKeyInfo()), { otherPubKey: this.otherPublicKey }), step: this.step, keysExchanged: this.areKeysExchanged() };
  }
  toString() {
    const e8 = { keyInfo: this.getKeyInfo(), keysExchanged: this.keysExchanged, step: this.step };
    return JSON.stringify(e8);
  }
};
!function(e8) {
  e8.TERMINATE = "terminate", e8.ANSWER = "answer", e8.OFFER = "offer", e8.CANDIDATE = "candidate", e8.JSONRPC = "jsonrpc", e8.WALLET_INFO = "wallet_info", e8.WALLET_INIT = "wallet_init", e8.ORIGINATOR_INFO = "originator_info", e8.PAUSE = "pause", e8.OTP = "otp", e8.AUTHORIZED = "authorized", e8.PING = "ping", e8.READY = "ready";
}(ko || (ko = {})), function(e8) {
  e8.REQUEST = "sdk_connect_request_started", e8.REQUEST_MOBILE = "sdk_connect_request_started_mobile", e8.RECONNECT = "sdk_reconnect_request_started", e8.CONNECTED = "sdk_connection_established", e8.CONNECTED_MOBILE = "sdk_connection_established_mobile", e8.AUTHORIZED = "sdk_connection_authorized", e8.REJECTED = "sdk_connection_rejected", e8.TERMINATED = "sdk_connection_terminated", e8.DISCONNECTED = "sdk_disconnected", e8.SDK_USE_EXTENSION = "sdk_use_extension", e8.SDK_RPC_REQUEST = "sdk_rpc_request", e8.SDK_RPC_REQUEST_RECEIVED = "sdk_rpc_request_received", e8.SDK_RPC_REQUEST_DONE = "sdk_rpc_request_done", e8.SDK_EXTENSION_UTILIZED = "sdk_extension_utilized", e8.SDK_USE_INAPP_BROWSER = "sdk_use_inapp_browser";
}(Ao || (Ao = {}));
var Io = (e8, t3, n2) => c(void 0, void 0, void 0, function* () {
  var r3, i2, o, s, a, c2;
  const { remote: l3, state: d3 } = e8, { channelId: u2, isOriginator: h3 } = d3;
  if ("error_terminated" === t3) return oo.SocketService(`handleJoinChannelResults: Channel ${u2} terminated`), void e8.emit(So.TERMINATE);
  if (!n2) return void oo.SocketService(`handleJoinChannelResults: No result for channel ${u2}`);
  const { persistence: f2, walletKey: p3, rejected: g3 } = n2;
  if (oo.SocketService(`handleJoinChannelResults: Channel ${u2} persistence=${f2} walletKey=${p3} rejected=${g3}`), g3) return oo.SocketService(`handleJoinChannelResults: Channel ${u2} rejected`), yield e8.remote.disconnect({ terminate: true }), e8.remote.emit(So.REJECTED, { channelId: u2 }), void e8.remote.emitServiceStatusEvent();
  if (p3 && !(null === (r3 = l3.state.channelConfig) || void 0 === r3 ? void 0 : r3.otherKey)) {
    e8.getKeyExchange().setOtherPublicKey(p3), null === (i2 = e8.state.keyExchange) || void 0 === i2 || i2.setKeysExchanged(true), l3.state.ready = true, l3.state.authorized = true, l3.emit(So.AUTHORIZED);
    const { communicationLayer: t4, storageManager: n3 } = l3.state, r4 = Object.assign(Object.assign({}, l3.state.channelConfig), { channelId: null !== (o = l3.state.channelId) && void 0 !== o ? o : "", validUntil: Date.now() + go, localKey: null == t4 ? void 0 : t4.getKeyInfo().ecies.private, otherKey: p3 });
    e8.sendMessage({ type: Co.KEY_HANDSHAKE_ACK }).catch((e9) => {
    }), null === (s = e8.state.socket) || void 0 === s || s.emit(ko.PING, { id: u2, clientType: h3 ? "dapp" : "wallet", context: "on_channel_reconnect", message: "" }), yield null == n3 ? void 0 : n3.persistChannelConfig(r4), l3.emitServiceStatusEvent(), l3.setConnectionStatus(Eo.LINKED);
  }
  f2 && (e8.emit(So.CHANNEL_PERSISTENCE), null === (a = e8.state.keyExchange) || void 0 === a || a.setKeysExchanged(true), l3.state.ready = true, l3.state.authorized = true, l3.emit(So.AUTHORIZED), lo(Object.assign(Object.assign({ id: null != u2 ? u2 : "", event: h3 ? Ao.CONNECTED : Ao.CONNECTED_MOBILE }, e8.remote.state.originatorInfo), { sdkVersion: e8.remote.state.sdkVersion, commLayer: e8.state.communicationLayerPreference, commLayerVersion: ho.version, walletVersion: null === (c2 = e8.remote.state.walletInfo) || void 0 === c2 ? void 0 : c2.version }), d3.communicationServerUrl).catch((e9) => {
  }));
});
var To = (e8) => new Promise((t3) => {
  setTimeout(t3, e8);
});
var Ro = (e8, t3, ...n2) => c(void 0, [e8, t3, ...n2], void 0, function* (e9, t4, n3 = 200) {
  let r3;
  const i2 = Date.now();
  let o = false;
  for (; !o; ) {
    if (o = Date.now() - i2 > 3e5, r3 = t4[e9], void 0 !== r3.elapsedTime) return r3;
    yield To(n3);
  }
  throw new Error(`RPC ${e9} timed out`);
});
var Po = (e8) => c(void 0, void 0, void 0, function* () {
  const { state: t3 } = e8, { socket: n2, channelId: r3, context: i2, isOriginator: o, isReconnecting: s } = t3;
  if (s) return oo.SocketService("[SocketService: reconnectSocket()] Reconnection already in progress, skipping", e8), false;
  if (!n2) return oo.SocketService("[SocketService: reconnectSocket()] socket is not defined", e8), false;
  if (!r3) return false;
  const { connected: a } = n2;
  t3.isReconnecting = true, t3.reconnectionAttempts = 0, oo.SocketService(`[SocketService: reconnectSocket()] connected=${a} trying to reconnect after socketio disconnection`, e8);
  try {
    for (; 3 > t3.reconnectionAttempts; ) {
      if (oo.SocketService(`[SocketService: reconnectSocket()] Attempt ${t3.reconnectionAttempts + 1} of 3`, e8), yield To(200), n2.connected) return oo.SocketService("Socket already connected --- ping to retrieve messages"), n2.emit(ko.PING, { id: r3, clientType: o ? "dapp" : "wallet", context: "on_channel_config", message: "" }), true;
      t3.resumed = true, n2.connect(), e8.emit(So.SOCKET_RECONNECT);
      try {
        if (yield new Promise((t4, s2) => {
          n2.emit(So.JOIN_CHANNEL, { channelId: r3, context: `${i2}connect_again`, clientType: o ? "dapp" : "wallet" }, (n3, r4) => c(void 0, void 0, void 0, function* () {
            try {
              yield Io(e8, n3, r4), t4();
            } catch (e9) {
              s2(e9);
            }
          }));
        }), yield To(100), n2.connected) return oo.SocketService(`Reconnection successful on attempt ${t3.reconnectionAttempts + 1}`), true;
      } catch (e9) {
        oo.SocketService(`Error during reconnection attempt ${t3.reconnectionAttempts + 1}:`, e9);
      }
      t3.reconnectionAttempts += 1, 3 > t3.reconnectionAttempts && (yield To(200));
    }
    return oo.SocketService("Failed to reconnect after 3 attempts"), false;
  } finally {
    t3.isReconnecting = false, t3.reconnectionAttempts = 0;
  }
});
function Oo(e8, t3) {
  return c(this, void 0, void 0, function* () {
    var n2;
    const r3 = null === (n2 = e8.state.keyExchange) || void 0 === n2 ? void 0 : n2.encryptMessage(JSON.stringify(t3)), i2 = { id: e8.state.channelId, context: e8.state.context, clientType: e8.state.isOriginator ? "dapp" : "wallet", message: r3, plaintext: e8.state.hasPlaintext ? JSON.stringify(t3) : void 0 };
    return oo.SocketService(`[SocketService: encryptAndSendMessage()] context=${e8.state.context}`, i2), t3.type === ko.TERMINATE && (e8.state.manualDisconnect = true), new Promise((t4, n3) => {
      var r4;
      null === (r4 = e8.state.socket) || void 0 === r4 || r4.emit(So.MESSAGE, i2, (e9, r5) => {
        var i3;
        e9 && (oo.SocketService(`[SocketService: encryptAndSendMessage()] error=${e9}`), n3(e9)), oo.SocketService("[encryptAndSendMessage] response", r5), t4(null !== (i3 = null == r5 ? void 0 : r5.success) && void 0 !== i3 && i3);
      });
    });
  });
}
var No;
!function(e8) {
  e8.RPC_CHECK = "rpcCheck", e8.SKIPPED_RPC = "skippedRpc";
}(No || (No = {}));
var Lo = ["eth_sendTransaction", "eth_signTypedData", "eth_signTransaction", "personal_sign", "wallet_requestPermissions", "wallet_switchEthereumChain", "eth_signTypedData_v3", "eth_signTypedData_v4", "metamask_connectSign", "metamask_connectWith", "metamask_batch"].map((e8) => e8.toLowerCase());
var Do = [{ event: So.CLIENTS_CONNECTED, handler: function(e8, t3) {
  return (n2) => c(this, void 0, void 0, function* () {
    var n3, r3, i2, o, s, a, c2, l3, d3, u2, h3;
    const f2 = null !== (r3 = null === (n3 = e8.remote.state.channelConfig) || void 0 === n3 ? void 0 : n3.relayPersistence) && void 0 !== r3 && r3;
    if (oo.SocketService(`[SocketService: handleClientsConnected()] context=${e8.state.context} on 'clients_connected-${t3}' relayPersistence=${f2} resumed=${e8.state.resumed}  clientsPaused=${e8.state.clientsPaused} keysExchanged=${null === (i2 = e8.state.keyExchange) || void 0 === i2 ? void 0 : i2.areKeysExchanged()} isOriginator=${e8.state.isOriginator}`), e8.emit(So.CLIENTS_CONNECTED, { isOriginator: e8.state.isOriginator, keysExchanged: null === (o = e8.state.keyExchange) || void 0 === o ? void 0 : o.areKeysExchanged(), context: e8.state.context }), e8.state.resumed) e8.state.isOriginator || (oo.SocketService(`[SocketService: handleClientsConnected()] context=${e8.state.context} 'clients_connected' / keysExchanged=${null === (s = e8.state.keyExchange) || void 0 === s ? void 0 : s.areKeysExchanged()} -- backward compatibility`), null === (a = e8.state.keyExchange) || void 0 === a || a.start({ isOriginator: null !== (c2 = e8.state.isOriginator) && void 0 !== c2 && c2 })), e8.state.resumed = false;
    else if (e8.state.clientsPaused) oo.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause");
    else if (!e8.state.isOriginator) {
      const t4 = !f2;
      oo.SocketService(`[SocketService: handleClientsConnected()] context=${e8.state.context} on 'clients_connected' / keysExchanged=${null === (l3 = e8.state.keyExchange) || void 0 === l3 ? void 0 : l3.areKeysExchanged()} -- force=${t4} -- backward compatibility`), oo.SocketService(`[SocketService: handleClientsConnected()] context=${e8.state.context} on 'clients_connected' / keysExchanged=${null === (d3 = e8.state.keyExchange) || void 0 === d3 ? void 0 : d3.areKeysExchanged()} -- force=${t4} -- backward compatibility`), null === (u2 = e8.state.keyExchange) || void 0 === u2 || u2.start({ isOriginator: null !== (h3 = e8.state.isOriginator) && void 0 !== h3 && h3, force: t4 });
    }
    e8.state.clientsConnected = true, e8.state.clientsPaused = false;
  });
} }, { event: So.CHANNEL_CREATED, handler: function(e8, t3) {
  return (n2) => {
    oo.SocketService(`[SocketService: handleChannelCreated()] context=${e8.state.context} on 'channel_created-${t3}'`, n2), e8.emit(So.CHANNEL_CREATED, n2);
  };
} }, { event: So.CLIENTS_DISCONNECTED, handler: function(e8, t3) {
  return () => {
    var n2;
    e8.state.clientsConnected = false, oo.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e8.state.context} on 'clients_disconnected-${t3}'`), e8.remote.state.relayPersistence ? oo.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e8.state.context} on 'clients_disconnected-${t3}' - relayPersistence enabled, skipping key exchange cleanup.`) : (e8.state.isOriginator && !e8.state.clientsPaused && (null === (n2 = e8.state.keyExchange) || void 0 === n2 || n2.clean()), e8.emit(So.CLIENTS_DISCONNECTED, t3));
  };
} }, { event: So.CONFIG, handler: function(e8, t3) {
  return (n2) => c(this, void 0, void 0, function* () {
    var r3, i2, o;
    oo.SocketService(`[SocketService: handleChannelConfig()] update relayPersistence on 'config-${t3}'`, n2);
    const { persistence: s, walletKey: a } = n2;
    e8.state.isOriginator && e8.remote.state.channelConfig ? (n2.walletKey && !e8.remote.state.channelConfig.otherKey && (oo.SocketService(`Setting wallet key ${a}`), e8.remote.state.channelConfig.otherKey = a, e8.getKeyExchange().setOtherPublicKey(n2.walletKey), null === (r3 = e8.state.keyExchange) || void 0 === r3 || r3.setKeysExchanged(true), yield e8.remote.sendMessage({ type: Co.KEY_HANDSHAKE_ACK }), yield e8.remote.sendMessage({ type: ko.PING }), yield null === (i2 = e8.remote.state.storageManager) || void 0 === i2 ? void 0 : i2.persistChannelConfig(e8.remote.state.channelConfig)), true !== s || e8.remote.state.channelConfig.relayPersistence || (oo.SocketService(`Setting relay persistence ${s}`), e8.remote.state.channelConfig.relayPersistence = s, e8.remote.state.relayPersistence = true, e8.remote.emit(So.CHANNEL_PERSISTENCE), e8.remote.state.authorized = true, e8.remote.state.ready = true, e8.remote.emit(So.AUTHORIZED), yield null === (o = e8.remote.state.storageManager) || void 0 === o ? void 0 : o.persistChannelConfig(e8.remote.state.channelConfig))) : e8.state.isOriginator || n2.persistence && (e8.remote.state.relayPersistence = true, e8.remote.emit(So.CHANNEL_PERSISTENCE));
  });
} }, { event: So.MESSAGE, handler: function(e8, t3) {
  return (r3) => {
    var i2, o, s, a, c2, l3, d3, u2, h3, f2, p3, g3, m2, y3, v2, b3, w2, E2;
    const { ackId: S3, message: _3, error: C3 } = r3, k3 = null !== (i2 = e8.remote.state.relayPersistence) && void 0 !== i2 && i2;
    if (oo.SocketService(`[SocketService handleMessage()]  relayPersistence=${k3}  context=${e8.state.context} on 'message' ${t3} keysExchanged=${null === (o = e8.state.keyExchange) || void 0 === o ? void 0 : o.areKeysExchanged()}`, r3), C3) throw oo.SocketService(`
      [SocketService handleMessage()] context=${e8.state.context}::on 'message' error=${C3}`), new Error(C3);
    const A3 = "string" == typeof _3;
    if (!A3 && (null == _3 ? void 0 : _3.type) === Co.KEY_HANDSHAKE_START) {
      if (k3) return;
      return oo.SocketService(`[SocketService handleMessage()] context=${e8.state.context}::on 'message' received HANDSHAKE_START isOriginator=${e8.state.isOriginator}`, _3), void (null === (s = e8.state.keyExchange) || void 0 === s || s.start({ isOriginator: null !== (a = e8.state.isOriginator) && void 0 !== a && a, force: true }));
    }
    if (!A3 && (null === (c2 = null == _3 ? void 0 : _3.type) || void 0 === c2 ? void 0 : c2.startsWith("key_handshake"))) {
      if (k3) return;
      return oo.SocketService(`[SocketService handleMessage()] context=${e8.state.context}::on 'message' emit KEY_EXCHANGE`, _3), void e8.emit(_o.KEY_EXCHANGE, { message: _3, context: e8.state.context });
    }
    if (A3 && !(null === (l3 = e8.state.keyExchange) || void 0 === l3 ? void 0 : l3.areKeysExchanged())) {
      let t4 = false;
      try {
        oo.SocketService(`[SocketService handleMessage()] context=${e8.state.context}::on 'message' trying to decrypt message`), null === (d3 = e8.state.keyExchange) || void 0 === d3 || d3.decryptMessage(_3), t4 = true;
      } catch (t5) {
        oo.SocketService(`[SocketService handleMessage()] context=${e8.state.context}::on 'message' error`, t5);
      }
      if (!t4) return e8.state.isOriginator ? null === (h3 = e8.state.keyExchange) || void 0 === h3 || h3.start({ isOriginator: null !== (f2 = e8.state.isOriginator) && void 0 !== f2 && f2 }) : e8.sendMessage({ type: Co.KEY_HANDSHAKE_START }).catch((e9) => {
      }), void oo.SocketService(`Message ignored because invalid key exchange status. step=${null === (p3 = e8.state.keyExchange) || void 0 === p3 ? void 0 : p3.getKeyInfo().step}`, null === (g3 = e8.state.keyExchange) || void 0 === g3 ? void 0 : g3.getKeyInfo(), _3);
      oo.SocketService("Invalid key exchange status detected --- updating it."), null === (u2 = e8.state.keyExchange) || void 0 === u2 || u2.setKeysExchanged(true);
    } else if (!A3 && (null == _3 ? void 0 : _3.type)) return void e8.emit(So.MESSAGE, _3);
    if (!A3) return void e8.emit(So.MESSAGE, _3);
    const x3 = null === (m2 = e8.state.keyExchange) || void 0 === m2 ? void 0 : m2.decryptMessage(_3), M3 = JSON.parse(null != x3 ? x3 : "{}");
    if (S3 && (null == S3 ? void 0 : S3.length) > 0 && (oo.SocketService(`[SocketService handleMessage()] context=${e8.state.context}::on 'message' ackid=${S3} channelId=${t3}`), null === (y3 = e8.state.socket) || void 0 === y3 || y3.emit(So.MESSAGE_ACK, { ackId: S3, channelId: t3, clientType: e8.state.isOriginator ? "dapp" : "wallet" })), e8.state.clientsPaused = (null == M3 ? void 0 : M3.type) === ko.PAUSE, e8.state.isOriginator && M3.data) {
      const t4 = M3.data, r4 = e8.state.rpcMethodTracker[t4.id];
      if (r4) {
        const i3 = Date.now() - r4.timestamp;
        oo.SocketService(`[SocketService handleMessage()] context=${e8.state.context}::on 'message' received answer for id=${t4.id} method=${r4.method} responseTime=${i3}`, M3), e8.remote.state.analytics && Lo.includes(r4.method.toLowerCase()) && lo(Object.assign(Object.assign({ id: null !== (v2 = e8.remote.state.channelId) && void 0 !== v2 ? v2 : "", event: Ao.SDK_RPC_REQUEST_DONE, sdkVersion: e8.remote.state.sdkVersion, commLayerVersion: ho.version }, e8.remote.state.originatorInfo), { walletVersion: null === (b3 = e8.remote.state.walletInfo) || void 0 === b3 ? void 0 : b3.version, params: { method: r4.method, from: "mobile" } }), e8.remote.state.communicationServerUrl).catch((e9) => {
        }), bo(r4.method) && import_sdk_analytics.analytics.track(t4.error ? 4001 === t4.error.code ? "sdk_action_rejected" : "sdk_action_failed" : "sdk_action_succeeded", { action: r4.method });
        const o2 = Object.assign(Object.assign({}, r4), { result: t4.result, error: t4.error ? { code: null === (w2 = t4.error) || void 0 === w2 ? void 0 : w2.code, message: null === (E2 = t4.error) || void 0 === E2 ? void 0 : E2.message } : void 0, elapsedTime: i3 });
        e8.state.rpcMethodTracker[t4.id] = o2, e8.emit(So.RPC_UPDATE, o2);
      }
    }
    e8.emit(So.MESSAGE, { message: M3 });
  };
} }, { event: So.REJECTED, handler: function(e8, t3) {
  return (r3) => c(this, void 0, void 0, function* () {
    var r4;
    e8.state.isOriginator && !e8.remote.state.ready ? (oo.SocketService(`[SocketService: handleChannelRejected()] context=${e8.state.context} channelId=${t3} isOriginator=${e8.state.isOriginator} ready=${e8.remote.state.ready}`, e8.remote.state.originatorInfo), lo(Object.assign(Object.assign({ id: t3, event: Ao.REJECTED }, e8.remote.state.originatorInfo), { sdkVersion: e8.remote.state.sdkVersion, commLayer: e8.state.communicationLayerPreference, commLayerVersion: ho.version, walletVersion: null === (r4 = e8.remote.state.walletInfo) || void 0 === r4 ? void 0 : r4.version }), e8.remote.state.communicationServerUrl).catch((e9) => {
    }), import_sdk_analytics.analytics.track("sdk_connection_rejected", { transport_type: "websocket" }), yield e8.remote.disconnect({ terminate: true }), e8.remote.emit(So.REJECTED, { channelId: t3 }), e8.remote.setConnectionStatus(Eo.DISCONNECTED)) : oo.SocketService(`[SocketService: handleChannelRejected()] SKIP -- channelId=${t3} isOriginator=${e8.state.isOriginator} ready=${e8.remote.state.ready}`);
  });
} }, { event: "clients_waiting_to_join", handler: function(e8, t3) {
  return (n2) => {
    oo.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${e8.state.context} on 'clients_waiting_to_join-${t3}'`, n2), e8.emit(So.CLIENTS_WAITING, n2);
  };
} }];
var $o = [{ event: So.KEY_INFO, handler: function(e8) {
  return (t3) => {
    oo.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'", t3), e8.emit(So.KEY_INFO, t3);
  };
} }, { event: So.KEYS_EXCHANGED, handler: function(e8) {
  return () => {
    var t3, n2, r3;
    oo.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${null === (t3 = e8.state.keyExchange) || void 0 === t3 ? void 0 : t3.areKeysExchanged()}`);
    const { channelConfig: i2 } = e8.remote.state;
    if (i2) {
      const t4 = e8.getKeyExchange().getKeyInfo().ecies;
      i2.localKey = t4.private, i2.otherKey = t4.otherPubKey, e8.remote.state.channelConfig = i2, null === (n2 = e8.remote.state.storageManager) || void 0 === n2 || n2.persistChannelConfig(i2).catch((e9) => {
      });
    }
    e8.emit(So.KEYS_EXCHANGED, { keysExchanged: null === (r3 = e8.state.keyExchange) || void 0 === r3 ? void 0 : r3.areKeysExchanged(), isOriginator: e8.state.isOriginator });
    const o = { keyInfo: e8.getKeyInfo() };
    e8.emit(So.SERVICE_STATUS, o);
  };
} }];
function Bo(e8, t3) {
  oo.SocketService(`[SocketService: setupChannelListener()] context=${e8.state.context} setting socket listeners for channel ${t3}...`);
  const { socket: n2 } = e8.state, { keyExchange: r3 } = e8.state;
  n2 && e8.state.isOriginator && (e8.state.debug && (null == n2 || n2.io.on("error", (t4) => {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e8.state.context} socket event=error`, t4);
  }), null == n2 || n2.io.on("reconnect", (t4) => {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e8.state.context} socket event=reconnect`, t4), Po(e8).catch((e9) => {
    });
  }), null == n2 || n2.io.on("reconnect_error", (t4) => {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e8.state.context} socket event=reconnect_error`, t4);
  }), null == n2 || n2.io.on("reconnect_failed", () => {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e8.state.context} socket event=reconnect_failed`);
  })), null == n2 || n2.on("disconnect", (t4) => (oo.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${t4}' begin recovery...`), (/* @__PURE__ */ function(e9) {
    return (t5) => {
      oo.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${e9.state.manualDisconnect}`, t5), e9.state.manualDisconnect || (e9.emit(So.SOCKET_DISCONNECTED), Po(e9).catch((e10) => {
      }));
    };
  }(e8))(t4)))), Do.forEach(({ event: r4, handler: i2 }) => {
    null == n2 || n2.on(`${r4}-${t3}`, i2(e8, t3));
  }), $o.forEach(({ event: t4, handler: n3 }) => {
    null == r3 || r3.on(t4, n3(e8));
  }), e8.state.setupChannelListeners = true;
}
var Ko = class extends import_eventemitter2.EventEmitter2 {
  constructor(e8) {
    super(), this.state = { clientsConnected: false, clientsPaused: false, manualDisconnect: false, lastRpcId: void 0, rpcMethodTracker: {}, hasPlaintext: false, communicationServerUrl: "", focusListenerAdded: false, removeFocusListener: void 0, isReconnecting: false, reconnectionAttempts: 0 }, this.options = e8;
    const { reconnect: n2, communicationLayerPreference: r3, communicationServerUrl: i2, context: o, remote: s, logging: a } = e8;
    this.state.resumed = n2, this.state.context = o, this.state.isOriginator = s.state.isOriginator, this.state.communicationLayerPreference = r3, this.state.debug = true === (null == a ? void 0 : a.serviceLayer), this.remote = s, true === (null == a ? void 0 : a.serviceLayer) && import_debug.default.enable("SocketService:Layer"), this.state.communicationServerUrl = i2, this.state.hasPlaintext = this.state.communicationServerUrl !== fo && true === (null == a ? void 0 : a.plaintext), oo.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`), this.initSocket();
  }
  initSocket() {
    var e8;
    const { otherPublicKey: t3, ecies: n2, logging: r3 } = this.options, i2 = { autoConnect: false, transports: po, withCredentials: true }, o = this.state.communicationServerUrl;
    oo.SocketService(`[SocketService: initSocket()] Socket IO url: ${o}`), this.state.socket = lookup(o, i2), function(e9) {
      if ("undefined" != typeof window && "undefined" != typeof document && (oo.SocketService(`[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`, e9), !e9.state.focusListenerAdded)) {
        const t4 = () => {
          oo.SocketService("Document has focus --- reconnecting socket"), Po(e9).catch((e10) => {
          });
        };
        window.addEventListener("focus", t4), e9.state.focusListenerAdded = true, e9.state.removeFocusListener = () => {
          window.removeEventListener("focus", t4), e9.state.focusListenerAdded = false;
        };
      }
    }(this);
    const s = { communicationLayer: this, otherPublicKey: t3, sendPublicKey: false, context: null !== (e8 = this.state.context) && void 0 !== e8 ? e8 : "", ecies: n2, logging: r3 };
    this.state.keyExchange = new Mo(s);
  }
  resetKeys() {
    return oo.SocketService("[SocketService: resetKeys()] Resetting keys."), void (null === (e8 = this.state.keyExchange) || void 0 === e8 || e8.resetKeys());
    var e8;
  }
  createChannel() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        return c(this, void 0, void 0, function* () {
          var t3, n2, r3;
          if (oo.SocketService(`[SocketService: createChannel()] context=${e8.state.context}`), e8.state.socket || e8.initSocket(), null === (t3 = e8.state.socket) || void 0 === t3 ? void 0 : t3.connected) throw new Error("socket already connected");
          null === (n2 = e8.state.socket) || void 0 === n2 || n2.connect(), e8.state.manualDisconnect = false, e8.state.isOriginator = true;
          const i2 = v4_default();
          e8.state.channelId = i2, Bo(e8, i2), yield new Promise((t4, n3) => {
            var r4;
            null === (r4 = e8.state.socket) || void 0 === r4 || r4.emit(So.JOIN_CHANNEL, { channelId: i2, context: `${e8.state.context}createChannel`, clientType: "dapp" }, (r5, i3) => c(this, void 0, void 0, function* () {
              try {
                yield Io(e8, r5, i3), t4();
              } catch (e9) {
                n3(e9);
              }
            }));
          });
          const o = null === (r3 = e8.state.keyExchange) || void 0 === r3 ? void 0 : r3.getKeyInfo();
          return { channelId: i2, pubKey: (null == o ? void 0 : o.ecies.public) || "", privKey: (null == o ? void 0 : o.ecies.private) || "" };
        });
      }(this);
    });
  }
  connectToChannel({ channelId: e8, withKeyExchange: t3 = false, authorized: n2 }) {
    return function(e9) {
      return c(this, arguments, void 0, function* ({ options: e10, instance: t4 }) {
        const { channelId: n3, authorized: r3, withKeyExchange: i2 } = e10, { state: o, remote: s } = t4, { isOriginator: a = false, socket: l3, keyExchange: d3 } = o, { channelConfig: u2 } = s.state;
        if (null == l3 ? void 0 : l3.connected) throw new Error("socket already connected");
        if (a && (null == u2 ? void 0 : u2.relayPersistence)) {
          const { localKey: e11, otherKey: t5 } = u2;
          e11 && t5 && (null == d3 || d3.setRelayPersistence({ localKey: e11, otherKey: t5 }));
        }
        return Object.assign(o, { manualDisconnect: false, withKeyExchange: i2, isOriginator: a, channelId: n3 }), null == l3 || l3.connect(), Bo(t4, n3), !a && r3 && (null == d3 || d3.setKeysExchanged(true), Object.assign(s.state, { ready: true, authorized: true })), new Promise((e11) => {
          var i3;
          const s2 = null === (i3 = null == d3 ? void 0 : d3.getKeyInfo()) || void 0 === i3 ? void 0 : i3.ecies.public;
          null == l3 || l3.emit(So.JOIN_CHANNEL, { channelId: n3, context: `${o.context}_connectToChannel`, clientType: a ? "dapp" : "wallet", publicKey: r3 && !a ? s2 : void 0 }, (n4, r4) => c(this, void 0, void 0, function* () {
            yield Io(t4, n4, r4), e11();
          }));
        });
      });
    }({ options: { channelId: e8, withKeyExchange: t3, authorized: n2 }, instance: this });
  }
  getKeyInfo() {
    return this.state.keyExchange.getKeyInfo();
  }
  keyCheck() {
    var e8, t3;
    null === (t3 = (e8 = this).state.socket) || void 0 === t3 || t3.emit(So.MESSAGE, { id: e8.state.channelId, context: e8.state.context, message: { type: Co.KEY_HANDSHAKE_CHECK, pubkey: e8.getKeyInfo().ecies.otherPubKey } });
  }
  getKeyExchange() {
    return this.state.keyExchange;
  }
  sendMessage(e8) {
    return c(this, void 0, void 0, function* () {
      return function(e9, t3) {
        return c(this, void 0, void 0, function* () {
          var r3, i2, o;
          if (!e9.state.channelId) throw oo.SocketService("handleSendMessage: no channelId - Create a channel first"), new Error("Create a channel first");
          if (oo.SocketService(`[SocketService: handleSendMessage()] context=${e9.state.context} areKeysExchanged=${null === (r3 = e9.state.keyExchange) || void 0 === r3 ? void 0 : r3.areKeysExchanged()}`, t3), null === (i2 = null == t3 ? void 0 : t3.type) || void 0 === i2 ? void 0 : i2.startsWith("key_handshake")) return function(e10, t4) {
            var n2;
            oo.SocketService(`[SocketService: handleKeyHandshake()] context=${e10.state.context}`, t4), null === (n2 = e10.state.socket) || void 0 === n2 || n2.emit(So.MESSAGE, { id: e10.state.channelId, context: e10.state.context, clientType: e10.state.isOriginator ? "dapp" : "wallet", message: t4 });
          }(e9, t3), true;
          !function(e10, t4) {
            var n2;
            if (!(null === (n2 = e10.state.keyExchange) || void 0 === n2 ? void 0 : n2.areKeysExchanged()) && !e10.remote.state.relayPersistence) throw oo.SocketService(`[SocketService: validateKeyExchange()] context=${e10.state.context} ERROR keys not exchanged`, t4), new Error("Keys not exchanged BBB");
          }(e9, t3), function(e10, t4) {
            var n2;
            const r4 = null !== (n2 = null == t4 ? void 0 : t4.method) && void 0 !== n2 ? n2 : "", i3 = null == t4 ? void 0 : t4.id;
            e10.state.isOriginator && i3 && (e10.state.rpcMethodTracker[i3] = { id: i3, timestamp: Date.now(), method: r4 }, e10.emit(So.RPC_UPDATE, e10.state.rpcMethodTracker[i3]));
          }(e9, t3);
          const s = yield Oo(e9, t3);
          return e9.remote.state.analytics && e9.remote.state.isOriginator && t3.method && Lo.includes(t3.method.toLowerCase()) && lo({ id: null !== (o = e9.remote.state.channelId) && void 0 !== o ? o : "", event: Ao.SDK_RPC_REQUEST, params: { method: t3.method, from: "mobile" } }, e9.remote.state.communicationServerUrl).catch((e10) => {
          }), e9.remote.state.isOriginator && t3.method && bo(t3.method) && import_sdk_analytics.analytics.track("sdk_action_requested", { action: t3.method }), function(e10, t4) {
            return c(this, void 0, void 0, function* () {
              var n2;
              const r4 = null == t4 ? void 0 : t4.id, i3 = null !== (n2 = null == t4 ? void 0 : t4.method) && void 0 !== n2 ? n2 : "";
              if (e10.state.isOriginator && r4) try {
                const n3 = Ro(r4, e10.state.rpcMethodTracker, 200).then((e11) => ({ type: No.RPC_CHECK, result: e11 })), o2 = (() => c(this, void 0, void 0, function* () {
                  const t5 = yield ((e11) => c(void 0, [e11], void 0, function* ({ rpcId: e12, instance: t6 }) {
                    for (; t6.state.lastRpcId === e12 || void 0 === t6.state.lastRpcId; ) yield To(200);
                    return t6.state.lastRpcId;
                  }))({ instance: e10, rpcId: r4 }), n4 = yield Ro(t5, e10.state.rpcMethodTracker, 200);
                  return { type: No.SKIPPED_RPC, result: n4 };
                }))(), s2 = yield Promise.race([n3, o2]);
                if (s2.type === No.RPC_CHECK) {
                  const e11 = s2.result;
                  oo.SocketService(`[SocketService:handleRpcReplies()] id=${t4.id} ${i3} ( ${e11.elapsedTime} ms)`, e11.result);
                } else {
                  if (s2.type !== No.SKIPPED_RPC) throw new Error(`Error handling RPC replies for ${r4}`);
                  {
                    const t5 = Object.assign(Object.assign({}, e10.state.rpcMethodTracker[r4]), { error: new Error("SDK_CONNECTION_ISSUE") });
                    e10.emit(So.RPC_UPDATE, t5);
                    const n4 = { data: Object.assign(Object.assign({}, t5), { jsonrpc: "2.0" }), name: "metamask-provider" };
                    e10.emit(So.MESSAGE, { message: n4 });
                  }
                }
              } catch (e11) {
                throw e11;
              }
            });
          }(e9, t3).catch((e10) => {
          }), s;
        });
      }(this, e8);
    });
  }
  ping() {
    return function(e8) {
      return c(this, void 0, void 0, function* () {
        var t3, n2;
        oo.SocketService(`[SocketService: ping()] context=${e8.state.context} originator=${e8.state.isOriginator} keysExchanged=${null === (t3 = e8.state.keyExchange) || void 0 === t3 ? void 0 : t3.areKeysExchanged()}`), null === (n2 = e8.state.socket) || void 0 === n2 || n2.emit(ko.PING, { id: e8.state.channelId, context: "ping", clientType: e8.remote.state.isOriginator ? "dapp" : "wallet", message: "" });
      });
    }(this);
  }
  pause() {
    return function(e8) {
      return c(this, void 0, void 0, function* () {
        var t3, n2;
        oo.SocketService(`[SocketService: pause()] context=${e8.state.context}`), e8.state.manualDisconnect = true, (null === (t3 = e8.state.keyExchange) || void 0 === t3 ? void 0 : t3.areKeysExchanged()) && (yield e8.sendMessage({ type: ko.PAUSE })), null === (n2 = e8.state.socket) || void 0 === n2 || n2.disconnect();
      });
    }(this);
  }
  isConnected() {
    var e8;
    return null === (e8 = this.state.socket) || void 0 === e8 ? void 0 : e8.connected;
  }
  resume() {
    return function(e8) {
      return c(this, void 0, void 0, function* () {
        const { state: t3, remote: n2 } = e8, { socket: r3, channelId: i2, context: o, keyExchange: s, isOriginator: a } = t3, { isOriginator: l3 } = n2.state;
        if (oo.SocketService(`[SocketService: resume()] channelId=${i2} context=${o} connected=${null == r3 ? void 0 : r3.connected} manualDisconnect=${t3.manualDisconnect} resumed=${t3.resumed} keysExchanged=${null == s ? void 0 : s.areKeysExchanged()}`), !i2) throw oo.SocketService("[SocketService: resume()] channelId is not defined"), new Error("ChannelId is not defined");
        (null == r3 ? void 0 : r3.connected) ? (oo.SocketService("[SocketService: resume()] already connected."), r3.emit(ko.PING, { id: i2, clientType: l3 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), n2.hasRelayPersistence() || (null == s ? void 0 : s.areKeysExchanged()) || (a ? yield e8.sendMessage({ type: ko.READY }) : null == s || s.start({ isOriginator: false }))) : (null == r3 || r3.connect(), oo.SocketService(`[SocketService: resume()] after connecting socket --> connected=${null == r3 ? void 0 : r3.connected}`), null == r3 || r3.emit(So.JOIN_CHANNEL, { channelId: i2, context: `${o}_resume`, clientType: l3 ? "dapp" : "wallet" }, (t4, n3) => c(this, void 0, void 0, function* () {
          try {
            yield Io(e8, t4, n3);
          } catch (e9) {
          }
        }))), t3.manualDisconnect = false, t3.resumed = true;
      });
    }(this);
  }
  getRPCMethodTracker() {
    return this.state.rpcMethodTracker;
  }
  disconnect(e8) {
    return function(e9, t3) {
      var n2, r3, i2, o, s;
      oo.SocketService(`[SocketService: disconnect()] context=${e9.state.context}`, t3), (null == t3 ? void 0 : t3.terminate) && (null === (r3 = (n2 = e9.state).removeFocusListener) || void 0 === r3 || r3.call(n2), e9.state.channelId = t3.channelId, null === (i2 = e9.state.socket) || void 0 === i2 || i2.removeAllListeners(), null === (o = e9.state.keyExchange) || void 0 === o || o.clean(), e9.remote.state.ready = false, e9.state.socket = void 0, e9.state.rpcMethodTracker = {}), e9.state.manualDisconnect = true, null === (s = e9.state.socket) || void 0 === s || s.disconnect();
    }(this, e8);
  }
};
var jo;
var Uo;
var Ho;
function Fo(e8) {
  return () => c(this, void 0, void 0, function* () {
    var t3, n2, r3;
    const { state: i2 } = e8;
    if (i2.authorized) return;
    yield (() => c(this, void 0, void 0, function* () {
      for (; !i2.walletInfo; ) yield To(500);
    }))();
    const o = "7.3".localeCompare((null === (t3 = i2.walletInfo) || void 0 === t3 ? void 0 : t3.version) || "");
    if (oo.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${null === (n2 = i2.walletInfo) || void 0 === n2 ? void 0 : n2.version} compareValue=${o}`), 1 !== o) return;
    const s = i2.platformType === Uo.MobileWeb || i2.platformType === Uo.ReactNative || i2.platformType === Uo.MetaMaskMobileWebview;
    oo.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i2.platformType} secure=${s} channel=${i2.channelId} walletVersion=${null === (r3 = i2.walletInfo) || void 0 === r3 ? void 0 : r3.version}`), s && (i2.authorized = true, e8.emit(So.AUTHORIZED));
  });
}
function zo(e8) {
  return (t3) => {
    const { state: n2 } = e8;
    oo.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${n2.context} on 'channel_created' channelId=${t3}`), e8.emit(So.CHANNEL_CREATED, t3);
  };
}
function qo(e8, t3) {
  return () => {
    var r3, i2, o, s;
    const { state: a } = e8;
    oo.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${a.channelId} keysExchanged=${null === (i2 = null === (r3 = a.communicationLayer) || void 0 === r3 ? void 0 : r3.getKeyInfo()) || void 0 === i2 ? void 0 : i2.keysExchanged}`), a.analytics && lo(Object.assign(Object.assign({ id: null !== (o = a.channelId) && void 0 !== o ? o : "", event: a.reconnection ? Ao.RECONNECT : a.isOriginator ? Ao.REQUEST : Ao.REQUEST_MOBILE }, a.originatorInfo), { commLayer: t3, sdkVersion: a.sdkVersion, walletVersion: null === (s = a.walletInfo) || void 0 === s ? void 0 : s.version, commLayerVersion: ho.version }), a.communicationServerUrl).catch((e9) => {
    }), a.isOriginator && !a.reconnection && import_sdk_analytics.analytics.track("sdk_connection_established", { transport_type: "websocket" }), a.clientsConnected = true, a.originatorInfoSent = false, e8.emit(So.CLIENTS_CONNECTED);
  };
}
function Wo(e8) {
  return (t3) => {
    const { state: n2 } = e8;
    oo.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${n2.context} on 'clients_disconnected' channelId=${t3}`), n2.relayPersistence || (n2.clientsConnected = false, n2.ready = false, n2.authorized = false), e8.emit(So.CLIENTS_DISCONNECTED, n2.channelId), e8.setConnectionStatus(Eo.DISCONNECTED);
  };
}
function Vo(e8) {
  return (t3) => {
    var n2;
    const { state: r3 } = e8;
    if (oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${r3.context} on 'clients_waiting' numberUsers=${t3} ready=${r3.ready} autoStarted=${r3.originatorConnectStarted}`), e8.setConnectionStatus(Eo.WAITING), e8.emit(So.CLIENTS_WAITING, t3), r3.originatorConnectStarted) {
      oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${r3.originatorConnectStarted} timeout`, r3.autoConnectOptions);
      const t4 = (null === (n2 = r3.autoConnectOptions) || void 0 === n2 ? void 0 : n2.timeout) || 3e3, i2 = setTimeout(() => {
        oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${t4}) terminate channelConfig`, r3.autoConnectOptions), r3.originatorConnectStarted = false, r3.ready || e8.setConnectionStatus(Eo.TIMEOUT), clearTimeout(i2);
      }, t4);
    }
  };
}
function Go(e8, t3) {
  return (n2) => {
    var r3, i2, o, s, a, c2, l3, d3;
    const { state: u2 } = e8;
    if (oo.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${u2.context} on commLayer.'keys_exchanged' channel=${u2.channelId}`, n2), null === (i2 = null === (r3 = u2.communicationLayer) || void 0 === r3 ? void 0 : r3.getKeyInfo()) || void 0 === i2 ? void 0 : i2.keysExchanged) {
      const t4 = Object.assign(Object.assign({}, u2.channelConfig), { channelId: null !== (o = u2.channelId) && void 0 !== o ? o : "", validUntil: (null === (s = u2.channelConfig) || void 0 === s ? void 0 : s.validUntil) || go, localKey: u2.communicationLayer.getKeyInfo().ecies.private, otherKey: u2.communicationLayer.getKeyInfo().ecies.otherPubKey });
      null === (a = u2.storageManager) || void 0 === a || a.persistChannelConfig(t4).catch((e9) => {
      }), e8.setConnectionStatus(Eo.LINKED);
    }
    !function(e9, t4) {
      var n3, r4, i3, o2, s2, a2, c3, l4;
      const { state: d4 } = e9;
      oo.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${d4.channelId}`, t4);
      const u3 = Object.assign(Object.assign({}, d4.channelConfig), { channelId: null !== (n3 = d4.channelId) && void 0 !== n3 ? n3 : "", validUntil: null !== (i3 = null === (r4 = d4.channelConfig) || void 0 === r4 ? void 0 : r4.validUntil) && void 0 !== i3 ? i3 : 0, relayPersistence: d4.relayPersistence, localKey: null === (s2 = null === (o2 = d4.communicationLayer) || void 0 === o2 ? void 0 : o2.state.keyExchange) || void 0 === s2 ? void 0 : s2.getKeyInfo().ecies.private, otherKey: null === (c3 = null === (a2 = d4.communicationLayer) || void 0 === a2 ? void 0 : a2.state.keyExchange) || void 0 === c3 ? void 0 : c3.getKeyInfo().ecies.otherPubKey, lastActive: t4.getTime() });
      null === (l4 = d4.storageManager) || void 0 === l4 || l4.persistChannelConfig(u3);
    }(e8, /* @__PURE__ */ new Date()), u2.analytics && u2.channelId && lo(Object.assign(Object.assign({ id: u2.channelId, event: n2.isOriginator ? Ao.CONNECTED : Ao.CONNECTED_MOBILE }, u2.originatorInfo), { sdkVersion: u2.sdkVersion, commLayer: t3, commLayerVersion: ho.version, walletVersion: null === (c2 = u2.walletInfo) || void 0 === c2 ? void 0 : c2.version }), u2.communicationServerUrl).catch((e9) => {
    }), u2.isOriginator = n2.isOriginator, n2.isOriginator || (null === (l3 = u2.communicationLayer) || void 0 === l3 || l3.sendMessage({ type: ko.READY }), u2.ready = true, u2.paused = false), n2.isOriginator && !u2.originatorInfoSent && (null === (d3 = u2.communicationLayer) || void 0 === d3 || d3.sendMessage({ type: ko.ORIGINATOR_INFO, originatorInfo: u2.originatorInfo, originator: u2.originatorInfo }), u2.originatorInfoSent = true);
  };
}
function Yo(e8) {
  return (t3) => {
    let n2 = t3;
    t3.message && (n2 = n2.message), function(e9, t4) {
      const { state: n3 } = t4;
      if (oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${n3.context} on 'message' typeof=${typeof e9}`, e9), t4.state.ready = true, n3.isOriginator || e9.type !== ko.ORIGINATOR_INFO) if (n3.isOriginator && e9.type === ko.WALLET_INFO) !function(e10, t5) {
        const { state: n4 } = e10;
        n4.walletInfo = t5.walletInfo, n4.paused = false;
      }(t4, e9);
      else {
        if (n3.isOriginator && e9.type === ko.WALLET_INIT) (function(e10, t5) {
          return c(this, void 0, void 0, function* () {
            var n4, r3, i2;
            const { state: o } = e10;
            if (o.isOriginator) {
              const o2 = t5.data || {};
              if ("object" == typeof o2 && "accounts" in o2 && "chainId" in o2 && "walletKey" in o2) try {
                const { channelConfig: t6 } = e10.state;
                if (oo.RemoteCommunication("WALLET_INIT: channelConfig", JSON.stringify(t6, null, 2)), t6) {
                  const s = o2.accounts, a = o2.chainId, c2 = o2.walletKey;
                  let l3, d3 = false;
                  "deeplinkProtocol" in o2 && (d3 = Boolean(o2.deeplinkProtocol), e10.state.deeplinkProtocolAvailable = d3), "walletVersion" in o2 && (l3 = o2.walletVersion), yield null === (n4 = e10.state.storageManager) || void 0 === n4 ? void 0 : n4.persistChannelConfig(Object.assign(Object.assign({}, t6), { otherKey: c2, walletVersion: l3, deeplinkProtocolAvailable: d3, relayPersistence: true })), yield null === (r3 = e10.state.storageManager) || void 0 === r3 ? void 0 : r3.persistAccounts(s), yield null === (i2 = e10.state.storageManager) || void 0 === i2 ? void 0 : i2.persistChainId(a);
                }
                e10.emit(So.WALLET_INIT, { accounts: o2.accounts, chainId: o2.chainId });
              } catch (n5) {
              }
            }
          });
        })(t4, e9).catch((e10) => {
          oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e10}`);
        });
        else if (e9.type === ko.TERMINATE) (function(e10) {
          return c(this, void 0, void 0, function* () {
            const { state: t5 } = e10;
            t5.isOriginator && (yield es({ options: { terminate: true, sendMessage: false }, instance: e10 }), e10.emit(So.TERMINATE));
          });
        })(t4).catch((e10) => {
          oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e10}`);
        });
        else if (e9.type === ko.PAUSE) !function(e10) {
          const { state: t5 } = e10;
          t5.paused = true, e10.setConnectionStatus(Eo.PAUSED);
        }(t4);
        else if (e9.type === ko.READY && n3.isOriginator) !function(e10) {
          const { state: t5 } = e10;
          e10.setConnectionStatus(Eo.LINKED);
          const n4 = t5.paused;
          t5.paused = false, e10.emit(So.CLIENTS_READY, { isOriginator: t5.isOriginator, walletInfo: t5.walletInfo }), n4 && (t5.authorized = true, e10.emit(So.AUTHORIZED));
        }(t4);
        else {
          if (e9.type === ko.OTP && n3.isOriginator) return void function(e10, t5) {
            var n4;
            const { state: r3 } = e10;
            e10.emit(So.OTP, t5.otpAnswer), 1 === "6.6".localeCompare((null === (n4 = r3.walletInfo) || void 0 === n4 ? void 0 : n4.version) || "") && e10.emit(So.SDK_RPC_CALL, { method: yo.ETH_REQUESTACCOUNTS, params: [] });
          }(t4, e9);
          e9.type === ko.AUTHORIZED && n3.isOriginator && function(e10) {
            const { state: t5 } = e10;
            t5.authorized = true, e10.emit(So.AUTHORIZED);
          }(t4);
        }
        t4.emit(So.MESSAGE, e9);
      }
      else !function(e10, t5) {
        var n4;
        const { state: r3 } = e10;
        null === (n4 = r3.communicationLayer) || void 0 === n4 || n4.sendMessage({ type: ko.WALLET_INFO, walletInfo: r3.walletInfo }), r3.originatorInfo = t5.originatorInfo || t5.originator, e10.emit(So.CLIENTS_READY, { isOriginator: r3.isOriginator, originatorInfo: r3.originatorInfo }), r3.paused = false;
      }(t4, e9);
    }(n2, e8);
  };
}
function Zo(e8) {
  return () => {
    const { state: t3 } = e8;
    oo.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"), t3.ready = false, t3.authorized = false, wo(t3), e8.emitServiceStatusEvent({ context: "socket_reconnect" });
  };
}
function Jo(e8) {
  return () => {
    const { state: t3 } = e8;
    oo.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"), t3.ready = false;
  };
}
function Qo(e8) {
  return () => c(this, void 0, void 0, function* () {
    var t3, n2, r3, i2, o, s, a;
    const { state: c2 } = e8;
    oo.RemoteCommunication(`[RemoteCommunication: handleFullPersistenceEvent()] context=${c2.context}`), e8.state.ready = true, e8.state.clientsConnected = true, e8.state.authorized = true, e8.state.relayPersistence = true, null === (t3 = e8.state.communicationLayer) || void 0 === t3 || t3.getKeyExchange().setKeysExchanged(true), e8.emit(So.KEYS_EXCHANGED, { keysExchanged: true, isOriginator: true }), e8.emit(So.AUTHORIZED), e8.emit(So.CLIENTS_READY), e8.emit(So.CHANNEL_PERSISTENCE);
    try {
      c2.channelConfig = Object.assign(Object.assign({}, c2.channelConfig), { localKey: null === (n2 = c2.communicationLayer) || void 0 === n2 ? void 0 : n2.getKeyExchange().getKeyInfo().ecies.private, otherKey: null === (r3 = c2.communicationLayer) || void 0 === r3 ? void 0 : r3.getKeyExchange().getOtherPublicKey(), channelId: null !== (i2 = c2.channelId) && void 0 !== i2 ? i2 : "", validUntil: null !== (s = null === (o = c2.channelConfig) || void 0 === o ? void 0 : o.validUntil) && void 0 !== s ? s : go, relayPersistence: true }), yield null === (a = c2.storageManager) || void 0 === a ? void 0 : a.persistChannelConfig(c2.channelConfig);
    } catch (t4) {
    }
  });
}
function Xo({ communicationLayerPreference: e8, otherPublicKey: t3, reconnect: n2, ecies: r3, communicationServerUrl: i2 = fo, instance: o }) {
  var s, a, c2, l3, d3, u2, h3, f2, p3, g3, m2;
  const { state: y3 } = o;
  if (oo.RemoteCommunication("[initCommunicationLayer()] ", JSON.stringify(y3, null, 2)), e8 !== jo.SOCKET) throw new Error("Invalid communication protocol");
  y3.communicationLayer = new Ko({ communicationLayerPreference: e8, otherPublicKey: t3, reconnect: n2, transports: y3.transports, communicationServerUrl: i2, context: y3.context, ecies: r3, logging: y3.logging, remote: o });
  let v2 = "undefined" != typeof document && document.URL || "", b3 = "undefined" != typeof document && document.title || "";
  (null === (s = y3.dappMetadata) || void 0 === s ? void 0 : s.url) && (v2 = y3.dappMetadata.url), (null === (a = y3.dappMetadata) || void 0 === a ? void 0 : a.name) && (b3 = y3.dappMetadata.name);
  const w2 = null !== (u2 = null !== (l3 = null === (c2 = y3.dappMetadata) || void 0 === c2 ? void 0 : c2.name) && void 0 !== l3 ? l3 : null === (d3 = y3.dappMetadata) || void 0 === d3 ? void 0 : d3.url) && void 0 !== u2 ? u2 : "N/A", E2 = "undefined" != typeof window && void 0 !== window.location && null !== (h3 = window.location.hostname) && void 0 !== h3 ? h3 : w2, S3 = { url: v2, title: b3, source: null === (f2 = y3.dappMetadata) || void 0 === f2 ? void 0 : f2.source, dappId: E2, anonId: y3.anonId, icon: (null === (p3 = y3.dappMetadata) || void 0 === p3 ? void 0 : p3.iconUrl) || (null === (g3 = y3.dappMetadata) || void 0 === g3 ? void 0 : g3.base64Icon), platform: y3.platformType, apiVersion: ho.version, connector: null === (m2 = y3.dappMetadata) || void 0 === m2 ? void 0 : m2.connector };
  y3.originatorInfo = S3;
  const _3 = { [So.AUTHORIZED]: Fo(o), [So.MESSAGE]: Yo(o), [So.CHANNEL_PERSISTENCE]: Qo(o), [So.CLIENTS_CONNECTED]: qo(o, e8), [So.KEYS_EXCHANGED]: Go(o, e8), [So.SOCKET_DISCONNECTED]: Jo(o), [So.SOCKET_RECONNECT]: Zo(o), [So.CLIENTS_DISCONNECTED]: Wo(o), [So.KEY_INFO]: () => {
  }, [So.CHANNEL_CREATED]: zo(o), [So.CLIENTS_WAITING]: Vo(o), [So.RPC_UPDATE]: (e9) => {
    o.emit(So.RPC_UPDATE, e9);
  } };
  for (const [t4, n3] of Object.entries(_3)) try {
    y3.communicationLayer.on(t4, n3);
  } catch (e9) {
  }
}
function es(e8) {
  return c(this, arguments, void 0, function* ({ options: e9, instance: t3 }) {
    const { state: n2 } = t3;
    return oo.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${n2.channelId}`, e9), new Promise((r3, i2) => {
      var o, a, c2, l3, d3, u2;
      (null == e9 ? void 0 : e9.terminate) ? (t3.state.ready && lo({ id: null !== (o = t3.state.channelId) && void 0 !== o ? o : "", event: Ao.TERMINATED }, t3.state.communicationServerUrl).catch((e10) => {
      }), n2.ready = false, n2.paused = false, null === (a = n2.storageManager) || void 0 === a || a.terminate(null !== (c2 = n2.channelId) && void 0 !== c2 ? c2 : ""), t3.state.terminated = true, e9.sendMessage ? (null === (l3 = n2.communicationLayer) || void 0 === l3 ? void 0 : l3.getKeyInfo().keysExchanged) && t3.state.communicationLayer && Oo(t3.state.communicationLayer, { type: ko.TERMINATE }).then(() => {
        r3(true);
      }).catch((e10) => {
        i2(e10);
      }) : r3(true), n2.authorized = false, n2.relayPersistence = false, n2.channelId = v4_default(), e9.channelId = n2.channelId, n2.channelConfig = void 0, n2.originatorConnectStarted = false, null === (d3 = n2.communicationLayer) || void 0 === d3 || d3.disconnect(e9), t3.setConnectionStatus(Eo.TERMINATED)) : (null === (u2 = n2.communicationLayer) || void 0 === u2 || u2.disconnect(e9), t3.setConnectionStatus(Eo.DISCONNECTED), r3(true));
    });
  });
}
(jo || (jo = {})).SOCKET = "socket", function(e8) {
  e8.NonBrowser = "nodejs", e8.MetaMaskMobileWebview = "in-app-browser", e8.DesktopWeb = "web-desktop", e8.MobileWeb = "web-mobile", e8.ReactNative = "react-native";
}(Uo || (Uo = {}));
var ts = class extends import_eventemitter2.EventEmitter2 {
  constructor(e8) {
    super(), this.state = { ready: false, anonId: "", authorized: false, isOriginator: false, terminated: false, protocolVersion: 1, paused: false, deeplinkProtocolAvailable: false, platformType: "metamask-mobile", analytics: false, reconnection: false, originatorInfoSent: false, communicationServerUrl: fo, context: "", persist: false, clientsConnected: false, sessionDuration: go, originatorConnectStarted: false, debug: false, _connectionStatus: Eo.DISCONNECTED }, this._options = e8;
    const { anonId: n2, platformType: r3, communicationLayerPreference: i2, otherPublicKey: o, reconnect: s, walletInfo: a, dappMetadata: c2, protocolVersion: l3, transports: d3, context: u2, relayPersistence: h3, ecies: f2, analytics: p3 = false, storage: g3, sdkVersion: m2, communicationServerUrl: y3 = fo, logging: v2, autoConnect: b3 = { timeout: mo } } = e8;
    this.state.anonId = n2, this.state.otherPublicKey = o, this.state.dappMetadata = c2, this.state.walletInfo = a, this.state.transports = d3, this.state.platformType = r3, this.state.analytics = p3, this.state.protocolVersion = null != l3 ? l3 : 1, this.state.isOriginator = !o, this.state.relayPersistence = h3, this.state.communicationServerUrl = y3, this.state.context = u2, this.state.terminated = false, this.state.sdkVersion = m2, this.setMaxListeners(50), this.setConnectionStatus(Eo.DISCONNECTED), (null == g3 ? void 0 : g3.duration) && (this.state.sessionDuration = go), this.state.storageOptions = g3, this.state.autoConnectOptions = b3, this.state.debug = true === (null == v2 ? void 0 : v2.remoteLayer), true === (null == v2 ? void 0 : v2.remoteLayer) && import_debug.default.enable("RemoteCommunication:Layer"), true === (null == v2 ? void 0 : v2.serviceLayer) && import_debug.default.enable("SocketService:Layer"), true === (null == v2 ? void 0 : v2.eciesLayer) && import_debug.default.enable("ECIES:Layer"), true === (null == v2 ? void 0 : v2.keyExchangeLayer) && import_debug.default.enable("KeyExchange:Layer"), this.state.logging = v2, (null == g3 ? void 0 : g3.storageManager) && (this.state.storageManager = g3.storageManager), oo.RemoteCommunication(`[RemoteCommunication: constructor()] protocolVersion=${l3} relayPersistence=${h3} isOriginator=${this.state.isOriginator} communicationLayerPreference=${i2} otherPublicKey=${o} reconnect=${s}`), this.state.isOriginator || Xo({ communicationLayerPreference: i2, otherPublicKey: o, reconnect: s, ecies: f2, communicationServerUrl: y3, instance: this }), this.emitServiceStatusEvent({ context: "constructor" });
  }
  initFromDappStorage() {
    return c(this, void 0, void 0, function* () {
      var e8;
      if (this.state.storageManager) {
        const t3 = yield this.state.storageManager.getPersistedChannelConfig({});
        t3 && (this.state.channelConfig = t3, this.state.channelId = t3.channelId, this.state.deeplinkProtocolAvailable = null !== (e8 = t3.deeplinkProtocolAvailable) && void 0 !== e8 && e8, t3.relayPersistence && (this.state.authorized = true, this.state.ready = true, this.setConnectionStatus(Eo.LINKED), yield this.connectToChannel({ channelId: t3.channelId })));
      }
      Xo({ communicationLayerPreference: jo.SOCKET, otherPublicKey: this.state.otherPublicKey, reconnect: this._options.reconnect, ecies: this._options.ecies, communicationServerUrl: this.state.communicationServerUrl, instance: this });
    });
  }
  originatorSessionConnect() {
    return c(this, void 0, void 0, function* () {
      return yield function(e8) {
        return c(this, void 0, void 0, function* () {
          var t3;
          const { state: n2 } = e8;
          if (!n2.storageManager) return void oo.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");
          const r3 = yield n2.storageManager.getPersistedChannelConfig({});
          if (oo.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${n2.originatorConnectStarted} channelConfig`, r3), null === (t3 = n2.communicationLayer) || void 0 === t3 ? void 0 : t3.isConnected()) return oo.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"), r3;
          if (r3) {
            if (r3.validUntil > Date.now()) return n2.channelConfig = r3, n2.originatorConnectStarted = true, n2.channelId = null == r3 ? void 0 : r3.channelId, n2.reconnection = true, r3;
            oo.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired");
          }
          n2.originatorConnectStarted = false;
        });
      }(this);
    });
  }
  generateChannelIdConnect() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        return c(this, void 0, void 0, function* () {
          var t3, n2, r3, i2, o, s;
          if (!e8.communicationLayer) throw new Error("communication layer not initialized");
          if (e8.ready) throw new Error("Channel already connected");
          if (e8.channelId && (null === (t3 = e8.communicationLayer) || void 0 === t3 ? void 0 : t3.isConnected())) return e8.channelConfig = Object.assign(Object.assign({}, e8.channelConfig), { channelId: e8.channelId, validUntil: Date.now() + e8.sessionDuration }), null === (n2 = e8.storageManager) || void 0 === n2 || n2.persistChannelConfig(e8.channelConfig), { channelId: e8.channelId, privKey: null === (i2 = null === (r3 = e8.communicationLayer) || void 0 === r3 ? void 0 : r3.getKeyInfo()) || void 0 === i2 ? void 0 : i2.ecies.private, pubKey: null === (s = null === (o = e8.communicationLayer) || void 0 === o ? void 0 : o.getKeyInfo()) || void 0 === s ? void 0 : s.ecies.public };
          oo.RemoteCommunication("[RemoteCommunication: generateChannelId()]");
          const a = yield e8.communicationLayer.createChannel();
          oo.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created", a);
          const c2 = Object.assign(Object.assign({}, e8.channelConfig), { channelId: a.channelId, localKey: a.privKey, validUntil: Date.now() + e8.sessionDuration });
          return e8.channelId = a.channelId, e8.channelConfig = c2, { channelId: e8.channelId, pubKey: a.pubKey, privKey: a.privKey };
        });
      }(this.state);
    });
  }
  clean() {
    return wo(this.state);
  }
  connectToChannel({ channelId: e8, withKeyExchange: t3, authorized: n2 }) {
    return function(e9) {
      return c(this, arguments, void 0, function* ({ channelId: e10, withKeyExchange: t4, authorized: n3, state: r3 }) {
        var i2, s, a;
        if (!validate_default(e10)) throw oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r3.context} invalid channel channelId=${e10}`), new Error(`Invalid channel ${e10}`);
        if (oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r3.context} channelId=${e10} withKeyExchange=${t4}`), null === (i2 = r3.communicationLayer) || void 0 === i2 ? void 0 : i2.isConnected()) return void oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r3.context} already connected - interrupt connection.`);
        r3.channelId = e10, yield null === (s = r3.communicationLayer) || void 0 === s ? void 0 : s.connectToChannel({ channelId: e10, authorized: n3, withKeyExchange: t4 });
        const c2 = Object.assign(Object.assign({}, r3.channelConfig), { channelId: e10, validUntil: Date.now() + r3.sessionDuration });
        r3.channelConfig = c2, null === (a = r3.storageManager) || void 0 === a || a.persistChannelConfig(c2);
      });
    }({ channelId: e8, authorized: n2, withKeyExchange: t3, state: this.state });
  }
  sendMessage(e8) {
    return c(this, void 0, void 0, function* () {
      const t3 = this.state.isOriginator && e8.method && bo(e8.method);
      t3 && import_sdk_analytics.analytics.track("sdk_action_requested", { action: e8.method });
      try {
        return yield function(e9, t4) {
          return c(this, void 0, void 0, function* () {
            var n2, r3;
            const { state: i2 } = e9;
            oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i2.context} paused=${i2.paused} ready=${i2.ready} relayPersistence=${i2.relayPersistence} authorized=${i2.authorized} socket=${null === (n2 = i2.communicationLayer) || void 0 === n2 ? void 0 : n2.isConnected()} clientsConnected=${i2.clientsConnected} status=${i2._connectionStatus}`, t4), i2.relayPersistence || i2.ready && (null === (r3 = i2.communicationLayer) || void 0 === r3 ? void 0 : r3.isConnected()) && i2.clientsConnected || (oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i2.context}  SKIP message waiting for MM mobile readiness.`), yield new Promise((t5) => {
              e9.once(So.CLIENTS_READY, t5);
            }), oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i2.context}  AFTER SKIP / READY -- sending pending message`));
            try {
              const n3 = yield function(e10, t5) {
                return c(this, void 0, void 0, function* () {
                  return new Promise((n4) => {
                    var r4;
                    const { state: i3 } = e10;
                    oo.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i3.context} ready=${i3.ready} authorized=${i3.authorized} method=${t5.method}`), !i3.isOriginator || i3.authorized || i3.relayPersistence ? null === (r4 = i3.communicationLayer) || void 0 === r4 || r4.sendMessage(t5).then((e11) => {
                      n4(e11);
                    }).catch((e11) => {
                      n4(false);
                    }) : e10.once(So.AUTHORIZED, () => {
                      var e11;
                      oo.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i3.context}  AFTER SKIP / AUTHORIZED -- sending pending message`), null === (e11 = i3.communicationLayer) || void 0 === e11 || e11.sendMessage(t5).then((e12) => {
                        n4(e12);
                      }).catch((e12) => {
                        n4(false);
                      });
                    });
                  });
                });
              }(e9, t4);
              return n3;
            } catch (e10) {
              throw e10;
            }
          });
        }(this, e8);
      } catch (r3) {
        throw t3 && import_sdk_analytics.analytics.track("sdk_action_failed", { action: e8.method }), r3;
      }
    });
  }
  testStorage() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        return c(this, void 0, void 0, function* () {
          var t3;
          const n2 = yield null === (t3 = e8.storageManager) || void 0 === t3 ? void 0 : t3.getPersistedChannelConfig();
          oo.RemoteCommunication("[RemoteCommunication: testStorage()] res", n2);
        });
      }(this.state);
    });
  }
  hasDeeplinkProtocol() {
    return this.state.deeplinkProtocolAvailable;
  }
  getChannelConfig() {
    return this.state.channelConfig;
  }
  isReady() {
    return this.state.ready;
  }
  isConnected() {
    var e8;
    return null === (e8 = this.state.communicationLayer) || void 0 === e8 ? void 0 : e8.isConnected();
  }
  isAuthorized() {
    return this.state.authorized;
  }
  isPaused() {
    return this.state.paused;
  }
  getCommunicationLayer() {
    return this.state.communicationLayer;
  }
  ping() {
    return c(this, void 0, void 0, function* () {
      var e8;
      oo.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`), yield null === (e8 = this.state.communicationLayer) || void 0 === e8 ? void 0 : e8.ping();
    });
  }
  testLogger() {
    oo.RemoteCommunication(`testLogger() channel=${this.state.channelId}`), oo.SocketService(`testLogger() channel=${this.state.channelId}`), oo.Ecies(`testLogger() channel=${this.state.channelId}`), oo.KeyExchange(`testLogger() channel=${this.state.channelId}`);
  }
  keyCheck() {
    var e8;
    oo.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`), null === (e8 = this.state.communicationLayer) || void 0 === e8 || e8.keyCheck();
  }
  setConnectionStatus(e8) {
    this.state._connectionStatus !== e8 && (this.state._connectionStatus = e8, this.emit(So.CONNECTION_STATUS, e8), this.emitServiceStatusEvent({ context: "setConnectionStatus" }));
  }
  emitServiceStatusEvent(e8 = {}) {
    this.emit(So.SERVICE_STATUS, this.getServiceStatus());
  }
  getConnectionStatus() {
    return this.state._connectionStatus;
  }
  getServiceStatus() {
    return { originatorInfo: this.state.originatorInfo, keyInfo: this.getKeyInfo(), connectionStatus: this.state._connectionStatus, channelConfig: this.state.channelConfig, channelId: this.state.channelId };
  }
  getKeyInfo() {
    var e8;
    return null === (e8 = this.state.communicationLayer) || void 0 === e8 ? void 0 : e8.getKeyInfo();
  }
  resetKeys() {
    var e8;
    null === (e8 = this.state.communicationLayer) || void 0 === e8 || e8.resetKeys();
  }
  setOtherPublicKey(e8) {
    var t3;
    const n2 = null === (t3 = this.state.communicationLayer) || void 0 === t3 ? void 0 : t3.getKeyExchange();
    if (!n2) throw new Error("KeyExchange is not initialized.");
    n2.getOtherPublicKey() !== e8 && n2.setOtherPublicKey(e8);
  }
  pause() {
    return c(this, void 0, void 0, function* () {
      var e8;
      oo.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`), yield null === (e8 = this.state.communicationLayer) || void 0 === e8 ? void 0 : e8.pause(), this.setConnectionStatus(Eo.PAUSED);
    });
  }
  getVersion() {
    return ho.version;
  }
  hasRelayPersistence() {
    var e8;
    return null !== (e8 = this.state.relayPersistence) && void 0 !== e8 && e8;
  }
  resume() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        return c(this, void 0, void 0, function* () {
          var t3;
          const { state: n2 } = e8;
          oo.RemoteCommunication(`[RemoteCommunication: resume()] channel=${n2.channelId}`), yield null === (t3 = n2.communicationLayer) || void 0 === t3 ? void 0 : t3.resume(), e8.setConnectionStatus(Eo.LINKED);
        });
      }(this);
    });
  }
  encrypt(e8) {
    var t3, n2, r3;
    const i2 = null === (t3 = this.state.communicationLayer) || void 0 === t3 ? void 0 : t3.getKeyExchange(), o = null == i2 ? void 0 : i2.getOtherPublicKey();
    if (!o) throw new Error("KeyExchange not completed");
    return null === (r3 = null === (n2 = this.state.communicationLayer) || void 0 === n2 ? void 0 : n2.state.eciesInstance) || void 0 === r3 ? void 0 : r3.encrypt(e8, o);
  }
  decrypt(e8) {
    var t3, n2, r3;
    if (!(null === (t3 = this.state.communicationLayer) || void 0 === t3 ? void 0 : t3.state.eciesInstance)) throw new Error("ECIES instance is not initialized");
    return null === (r3 = null === (n2 = this.state.communicationLayer) || void 0 === n2 ? void 0 : n2.state.eciesInstance) || void 0 === r3 ? void 0 : r3.decrypt(e8);
  }
  getChannelId() {
    return this.state.channelId;
  }
  getRPCMethodTracker() {
    var e8;
    return null === (e8 = this.state.communicationLayer) || void 0 === e8 ? void 0 : e8.getRPCMethodTracker();
  }
  reject({ channelId: e8 }) {
    return function(e9) {
      return c(this, arguments, void 0, function* ({ channelId: e10, state: t3 }) {
        var n2, r3, i2;
        if (!validate_default(e10)) throw oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${t3.context} invalid channel channelId=${e10}`), new Error(`Invalid channel ${e10}`);
        if (t3.isOriginator) return void oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t3.context} isOriginator=${t3.isOriginator} channelId=${e10}`);
        const { socket: s } = null !== (r3 = null === (n2 = t3.communicationLayer) || void 0 === n2 ? void 0 : n2.state) && void 0 !== r3 ? r3 : {};
        (null == s ? void 0 : s.connected) || (oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t3.context} socket already connected`), null == s || s.connect()), lo(Object.assign(Object.assign({ id: e10, event: Ao.REJECTED }, t3.originatorInfo), { sdkVersion: t3.sdkVersion, commLayerVersion: ho.version, walletVersion: null === (i2 = t3.walletInfo) || void 0 === i2 ? void 0 : i2.version }), t3.communicationServerUrl).catch((e11) => {
        }), yield new Promise((n3, r4) => {
          null == s || s.emit(So.REJECTED, { channelId: e10 }, (e11, i3) => {
            oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t3.context} socket=${null == s ? void 0 : s.id}`, { error: e11, response: i3 }), e11 ? r4(e11) : n3(i3);
          });
        });
      });
    }({ channelId: e8, state: this.state });
  }
  disconnect(e8) {
    return c(this, void 0, void 0, function* () {
      return es({ options: e8, instance: this });
    });
  }
};
!function(e8) {
  e8.RENEW = "renew", e8.LINK = "link";
}(Ho || (Ho = {}));
var ns = "ERC721";
var rs = "ERC1155";
var is = { errors: { disconnected: () => "MetaMask: Disconnected from chain. Attempting to connect.", permanentlyDisconnected: () => "MetaMask: Disconnected from MetaMask background. Page reload required.", sendSiteMetadata: () => "MetaMask: Failed to send site metadata. This is an internal error, please report this bug.", unsupportedSync: (e8) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${e8} without a callback parameter.`, invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.", invalidNetworkParams: () => "MetaMask: Received invalid network parameters. Please report this bug.", invalidRequestArgs: () => "Expected a single, non-array, object argument.", invalidRequestMethod: () => "'args.method' must be a non-empty string.", invalidRequestParams: () => "'args.params' must be an object or array if provided.", invalidLoggerObject: () => "'args.logger' must be an object if provided.", invalidLoggerMethod: (e8) => `'args.logger' must include required method '${e8}'.` }, info: { connected: (e8) => `MetaMask: Connected to chain with ID "${e8}".` }, warnings: { chainIdDeprecation: "MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", networkVersionDeprecation: "MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", selectedAddressDeprecation: "MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", enableDeprecation: "MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1102", sendDeprecation: "MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193", events: { close: "MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect", data: "MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message", networkChanged: "MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged", notification: "MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message" }, rpc: { ethDecryptDeprecation: "MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686", ethGetEncryptionPublicKeyDeprecation: "MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686", walletWatchAssetNFTExperimental: "MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle" }, experimentalMethods: "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning." } };
function os(e8) {
  const t3 = { ethDecryptDeprecation: false, ethGetEncryptionPublicKeyDeprecation: false, walletWatchAssetNFTExperimental: false };
  return (n2, r3, i2) => {
    var _a2;
    t3.ethDecryptDeprecation || "eth_decrypt" !== n2.method ? t3.ethGetEncryptionPublicKeyDeprecation || "eth_getEncryptionPublicKey" !== n2.method ? !t3.walletWatchAssetNFTExperimental && "wallet_watchAsset" === n2.method && [ns, rs].includes(((_a2 = n2.params) == null ? void 0 : _a2.type) || "") && (e8.warn(is.warnings.rpc.walletWatchAssetNFTExperimental), t3.walletWatchAssetNFTExperimental = true) : (e8.warn(is.warnings.rpc.ethGetEncryptionPublicKeyDeprecation), t3.ethGetEncryptionPublicKeyDeprecation = true) : (e8.warn(is.warnings.rpc.ethDecryptDeprecation), t3.ethDecryptDeprecation = true), i2();
  };
}
var ss = 4294967295;
var as = Math.floor(Math.random() * ss);
function cs() {
  return (e8, t3, n2, r3) => {
    const i2 = e8.id, o = as = (as + 1) % ss;
    e8.id = o, t3.id = o, n2((n3) => {
      e8.id = i2, t3.id = i2, n3();
    });
  };
}
var ls = (e8, t3, n2) => {
  if (!t3.has(e8)) throw TypeError("Cannot " + n2);
};
var ds = (e8, t3, n2) => (ls(e8, t3, "read from private field"), n2 ? n2.call(e8) : t3.get(e8));
var us = (e8, t3, n2) => {
  if (t3.has(e8)) throw TypeError("Cannot add the same private member more than once");
  t3 instanceof WeakSet ? t3.add(e8) : t3.set(e8, n2);
};
var hs = (e8, t3, n2, r3) => (ls(e8, t3, "write to private field"), t3.set(e8, n2), n2);
var fs = (e8, t3, n2) => (ls(e8, t3, "access private method"), n2);
var ps = { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 };
var gs = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } };
function ms(e8) {
  return Boolean(e8) && "object" == typeof e8 && !Array.isArray(e8);
}
var ys = (e8, t3) => Object.hasOwnProperty.call(e8, t3);
var vs = class extends TypeError {
  constructor(e8, t3) {
    let n2;
    const { message: r3, explanation: i2, ...o } = e8, { path: s } = e8, a = 0 === s.length ? r3 : `At path: ${s.join(".")} -- ${r3}`;
    super(i2 ?? a), null != i2 && (this.cause = a), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => n2 ?? (n2 = [e8, ...t3()]);
  }
};
function bs(e8) {
  return "object" == typeof e8 && null != e8;
}
function ws(e8) {
  return "symbol" == typeof e8 ? e8.toString() : "string" == typeof e8 ? JSON.stringify(e8) : `${e8}`;
}
function Es(e8, t3, n2, r3) {
  if (true === e8) return;
  false === e8 ? e8 = {} : "string" == typeof e8 && (e8 = { message: e8 });
  const { path: i2, branch: o } = t3, { type: s } = n2, { refinement: a, message: c2 = `Expected a value of type \`${s}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${ws(r3)}\`` } = e8;
  return { value: r3, type: s, refinement: a, key: i2[i2.length - 1], path: i2, branch: o, ...e8, message: c2 };
}
function* Ss(e8, t3, n2, r3) {
  (function(e9) {
    return bs(e9) && "function" == typeof e9[Symbol.iterator];
  })(e8) || (e8 = [e8]);
  for (const i2 of e8) {
    const e9 = Es(i2, t3, n2, r3);
    e9 && (yield e9);
  }
}
function* _s(e8, t3, n2 = {}) {
  const { path: r3 = [], branch: i2 = [e8], coerce: o = false, mask: s = false } = n2, a = { path: r3, branch: i2 };
  if (o && (e8 = t3.coercer(e8, a), s && "type" !== t3.type && bs(t3.schema) && bs(e8) && !Array.isArray(e8))) for (const n3 in e8) void 0 === t3.schema[n3] && delete e8[n3];
  let c2 = "valid";
  for (const r4 of t3.validator(e8, a)) r4.explanation = n2.message, c2 = "not_valid", yield [r4, void 0];
  for (let [l3, d3, u2] of t3.entries(e8, a)) {
    const t4 = _s(d3, u2, { path: void 0 === l3 ? r3 : [...r3, l3], branch: void 0 === l3 ? i2 : [...i2, d3], coerce: o, mask: s, message: n2.message });
    for (const n3 of t4) n3[0] ? (c2 = null != n3[0].refinement ? "not_refined" : "not_valid", yield [n3[0], void 0]) : o && (d3 = n3[1], void 0 === l3 ? e8 = d3 : e8 instanceof Map ? e8.set(l3, d3) : e8 instanceof Set ? e8.add(d3) : bs(e8) && (void 0 !== d3 || l3 in e8) && (e8[l3] = d3));
  }
  if ("not_valid" !== c2) for (const r4 of t3.refiner(e8, a)) r4.explanation = n2.message, c2 = "not_refined", yield [r4, void 0];
  "valid" === c2 && (yield [void 0, e8]);
}
var Cs = class {
  constructor(e8) {
    const { type: t3, schema: n2, validator: r3, refiner: i2, coercer: o = (e9) => e9, entries: s = function* () {
    } } = e8;
    this.type = t3, this.schema = n2, this.entries = s, this.coercer = o, this.validator = r3 ? (e9, t4) => Ss(r3(e9, t4), t4, this, e9) : () => [], this.refiner = i2 ? (e9, t4) => Ss(i2(e9, t4), t4, this, e9) : () => [];
  }
  assert(e8, t3) {
    return ks(e8, this, t3);
  }
  create(e8, t3) {
    return As(e8, this, t3);
  }
  is(e8) {
    return xs(e8, this);
  }
  mask(e8, t3) {
    return function(e9, t4, n2) {
      const r3 = Ms(e9, t4, { coerce: true, mask: true, message: n2 });
      if (r3[0]) throw r3[0];
      return r3[1];
    }(e8, this, t3);
  }
  validate(e8, t3 = {}) {
    return Ms(e8, this, t3);
  }
};
function ks(e8, t3, n2) {
  const r3 = Ms(e8, t3, { message: n2 });
  if (r3[0]) throw r3[0];
}
function As(e8, t3, n2) {
  const r3 = Ms(e8, t3, { coerce: true, message: n2 });
  if (r3[0]) throw r3[0];
  return r3[1];
}
function xs(e8, t3) {
  return !Ms(e8, t3)[0];
}
function Ms(e8, t3, n2 = {}) {
  const r3 = _s(e8, t3, n2), i2 = function(e9) {
    const { done: t4, value: n3 } = e9.next();
    return t4 ? void 0 : n3;
  }(r3);
  if (i2[0]) {
    const e9 = new vs(i2[0], function* () {
      for (const e10 of r3) e10[0] && (yield e10[0]);
    });
    return [e9, void 0];
  }
  return [void 0, i2[1]];
}
function Is(e8, t3) {
  return new Cs({ type: e8, schema: null, validator: t3 });
}
function Ts(e8) {
  let t3;
  return new Cs({ type: "lazy", schema: null, *entries(n2, r3) {
    t3 ?? (t3 = e8()), yield* t3.entries(n2, r3);
  }, validator: (n2, r3) => (t3 ?? (t3 = e8()), t3.validator(n2, r3)), coercer: (n2, r3) => (t3 ?? (t3 = e8()), t3.coercer(n2, r3)), refiner: (n2, r3) => (t3 ?? (t3 = e8()), t3.refiner(n2, r3)) });
}
function Rs(e8) {
  return new Cs({ type: "array", schema: e8, *entries(t3) {
    if (e8 && Array.isArray(t3)) for (const [n2, r3] of t3.entries()) yield [n2, r3, e8];
  }, coercer: (e9) => Array.isArray(e9) ? e9.slice() : e9, validator: (e9) => Array.isArray(e9) || `Expected an array value, but received: ${ws(e9)}` });
}
function Ps(e8) {
  const t3 = ws(e8), n2 = typeof e8;
  return new Cs({ type: "literal", schema: "string" === n2 || "number" === n2 || "boolean" === n2 ? e8 : null, validator: (n3) => n3 === e8 || `Expected the literal \`${t3}\`, but received: ${ws(n3)}` });
}
function Os() {
  return Is("number", (e8) => "number" == typeof e8 && !isNaN(e8) || `Expected a number, but received: ${ws(e8)}`);
}
function Ns(e8) {
  const t3 = e8 ? Object.keys(e8) : [], n2 = Is("never", () => false);
  return new Cs({ type: "object", schema: e8 || null, *entries(r3) {
    if (e8 && bs(r3)) {
      const i2 = new Set(Object.keys(r3));
      for (const n3 of t3) i2.delete(n3), yield [n3, r3[n3], e8[n3]];
      for (const e9 of i2) yield [e9, r3[e9], n2];
    }
  }, validator: (e9) => bs(e9) || `Expected an object, but received: ${ws(e9)}`, coercer: (e9) => bs(e9) ? { ...e9 } : e9 });
}
function Ls(e8) {
  return new Cs({ ...e8, validator: (t3, n2) => void 0 === t3 || e8.validator(t3, n2), refiner: (t3, n2) => void 0 === t3 || e8.refiner(t3, n2) });
}
function Ds(e8, t3) {
  return new Cs({ type: "record", schema: null, *entries(n2) {
    if (bs(n2)) for (const r3 in n2) {
      const i2 = n2[r3];
      yield [r3, r3, e8], yield [r3, i2, t3];
    }
  }, validator: (e9) => bs(e9) || `Expected an object, but received: ${ws(e9)}` });
}
function $s() {
  return Is("string", (e8) => "string" == typeof e8 || `Expected a string, but received: ${ws(e8)}`);
}
function Bs(e8) {
  const t3 = e8.map((e9) => e9.type).join(" | ");
  return new Cs({ type: "union", schema: null, coercer(t4) {
    for (const n2 of e8) {
      const [e9, r3] = n2.validate(t4, { coerce: true });
      if (!e9) return r3;
    }
    return t4;
  }, validator(n2, r3) {
    const i2 = [];
    for (const t4 of e8) {
      const [...e9] = _s(n2, t4, r3), [o] = e9;
      if (!o[0]) return [];
      for (const [t5] of e9) t5 && i2.push(t5);
    }
    return [`Expected the value to satisfy a union of \`${t3}\`, but received: ${ws(n2)}`, ...i2];
  } });
}
function Ks(e8) {
  return function(e9) {
    return function(e10) {
      return "object" == typeof e10 && null !== e10 && "message" in e10;
    }(e9) && "string" == typeof e9.message ? e9.message : null == e9 ? "" : String(e9);
  }(e8).replace(/\.$/u, "");
}
function js(e8, t3) {
  var _a2, _b;
  return n2 = e8, Boolean("string" == typeof ((_b = (_a2 = n2 == null ? void 0 : n2.prototype) == null ? void 0 : _a2.constructor) == null ? void 0 : _b.name)) ? new e8({ message: t3 }) : e8({ message: t3 });
  var n2;
}
var Us = class extends Error {
  constructor(e8) {
    super(e8.message), this.code = "ERR_ASSERTION";
  }
};
function Hs() {
  throw new Error("setTimeout has not been defined");
}
function Fs() {
  throw new Error("clearTimeout has not been defined");
}
var zs = Hs;
var qs = Fs;
function Ws(e8) {
  if (zs === setTimeout) return setTimeout(e8, 0);
  if ((zs === Hs || !zs) && setTimeout) return zs = setTimeout, setTimeout(e8, 0);
  try {
    return zs(e8, 0);
  } catch (t3) {
    try {
      return zs.call(null, e8, 0);
    } catch (t4) {
      return zs.call(this, e8, 0);
    }
  }
}
"function" == typeof l.setTimeout && (zs = setTimeout), "function" == typeof l.clearTimeout && (qs = clearTimeout);
var Vs;
var Gs = [];
var Ys = false;
var Zs = -1;
function Js() {
  Ys && Vs && (Ys = false, Vs.length ? Gs = Vs.concat(Gs) : Zs = -1, Gs.length && Qs());
}
function Qs() {
  if (!Ys) {
    var e8 = Ws(Js);
    Ys = true;
    for (var t3 = Gs.length; t3; ) {
      for (Vs = Gs, Gs = []; ++Zs < t3; ) Vs && Vs[Zs].run();
      Zs = -1, t3 = Gs.length;
    }
    Vs = null, Ys = false, function(e9) {
      if (qs === clearTimeout) return clearTimeout(e9);
      if ((qs === Fs || !qs) && clearTimeout) return qs = clearTimeout, clearTimeout(e9);
      try {
        return qs(e9);
      } catch (t4) {
        try {
          return qs.call(null, e9);
        } catch (t5) {
          return qs.call(this, e9);
        }
      }
    }(e8);
  }
}
function Xs(e8, t3) {
  this.fun = e8, this.array = t3;
}
Xs.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function ea() {
}
var ta = ea;
var na = ea;
var ra = ea;
var ia = ea;
var oa = ea;
var sa = ea;
var aa = ea;
var ca = l.performance || {};
var la = ca.now || ca.mozNow || ca.msNow || ca.oNow || ca.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
var da = /* @__PURE__ */ new Date();
var ua = { nextTick: function(e8) {
  var t3 = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var n2 = 1; n2 < arguments.length; n2++) t3[n2 - 1] = arguments[n2];
  Gs.push(new Xs(e8, t3)), 1 !== Gs.length || Ys || Ws(Qs);
}, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: ta, addListener: na, once: ra, off: ia, removeListener: oa, removeAllListeners: sa, emit: aa, binding: function(e8) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e8) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e8) {
  var t3 = 1e-3 * la.call(ca), n2 = Math.floor(t3), r3 = Math.floor(t3 % 1 * 1e9);
  return e8 && (n2 -= e8[0], (r3 -= e8[1]) < 0 && (n2--, r3 += 1e9)), [n2, r3];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (/* @__PURE__ */ new Date() - da) / 1e3;
} };
var ha = (e8) => Ns(e8);
function fa({ path: e8, branch: t3 }) {
  const n2 = e8[e8.length - 1];
  return ys(t3[t3.length - 2], n2);
}
function pa(e8) {
  return new Cs({ ...e8, type: `optional ${e8.type}`, validator: (t3, n2) => !fa(n2) || e8.validator(t3, n2), refiner: (t3, n2) => !fa(n2) || e8.refiner(t3, n2) });
}
var ga;
var ma;
var ya;
var va = Bs([Ps(null), Is("boolean", (e8) => "boolean" == typeof e8), Is("finite number", (e8) => xs(e8, Os()) && Number.isFinite(e8)), $s(), Rs(Ts(() => va)), Ds($s(), Ts(() => va))]);
var ba = (ga = va, ma = Is("any", () => true), ya = (e8) => (function(e9, t3, n2 = "Assertion failed", r3 = Us) {
  try {
    ks(e9, t3);
  } catch (e10) {
    throw js(r3, `${n2}: ${Ks(e10)}.`);
  }
}(e8, va), JSON.parse(JSON.stringify(e8, (e9, t3) => {
  if ("__proto__" !== e9 && "constructor" !== e9) return t3;
}))), new Cs({ ...ga, coercer: (e8, t3) => xs(e8, ma) ? ga.coercer(ya(e8, t3), t3) : ga.coercer(e8, t3) }));
function wa(e8) {
  try {
    return function(e9) {
      As(e9, ba);
    }(e8), true;
  } catch {
    return false;
  }
}
var Ea = Ps("2.0");
var Sa = function(e8) {
  return new Cs({ ...e8, validator: (t3, n2) => null === t3 || e8.validator(t3, n2), refiner: (t3, n2) => null === t3 || e8.refiner(t3, n2) });
}(Bs([Os(), $s()]));
var _a = ha({ code: Is("integer", (e8) => "number" == typeof e8 && !isNaN(e8) && Number.isInteger(e8) || `Expected an integer, but received: ${ws(e8)}`), message: $s(), data: pa(ba), stack: pa($s()) });
var Ca = Bs([Ds($s(), ba), Rs(ba)]);
var ka = ha({ id: Sa, jsonrpc: Ea, method: $s(), params: pa(Ca) });
var Aa = ha({ jsonrpc: Ea, method: $s(), params: pa(Ca) });
function xa(e8) {
  return xs(e8, ka);
}
function Ma(e8) {
  return xs(e8, _a);
}
Ns({ id: Sa, jsonrpc: Ea, result: Ls(Is("unknown", () => true)), error: Ls(_a) }), Bs([ha({ id: Sa, jsonrpc: Ea, result: ba }), ha({ id: Sa, jsonrpc: Ea, error: _a })]);
var Ia = ps.internal;
var Ta = "Unspecified error message. This is a bug, please report it.";
var Ra = { code: Ia, message: Oa(Ia) };
var Pa = "Unspecified server error.";
function Oa(e8, t3 = Ta) {
  if (function(e9) {
    return Number.isInteger(e9);
  }(e8)) {
    const t4 = e8.toString();
    if (ys(gs, t4)) return gs[t4].message;
    if (function(e9) {
      return e9 >= -32099 && e9 <= -32e3;
    }(e8)) return Pa;
  }
  return t3;
}
function Na(e8, { fallbackError: t3 = Ra, shouldIncludeStack: n2 = true } = {}) {
  if (!Ma(t3)) throw new Error("Must provide fallback error with integer number code and string message.");
  const r3 = function(e9, t4) {
    if (e9 && "object" == typeof e9 && "serialize" in e9 && "function" == typeof e9.serialize) return e9.serialize();
    if (Ma(e9)) return e9;
    const n3 = La(e9), r4 = { ...t4, data: { cause: n3 } };
    return r4;
  }(e8, t3);
  return n2 || delete r3.stack, r3;
}
function La(e8) {
  return Array.isArray(e8) ? e8.map((e9) => wa(e9) ? e9 : ms(e9) ? Da(e9) : null) : ms(e8) ? Da(e8) : wa(e8) ? e8 : null;
}
function Da(e8) {
  return Object.getOwnPropertyNames(e8).reduce((t3, n2) => {
    const r3 = e8[n2];
    return wa(r3) && (t3[n2] = r3), t3;
  }, {});
}
var $a = Fa;
Fa.default = Fa, Fa.stable = Va, Fa.stableStringify = Va;
var Ba = "[...]";
var Ka = "[Circular]";
var ja = [];
var Ua = [];
function Ha() {
  return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
}
function Fa(e8, t3, n2, r3) {
  var i2;
  void 0 === r3 && (r3 = Ha()), qa(e8, "", 0, [], void 0, 0, r3);
  try {
    i2 = 0 === Ua.length ? JSON.stringify(e8, t3, n2) : JSON.stringify(e8, Ya(t3), n2);
  } catch (e9) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; 0 !== ja.length; ) {
      var o = ja.pop();
      4 === o.length ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2];
    }
  }
  return i2;
}
function za(e8, t3, n2, r3) {
  var i2 = Object.getOwnPropertyDescriptor(r3, n2);
  void 0 !== i2.get ? i2.configurable ? (Object.defineProperty(r3, n2, { value: e8 }), ja.push([r3, n2, t3, i2])) : Ua.push([t3, n2, e8]) : (r3[n2] = e8, ja.push([r3, n2, t3]));
}
function qa(e8, t3, n2, r3, i2, o, s) {
  var a;
  if (o += 1, "object" == typeof e8 && null !== e8) {
    for (a = 0; a < r3.length; a++) if (r3[a] === e8) return void za(Ka, e8, t3, i2);
    if (void 0 !== s.depthLimit && o > s.depthLimit) return void za(Ba, e8, t3, i2);
    if (void 0 !== s.edgesLimit && n2 + 1 > s.edgesLimit) return void za(Ba, e8, t3, i2);
    if (r3.push(e8), Array.isArray(e8)) for (a = 0; a < e8.length; a++) qa(e8[a], a, a, r3, e8, o, s);
    else {
      var c2 = Object.keys(e8);
      for (a = 0; a < c2.length; a++) {
        var l3 = c2[a];
        qa(e8[l3], l3, a, r3, e8, o, s);
      }
    }
    r3.pop();
  }
}
function Wa(e8, t3) {
  return e8 < t3 ? -1 : e8 > t3 ? 1 : 0;
}
function Va(e8, t3, n2, r3) {
  void 0 === r3 && (r3 = Ha());
  var i2, o = Ga(e8, "", 0, [], void 0, 0, r3) || e8;
  try {
    i2 = 0 === Ua.length ? JSON.stringify(o, t3, n2) : JSON.stringify(o, Ya(t3), n2);
  } catch (e9) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; 0 !== ja.length; ) {
      var s = ja.pop();
      4 === s.length ? Object.defineProperty(s[0], s[1], s[3]) : s[0][s[1]] = s[2];
    }
  }
  return i2;
}
function Ga(e8, t3, n2, r3, i2, o, s) {
  var a;
  if (o += 1, "object" == typeof e8 && null !== e8) {
    for (a = 0; a < r3.length; a++) if (r3[a] === e8) return void za(Ka, e8, t3, i2);
    try {
      if ("function" == typeof e8.toJSON) return;
    } catch (e9) {
      return;
    }
    if (void 0 !== s.depthLimit && o > s.depthLimit) return void za(Ba, e8, t3, i2);
    if (void 0 !== s.edgesLimit && n2 + 1 > s.edgesLimit) return void za(Ba, e8, t3, i2);
    if (r3.push(e8), Array.isArray(e8)) for (a = 0; a < e8.length; a++) Ga(e8[a], a, a, r3, e8, o, s);
    else {
      var c2 = {}, l3 = Object.keys(e8).sort(Wa);
      for (a = 0; a < l3.length; a++) {
        var d3 = l3[a];
        Ga(e8[d3], d3, a, r3, e8, o, s), c2[d3] = e8[d3];
      }
      if (void 0 === i2) return c2;
      ja.push([i2, t3, e8]), i2[t3] = c2;
    }
    r3.pop();
  }
}
function Ya(e8) {
  return e8 = void 0 !== e8 ? e8 : function(e9, t3) {
    return t3;
  }, function(t3, n2) {
    if (Ua.length > 0) for (var r3 = 0; r3 < Ua.length; r3++) {
      var i2 = Ua[r3];
      if (i2[1] === t3 && i2[0] === n2) {
        n2 = i2[2], Ua.splice(r3, 1);
        break;
      }
    }
    return e8.call(this, t3, n2);
  };
}
var Za = ue($a);
var Ja = class extends Error {
  constructor(e8, t3, n2) {
    if (!Number.isInteger(e8)) throw new Error('"code" must be an integer.');
    if (!t3 || "string" != typeof t3) throw new Error('"message" must be a non-empty string.');
    super(t3), this.code = e8, void 0 !== n2 && (this.data = n2);
  }
  serialize() {
    const e8 = { code: this.code, message: this.message };
    return void 0 !== this.data && (e8.data = this.data, function(e9) {
      if ("object" != typeof e9 || null === e9) return false;
      try {
        let t3 = e9;
        for (; null !== Object.getPrototypeOf(t3); ) t3 = Object.getPrototypeOf(t3);
        return Object.getPrototypeOf(e9) === t3;
      } catch (e10) {
        return false;
      }
    }(this.data) && (e8.data.cause = La(this.data.cause))), this.stack && (e8.stack = this.stack), e8;
  }
  toString() {
    return Za(this.serialize(), Qa, 2);
  }
};
function Qa(e8, t3) {
  if ("[Circular]" !== t3) return t3;
}
var Xa = (e8) => ec(ps.invalidRequest, e8);
function ec(e8, t3) {
  const [n2, r3] = function(e9) {
    if (e9) {
      if ("string" == typeof e9) return [e9];
      if ("object" == typeof e9 && !Array.isArray(e9)) {
        const { message: t4, data: n3 } = e9;
        if (t4 && "string" != typeof t4) throw new Error("Must specify string message.");
        return [t4 ?? void 0, n3];
      }
    }
    return [];
  }(t3);
  return new Ja(e8, n2 ?? Oa(e8), r3);
}
var tc = {};
function nc() {
}
function rc() {
  rc.init.call(this);
}
function ic(e8) {
  return void 0 === e8._maxListeners ? rc.defaultMaxListeners : e8._maxListeners;
}
function oc(e8, t3, n2, r3) {
  var i2, o, s;
  if ("function" != typeof n2) throw new TypeError('"listener" argument must be a function');
  if ((o = e8._events) ? (o.newListener && (e8.emit("newListener", t3, n2.listener ? n2.listener : n2), o = e8._events), s = o[t3]) : (o = e8._events = new nc(), e8._eventsCount = 0), s) {
    if ("function" == typeof s ? s = o[t3] = r3 ? [n2, s] : [s, n2] : r3 ? s.unshift(n2) : s.push(n2), !s.warned && (i2 = ic(e8)) && i2 > 0 && s.length > i2) {
      s.warned = true;
      var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + t3 + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a.name = "MaxListenersExceededWarning", a.emitter = e8, a.type = t3, a.count = s.length, function(e9) {
        "function" == typeof console.warn ? console.warn(e9) : console.log(e9);
      }(a);
    }
  } else s = o[t3] = n2, ++e8._eventsCount;
  return e8;
}
function sc(e8, t3, n2) {
  var r3 = false;
  function i2() {
    e8.removeListener(t3, i2), r3 || (r3 = true, n2.apply(e8, arguments));
  }
  return i2.listener = n2, i2;
}
function ac(e8) {
  var t3 = this._events;
  if (t3) {
    var n2 = t3[e8];
    if ("function" == typeof n2) return 1;
    if (n2) return n2.length;
  }
  return 0;
}
function cc(e8, t3) {
  for (var n2 = new Array(t3); t3--; ) n2[t3] = e8[t3];
  return n2;
}
nc.prototype = /* @__PURE__ */ Object.create(null), rc.EventEmitter = rc, rc.usingDomains = false, rc.prototype.domain = void 0, rc.prototype._events = void 0, rc.prototype._maxListeners = void 0, rc.defaultMaxListeners = 10, rc.init = function() {
  this.domain = null, rc.usingDomains && (void 0).active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new nc(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, rc.prototype.setMaxListeners = function(e8) {
  if ("number" != typeof e8 || e8 < 0 || isNaN(e8)) throw new TypeError('"n" argument must be a positive number');
  return this._maxListeners = e8, this;
}, rc.prototype.getMaxListeners = function() {
  return ic(this);
}, rc.prototype.emit = function(e8) {
  var t3, n2, r3, i2, o, s, a, c2 = "error" === e8;
  if (s = this._events) c2 = c2 && null == s.error;
  else if (!c2) return false;
  if (a = this.domain, c2) {
    if (t3 = arguments[1], !a) {
      if (t3 instanceof Error) throw t3;
      var l3 = new Error('Uncaught, unspecified "error" event. (' + t3 + ")");
      throw l3.context = t3, l3;
    }
    return t3 || (t3 = new Error('Uncaught, unspecified "error" event')), t3.domainEmitter = this, t3.domain = a, t3.domainThrown = false, a.emit("error", t3), false;
  }
  if (!(n2 = s[e8])) return false;
  var d3 = "function" == typeof n2;
  switch (r3 = arguments.length) {
    case 1:
      !function(e9, t4, n3) {
        if (t4) e9.call(n3);
        else for (var r4 = e9.length, i3 = cc(e9, r4), o2 = 0; o2 < r4; ++o2) i3[o2].call(n3);
      }(n2, d3, this);
      break;
    case 2:
      !function(e9, t4, n3, r4) {
        if (t4) e9.call(n3, r4);
        else for (var i3 = e9.length, o2 = cc(e9, i3), s2 = 0; s2 < i3; ++s2) o2[s2].call(n3, r4);
      }(n2, d3, this, arguments[1]);
      break;
    case 3:
      !function(e9, t4, n3, r4, i3) {
        if (t4) e9.call(n3, r4, i3);
        else for (var o2 = e9.length, s2 = cc(e9, o2), a2 = 0; a2 < o2; ++a2) s2[a2].call(n3, r4, i3);
      }(n2, d3, this, arguments[1], arguments[2]);
      break;
    case 4:
      !function(e9, t4, n3, r4, i3, o2) {
        if (t4) e9.call(n3, r4, i3, o2);
        else for (var s2 = e9.length, a2 = cc(e9, s2), c3 = 0; c3 < s2; ++c3) a2[c3].call(n3, r4, i3, o2);
      }(n2, d3, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      for (i2 = new Array(r3 - 1), o = 1; o < r3; o++) i2[o - 1] = arguments[o];
      !function(e9, t4, n3, r4) {
        if (t4) e9.apply(n3, r4);
        else for (var i3 = e9.length, o2 = cc(e9, i3), s2 = 0; s2 < i3; ++s2) o2[s2].apply(n3, r4);
      }(n2, d3, this, i2);
  }
  return true;
}, rc.prototype.addListener = function(e8, t3) {
  return oc(this, e8, t3, false);
}, rc.prototype.on = rc.prototype.addListener, rc.prototype.prependListener = function(e8, t3) {
  return oc(this, e8, t3, true);
}, rc.prototype.once = function(e8, t3) {
  if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
  return this.on(e8, sc(this, e8, t3)), this;
}, rc.prototype.prependOnceListener = function(e8, t3) {
  if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
  return this.prependListener(e8, sc(this, e8, t3)), this;
}, rc.prototype.removeListener = function(e8, t3) {
  var n2, r3, i2, o, s;
  if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
  if (!(r3 = this._events)) return this;
  if (!(n2 = r3[e8])) return this;
  if (n2 === t3 || n2.listener && n2.listener === t3) 0 == --this._eventsCount ? this._events = new nc() : (delete r3[e8], r3.removeListener && this.emit("removeListener", e8, n2.listener || t3));
  else if ("function" != typeof n2) {
    for (i2 = -1, o = n2.length; o-- > 0; ) if (n2[o] === t3 || n2[o].listener && n2[o].listener === t3) {
      s = n2[o].listener, i2 = o;
      break;
    }
    if (i2 < 0) return this;
    if (1 === n2.length) {
      if (n2[0] = void 0, 0 == --this._eventsCount) return this._events = new nc(), this;
      delete r3[e8];
    } else !function(e9, t4) {
      for (var n3 = t4, r4 = n3 + 1, i3 = e9.length; r4 < i3; n3 += 1, r4 += 1) e9[n3] = e9[r4];
      e9.pop();
    }(n2, i2);
    r3.removeListener && this.emit("removeListener", e8, s || t3);
  }
  return this;
}, rc.prototype.off = function(e8, t3) {
  return this.removeListener(e8, t3);
}, rc.prototype.removeAllListeners = function(e8) {
  var t3, n2;
  if (!(n2 = this._events)) return this;
  if (!n2.removeListener) return 0 === arguments.length ? (this._events = new nc(), this._eventsCount = 0) : n2[e8] && (0 == --this._eventsCount ? this._events = new nc() : delete n2[e8]), this;
  if (0 === arguments.length) {
    for (var r3, i2 = Object.keys(n2), o = 0; o < i2.length; ++o) "removeListener" !== (r3 = i2[o]) && this.removeAllListeners(r3);
    return this.removeAllListeners("removeListener"), this._events = new nc(), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t3 = n2[e8])) this.removeListener(e8, t3);
  else if (t3) do {
    this.removeListener(e8, t3[t3.length - 1]);
  } while (t3[0]);
  return this;
}, rc.prototype.listeners = function(e8) {
  var t3, n2, r3 = this._events;
  return n2 = r3 && (t3 = r3[e8]) ? "function" == typeof t3 ? [t3.listener || t3] : function(e9) {
    for (var t4 = new Array(e9.length), n3 = 0; n3 < t4.length; ++n3) t4[n3] = e9[n3].listener || e9[n3];
    return t4;
  }(t3) : [], n2;
}, rc.listenerCount = function(e8, t3) {
  return "function" == typeof e8.listenerCount ? e8.listenerCount(t3) : ac.call(e8, t3);
}, rc.prototype.listenerCount = ac, rc.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
var lc = he(Object.freeze({ __proto__: null, EventEmitter: rc, default: rc }));
Object.defineProperty(tc, "__esModule", { value: true });
var dc = lc;
function uc(e8, t3, n2) {
  try {
    Reflect.apply(e8, t3, n2);
  } catch (e9) {
    setTimeout(() => {
      throw e9;
    });
  }
}
var hc = class extends dc.EventEmitter {
  emit(e8, ...t3) {
    let n2 = "error" === e8;
    const r3 = this._events;
    if (void 0 !== r3) n2 = n2 && void 0 === r3.error;
    else if (!n2) return false;
    if (n2) {
      let e9;
      if (t3.length > 0 && ([e9] = t3), e9 instanceof Error) throw e9;
      const n3 = new Error("Unhandled error." + (e9 ? ` (${e9.message})` : ""));
      throw n3.context = e9, n3;
    }
    const i2 = r3[e8];
    if (void 0 === i2) return false;
    if ("function" == typeof i2) uc(i2, this, t3);
    else {
      const e9 = i2.length, n3 = function(e10) {
        const t4 = e10.length, n4 = new Array(t4);
        for (let r4 = 0; r4 < t4; r4 += 1) n4[r4] = e10[r4];
        return n4;
      }(i2);
      for (let r4 = 0; r4 < e9; r4 += 1) uc(n3[r4], this, t3);
    }
    return true;
  }
};
var fc;
var pc;
var gc;
var mc;
var yc;
var vc;
var bc;
var wc;
var Ec;
var Sc;
var _c;
var Cc;
var kc;
var Ac;
var xc;
var Mc;
var Ic;
var Tc;
var Rc;
var Pc = tc.default = hc;
var Oc = class e2 extends Pc {
  constructor({ notificationHandler: e8 } = {}) {
    super(), us(this, mc), us(this, vc), us(this, wc), us(this, fc, false), us(this, pc, void 0), us(this, gc, void 0), hs(this, pc, []), hs(this, gc, e8);
  }
  destroy() {
    ds(this, pc).forEach((e8) => {
      "destroy" in e8 && "function" == typeof e8.destroy && e8.destroy();
    }), hs(this, pc, []), hs(this, fc, true);
  }
  push(e8) {
    fs(this, mc, yc).call(this), ds(this, pc).push(e8);
  }
  handle(e8, t3) {
    if (fs(this, mc, yc).call(this), t3 && "function" != typeof t3) throw new Error('"callback" must be a function if provided.');
    return Array.isArray(e8) ? t3 ? fs(this, vc, bc).call(this, e8, t3) : fs(this, vc, bc).call(this, e8) : t3 ? fs(this, wc, Ec).call(this, e8, t3) : this._promiseHandle(e8);
  }
  asMiddleware() {
    return fs(this, mc, yc).call(this), async (t3, n2, r3, i2) => {
      var o, s;
      try {
        const [a, c2, l3] = await fs(o = e2, Cc, kc).call(o, t3, n2, ds(this, pc));
        return c2 ? (await fs(s = e2, Mc, Ic).call(s, l3), i2(a)) : r3(async (t4) => {
          var n3;
          try {
            await fs(n3 = e2, Mc, Ic).call(n3, l3);
          } catch (e8) {
            return t4(e8);
          }
          return t4();
        });
      } catch (e8) {
        return i2(e8);
      }
    };
  }
  async _promiseHandle(e8) {
    return new Promise((t3, n2) => {
      fs(this, wc, Ec).call(this, e8, (e9, r3) => {
        e9 && void 0 === r3 ? n2(e9) : t3(r3);
      }).catch(n2);
    });
  }
};
fc = /* @__PURE__ */ new WeakMap(), pc = /* @__PURE__ */ new WeakMap(), gc = /* @__PURE__ */ new WeakMap(), mc = /* @__PURE__ */ new WeakSet(), yc = function() {
  if (ds(this, fc)) throw new Error("This engine is destroyed and can no longer be used.");
}, vc = /* @__PURE__ */ new WeakSet(), bc = async function(e8, t3) {
  try {
    if (0 === e8.length) {
      const e9 = [{ id: null, jsonrpc: "2.0", error: new Ja(ps.invalidRequest, "Request batch must contain plain objects. Received an empty array") }];
      return t3 ? t3(null, e9) : e9;
    }
    const n2 = (await Promise.all(e8.map(this._promiseHandle.bind(this)))).filter((e9) => void 0 !== e9);
    return t3 ? t3(null, n2) : n2;
  } catch (e9) {
    if (t3) return t3(e9);
    throw e9;
  }
}, wc = /* @__PURE__ */ new WeakSet(), Ec = async function(e8, t3) {
  var n2;
  if (!e8 || Array.isArray(e8) || "object" != typeof e8) {
    const n3 = new Ja(ps.invalidRequest, "Requests must be plain objects. Received: " + typeof e8, { request: e8 });
    return t3(n3, { id: null, jsonrpc: "2.0", error: n3 });
  }
  if ("string" != typeof e8.method) {
    const n3 = new Ja(ps.invalidRequest, "Must specify a string method. Received: " + typeof e8.method, { request: e8 });
    return ds(this, gc) && !xa(e8) ? t3(null) : t3(n3, { id: e8.id ?? null, jsonrpc: "2.0", error: n3 });
  }
  if (ds(this, gc) && xs(e8, Aa) && !xa(e8)) {
    try {
      await ds(this, gc).call(this, e8);
    } catch (e9) {
      return t3(e9);
    }
    return t3(null);
  }
  let r3 = null;
  const i2 = { ...e8 }, o = { id: i2.id, jsonrpc: i2.jsonrpc };
  try {
    await fs(n2 = Oc, Sc, _c).call(n2, i2, o, ds(this, pc));
  } catch (e9) {
    r3 = e9;
  }
  return r3 && (delete o.result, o.error || (o.error = Na(r3))), t3(r3, o);
}, Sc = /* @__PURE__ */ new WeakSet(), _c = async function(e8, t3, n2) {
  var r3, i2, o;
  const [s, a, c2] = await fs(r3 = Oc, Cc, kc).call(r3, e8, t3, n2);
  if (fs(i2 = Oc, Tc, Rc).call(i2, e8, t3, a), await fs(o = Oc, Mc, Ic).call(o, c2), s) throw s;
}, Cc = /* @__PURE__ */ new WeakSet(), kc = async function(e8, t3, n2) {
  var r3;
  const i2 = [];
  let o = null, s = false;
  for (const a of n2) if ([o, s] = await fs(r3 = Oc, Ac, xc).call(r3, e8, t3, a, i2), s) break;
  return [o, s, i2.reverse()];
}, Ac = /* @__PURE__ */ new WeakSet(), xc = async function(e8, t3, n2, r3) {
  return new Promise((i2) => {
    const o = (e9) => {
      const n3 = e9 || t3.error;
      n3 && (t3.error = Na(n3)), i2([n3, true]);
    }, s = (n3) => {
      t3.error ? o(t3.error) : (n3 && ("function" != typeof n3 && o(new Ja(ps.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof n3}" for request:
${Lc(e8)}`, { request: e8 })), r3.push(n3)), i2([null, false]));
    };
    try {
      n2(e8, t3, s, o);
    } catch (e9) {
      o(e9);
    }
  });
}, Mc = /* @__PURE__ */ new WeakSet(), Ic = async function(e8) {
  for (const t3 of e8) await new Promise((e9, n2) => {
    t3((t4) => t4 ? n2(t4) : e9());
  });
}, Tc = /* @__PURE__ */ new WeakSet(), Rc = function(e8, t3, n2) {
  if (!ys(t3, "result") && !ys(t3, "error")) throw new Ja(ps.internal, `JsonRpcEngine: Response has no error or result for request:
${Lc(e8)}`, { request: e8 });
  if (!n2) throw new Ja(ps.internal, `JsonRpcEngine: Nothing ended request:
${Lc(e8)}`, { request: e8 });
}, us(Oc, Sc), us(Oc, Cc), us(Oc, Ac), us(Oc, Mc), us(Oc, Tc);
var Nc = Oc;
function Lc(e8) {
  return JSON.stringify(e8, null, 2);
}
var Dc = Object.freeze(["eth_subscription"]);
var $c = (e8 = console) => [cs(), Bc(e8), os(e8)];
function Bc(e8) {
  return (t3, n2, r3) => {
    "string" == typeof t3.method && t3.method || (n2.error = Xa({ message: "The request 'method' must be a non-empty string.", data: t3 })), r3((t4) => {
      const { error: r4 } = n2;
      return r4 ? (e8.error(`MetaMask - RPC Error: ${r4.message}`, r4), t4()) : t4();
    });
  };
}
var Kc = (e8, t3, n2 = true) => (r3, i2) => {
  r3 || i2.error ? t3(r3 || i2.error) : !n2 || Array.isArray(i2) ? e8(i2) : e8(i2.result);
};
var jc = (e8) => Boolean(e8) && "string" == typeof e8 && e8.startsWith("0x");
var Uc = () => {
};
async function Hc(e8, t3) {
  try {
    const t4 = await async function() {
      return { name: Fc(window), icon: await zc(window) };
    }();
    e8.handle({ jsonrpc: "2.0", id: 1, method: "metamask_sendDomainMetadata", params: t4 }, Uc);
  } catch (e9) {
    t3.error({ message: is.errors.sendSiteMetadata(), originalError: e9 });
  }
}
function Fc(e8) {
  const { document: t3 } = e8, n2 = t3.querySelector('head > meta[property="og:site_name"]');
  if (n2) return n2.content;
  const r3 = t3.querySelector('head > meta[name="title"]');
  return r3 ? r3.content : t3.title && t3.title.length > 0 ? t3.title : window.location.hostname;
}
async function zc(e8) {
  const { document: t3 } = e8, n2 = t3.querySelectorAll('head > link[rel~="icon"]');
  for (const e9 of Array.from(n2)) if (e9 && await qc(e9.href)) return e9.href;
  return null;
}
async function qc(e8) {
  return new Promise((t3, n2) => {
    try {
      const n3 = document.createElement("img");
      n3.onload = () => t3(true), n3.onerror = () => t3(false), n3.src = e8;
    } catch (e9) {
      n2(e9);
    }
  });
}
var Wc = (e8, t3, n2) => {
  if (!t3.has(e8)) throw TypeError("Cannot " + n2);
};
var Vc = (e8, t3, n2) => (Wc(e8, t3, "read from private field"), n2 ? n2.call(e8) : t3.get(e8));
var Gc = (e8, t3, n2) => {
  if (t3.has(e8)) throw TypeError("Cannot add the same private member more than once");
  t3 instanceof WeakSet ? t3.add(e8) : t3.set(e8, n2);
};
var Yc = (e8, t3, n2, r3) => (Wc(e8, t3, "write to private field"), t3.set(e8, n2), n2);
function Zc(e8, t3, n2) {
  try {
    Reflect.apply(e8, t3, n2);
  } catch (e9) {
    setTimeout(() => {
      throw e9;
    });
  }
}
var Jc = class extends rc {
  emit(e8, ...t3) {
    let n2 = "error" === e8;
    const r3 = this._events;
    if (void 0 !== r3) n2 = n2 && void 0 === r3.error;
    else if (!n2) return false;
    if (n2) {
      let e9;
      if (t3.length > 0 && ([e9] = t3), e9 instanceof Error) throw e9;
      const n3 = new Error("Unhandled error." + (e9 ? ` (${e9.message})` : ""));
      throw n3.context = e9, n3;
    }
    const i2 = r3[e8];
    if (void 0 === i2) return false;
    if ("function" == typeof i2) Zc(i2, this, t3);
    else {
      const e9 = i2.length, n3 = function(e10) {
        const t4 = e10.length, n4 = new Array(t4);
        for (let r4 = 0; r4 < t4; r4 += 1) n4[r4] = e10[r4];
        return n4;
      }(i2);
      for (let r4 = 0; r4 < e9; r4 += 1) Zc(n3[r4], this, t3);
    }
    return true;
  }
};
var Qc;
var Xc;
var el = function e3(t3, n2) {
  if (t3 === n2) return true;
  if (t3 && n2 && "object" == typeof t3 && "object" == typeof n2) {
    if (t3.constructor !== n2.constructor) return false;
    var r3, i2, o;
    if (Array.isArray(t3)) {
      if ((r3 = t3.length) != n2.length) return false;
      for (i2 = r3; 0 != i2--; ) if (!e3(t3[i2], n2[i2])) return false;
      return true;
    }
    if (t3.constructor === RegExp) return t3.source === n2.source && t3.flags === n2.flags;
    if (t3.valueOf !== Object.prototype.valueOf) return t3.valueOf() === n2.valueOf();
    if (t3.toString !== Object.prototype.toString) return t3.toString() === n2.toString();
    if ((r3 = (o = Object.keys(t3)).length) !== Object.keys(n2).length) return false;
    for (i2 = r3; 0 != i2--; ) if (!Object.prototype.hasOwnProperty.call(n2, o[i2])) return false;
    for (i2 = r3; 0 != i2--; ) {
      var s = o[i2];
      if (!e3(t3[s], n2[s])) return false;
    }
    return true;
  }
  return t3 != t3 && n2 != n2;
};
var tl = ue(el);
var nl = class e4 extends Jc {
  constructor({ logger: t3 = console, maxEventListeners: n2 = 100, rpcMiddleware: r3 = [] } = {}) {
    super(), Gc(this, Qc, void 0), Gc(this, Xc, void 0), this._log = t3, this.setMaxListeners(n2), this._state = { ...e4._defaultState }, Yc(this, Xc, null), Yc(this, Qc, null), this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const i2 = new Nc();
    r3.forEach((e8) => i2.push(e8)), this._rpcEngine = i2;
  }
  get chainId() {
    return Vc(this, Qc);
  }
  get selectedAddress() {
    return Vc(this, Xc);
  }
  isConnected() {
    return this._state.isConnected;
  }
  async request(e8) {
    if (!e8 || "object" != typeof e8 || Array.isArray(e8)) throw Xa({ message: is.errors.invalidRequestArgs(), data: e8 });
    const { method: t3, params: n2 } = e8;
    if ("string" != typeof t3 || 0 === t3.length) throw Xa({ message: is.errors.invalidRequestMethod(), data: e8 });
    if (void 0 !== n2 && !Array.isArray(n2) && ("object" != typeof n2 || null === n2)) throw Xa({ message: is.errors.invalidRequestParams(), data: e8 });
    const r3 = null == n2 ? { method: t3 } : { method: t3, params: n2 };
    return new Promise((e9, t4) => {
      this._rpcRequest(r3, Kc(e9, t4));
    });
  }
  _initializeState(e8) {
    if (this._state.initialized) throw new Error("Provider already initialized.");
    if (e8) {
      const { accounts: t3, chainId: n2, isUnlocked: r3, networkVersion: i2 } = e8;
      this._handleConnect(n2), this._handleChainChanged({ chainId: n2, networkVersion: i2 }), this._handleUnlockStateChanged({ accounts: t3, isUnlocked: r3 }), this._handleAccountsChanged(t3);
    }
    this._state.initialized = true, this.emit("_initialized");
  }
  _rpcRequest(e8, t3) {
    let n2 = t3;
    return Array.isArray(e8) || (e8.jsonrpc || (e8.jsonrpc = "2.0"), "eth_accounts" !== e8.method && "eth_requestAccounts" !== e8.method || (n2 = (n3, r3) => {
      this._handleAccountsChanged(r3.result ?? [], "eth_accounts" === e8.method), t3(n3, r3);
    })), this._rpcEngine.handle(e8, n2);
  }
  _handleConnect(e8) {
    this._state.isConnected || (this._state.isConnected = true, this.emit("connect", { chainId: e8 }), this._log.debug(is.info.connected(e8)));
  }
  _handleDisconnect(e8, t3) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !e8) {
      let n2;
      this._state.isConnected = false, e8 ? (n2 = new Ja(1013, t3 ?? is.errors.disconnected()), this._log.debug(n2)) : (n2 = new Ja(1011, t3 ?? is.errors.permanentlyDisconnected()), this._log.error(n2), Yc(this, Qc, null), this._state.accounts = null, Yc(this, Xc, null), this._state.isUnlocked = false, this._state.isPermanentlyDisconnected = true), this.emit("disconnect", n2);
    }
  }
  _handleChainChanged({ chainId: e8 } = {}) {
    jc(e8) ? (this._handleConnect(e8), e8 !== Vc(this, Qc) && (Yc(this, Qc, e8), this._state.initialized && this.emit("chainChanged", Vc(this, Qc)))) : this._log.error(is.errors.invalidNetworkParams(), { chainId: e8 });
  }
  _handleAccountsChanged(e8, t3 = false) {
    let n2 = e8;
    Array.isArray(e8) || (this._log.error("MetaMask: Received invalid accounts parameter. Please report this bug.", e8), n2 = []);
    for (const t4 of e8) if ("string" != typeof t4) {
      this._log.error("MetaMask: Received non-string account. Please report this bug.", e8), n2 = [];
      break;
    }
    if (!tl(this._state.accounts, n2) && (t3 && null !== this._state.accounts && this._log.error("MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.", n2), this._state.accounts = n2, Vc(this, Xc) !== n2[0] && Yc(this, Xc, n2[0] || null), this._state.initialized)) {
      const e9 = [...n2];
      this.emit("accountsChanged", e9);
    }
  }
  _handleUnlockStateChanged({ accounts: e8, isUnlocked: t3 } = {}) {
    "boolean" == typeof t3 ? t3 !== this._state.isUnlocked && (this._state.isUnlocked = t3, this._handleAccountsChanged(e8 ?? [])) : this._log.error("MetaMask: Received invalid isUnlocked parameter. Please report this bug.");
  }
};
Qc = /* @__PURE__ */ new WeakMap(), Xc = /* @__PURE__ */ new WeakMap(), nl._defaultState = { accounts: null, isConnected: false, isUnlocked: false, initialized: false, isPermanentlyDisconnected: false };
var rl;
var il;
var ol = nl;
var sl = { exports: {} };
function al() {
  return il ? rl : (il = 1, rl = lc.EventEmitter);
}
var cl;
var ll = he(le);
cl = "function" == typeof Object.create ? function(e8, t3) {
  e8.super_ = t3, e8.prototype = Object.create(t3.prototype, { constructor: { value: e8, enumerable: false, writable: true, configurable: true } });
} : function(e8, t3) {
  e8.super_ = t3;
  var n2 = function() {
  };
  n2.prototype = t3.prototype, e8.prototype = new n2(), e8.prototype.constructor = e8;
};
var dl = Object.getOwnPropertyDescriptors || function(e8) {
  for (var t3 = Object.keys(e8), n2 = {}, r3 = 0; r3 < t3.length; r3++) n2[t3[r3]] = Object.getOwnPropertyDescriptor(e8, t3[r3]);
  return n2;
};
var ul = /%[sdj%]/g;
function hl(e8) {
  if (!Ml(e8)) {
    for (var t3 = [], n2 = 0; n2 < arguments.length; n2++) t3.push(yl(arguments[n2]));
    return t3.join(" ");
  }
  n2 = 1;
  for (var r3 = arguments, i2 = r3.length, o = String(e8).replace(ul, function(e9) {
    if ("%%" === e9) return "%";
    if (n2 >= i2) return e9;
    switch (e9) {
      case "%s":
        return String(r3[n2++]);
      case "%d":
        return Number(r3[n2++]);
      case "%j":
        try {
          return JSON.stringify(r3[n2++]);
        } catch (e10) {
          return "[Circular]";
        }
      default:
        return e9;
    }
  }), s = r3[n2]; n2 < i2; s = r3[++n2]) kl(s) || !Pl(s) ? o += " " + s : o += " " + yl(s);
  return o;
}
function fl(e8, t3) {
  if (Tl(l.process)) return function() {
    return fl(e8, t3).apply(this, arguments);
  };
  if (true === ua.noDeprecation) return e8;
  var n2 = false;
  return function() {
    if (!n2) {
      if (ua.throwDeprecation) throw new Error(t3);
      ua.traceDeprecation ? console.trace(t3) : console.error(t3), n2 = true;
    }
    return e8.apply(this, arguments);
  };
}
var pl;
var gl = {};
function ml(e8) {
  if (Tl(pl) && (pl = ua.env.NODE_DEBUG || ""), e8 = e8.toUpperCase(), !gl[e8]) if (new RegExp("\\b" + e8 + "\\b", "i").test(pl)) {
    gl[e8] = function() {
      var t3 = hl.apply(null, arguments);
      console.error("%s %d: %s", e8, 0, t3);
    };
  } else gl[e8] = function() {
  };
  return gl[e8];
}
function yl(e8, t3) {
  var n2 = { seen: [], stylize: bl };
  return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), Cl(t3) ? n2.showHidden = t3 : t3 && Hl(n2, t3), Tl(n2.showHidden) && (n2.showHidden = false), Tl(n2.depth) && (n2.depth = 2), Tl(n2.colors) && (n2.colors = false), Tl(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = vl), wl(n2, e8, n2.depth);
}
function vl(e8, t3) {
  var n2 = yl.styles[t3];
  return n2 ? "\x1B[" + yl.colors[n2][0] + "m" + e8 + "\x1B[" + yl.colors[n2][1] + "m" : e8;
}
function bl(e8, t3) {
  return e8;
}
function wl(e8, t3, n2) {
  if (e8.customInspect && t3 && Ll(t3.inspect) && t3.inspect !== yl && (!t3.constructor || t3.constructor.prototype !== t3)) {
    var r3 = t3.inspect(n2, e8);
    return Ml(r3) || (r3 = wl(e8, r3, n2)), r3;
  }
  var i2 = function(e9, t4) {
    if (Tl(t4)) return e9.stylize("undefined", "undefined");
    if (Ml(t4)) {
      var n3 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e9.stylize(n3, "string");
    }
    if (xl(t4)) return e9.stylize("" + t4, "number");
    if (Cl(t4)) return e9.stylize("" + t4, "boolean");
    if (kl(t4)) return e9.stylize("null", "null");
  }(e8, t3);
  if (i2) return i2;
  var o = Object.keys(t3), s = function(e9) {
    var t4 = {};
    return e9.forEach(function(e10, n3) {
      t4[e10] = true;
    }), t4;
  }(o);
  if (e8.showHidden && (o = Object.getOwnPropertyNames(t3)), Nl(t3) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return El(t3);
  if (0 === o.length) {
    if (Ll(t3)) {
      var a = t3.name ? ": " + t3.name : "";
      return e8.stylize("[Function" + a + "]", "special");
    }
    if (Rl(t3)) return e8.stylize(RegExp.prototype.toString.call(t3), "regexp");
    if (Ol(t3)) return e8.stylize(Date.prototype.toString.call(t3), "date");
    if (Nl(t3)) return El(t3);
  }
  var c2, l3 = "", d3 = false, u2 = ["{", "}"];
  (_l(t3) && (d3 = true, u2 = ["[", "]"]), Ll(t3)) && (l3 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
  return Rl(t3) && (l3 = " " + RegExp.prototype.toString.call(t3)), Ol(t3) && (l3 = " " + Date.prototype.toUTCString.call(t3)), Nl(t3) && (l3 = " " + El(t3)), 0 !== o.length || d3 && 0 != t3.length ? n2 < 0 ? Rl(t3) ? e8.stylize(RegExp.prototype.toString.call(t3), "regexp") : e8.stylize("[Object]", "special") : (e8.seen.push(t3), c2 = d3 ? function(e9, t4, n3, r4, i3) {
    for (var o2 = [], s2 = 0, a2 = t4.length; s2 < a2; ++s2) Fl(t4, String(s2)) ? o2.push(Sl(e9, t4, n3, r4, String(s2), true)) : o2.push("");
    return i3.forEach(function(i4) {
      i4.match(/^\d+$/) || o2.push(Sl(e9, t4, n3, r4, i4, true));
    }), o2;
  }(e8, t3, n2, s, o) : o.map(function(r4) {
    return Sl(e8, t3, n2, s, r4, d3);
  }), e8.seen.pop(), function(e9, t4, n3) {
    var r4 = e9.reduce(function(e10, t5) {
      return t5.indexOf("\n"), e10 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (r4 > 60) return n3[0] + ("" === t4 ? "" : t4 + "\n ") + " " + e9.join(",\n  ") + " " + n3[1];
    return n3[0] + t4 + " " + e9.join(", ") + " " + n3[1];
  }(c2, l3, u2)) : u2[0] + l3 + u2[1];
}
function El(e8) {
  return "[" + Error.prototype.toString.call(e8) + "]";
}
function Sl(e8, t3, n2, r3, i2, o) {
  var s, a, c2;
  if ((c2 = Object.getOwnPropertyDescriptor(t3, i2) || { value: t3[i2] }).get ? a = c2.set ? e8.stylize("[Getter/Setter]", "special") : e8.stylize("[Getter]", "special") : c2.set && (a = e8.stylize("[Setter]", "special")), Fl(r3, i2) || (s = "[" + i2 + "]"), a || (e8.seen.indexOf(c2.value) < 0 ? (a = kl(n2) ? wl(e8, c2.value, null) : wl(e8, c2.value, n2 - 1)).indexOf("\n") > -1 && (a = o ? a.split("\n").map(function(e9) {
    return "  " + e9;
  }).join("\n").substr(2) : "\n" + a.split("\n").map(function(e9) {
    return "   " + e9;
  }).join("\n")) : a = e8.stylize("[Circular]", "special")), Tl(s)) {
    if (o && i2.match(/^\d+$/)) return a;
    (s = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e8.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e8.stylize(s, "string"));
  }
  return s + ": " + a;
}
function _l(e8) {
  return Array.isArray(e8);
}
function Cl(e8) {
  return "boolean" == typeof e8;
}
function kl(e8) {
  return null === e8;
}
function Al(e8) {
  return null == e8;
}
function xl(e8) {
  return "number" == typeof e8;
}
function Ml(e8) {
  return "string" == typeof e8;
}
function Il(e8) {
  return "symbol" == typeof e8;
}
function Tl(e8) {
  return void 0 === e8;
}
function Rl(e8) {
  return Pl(e8) && "[object RegExp]" === Bl(e8);
}
function Pl(e8) {
  return "object" == typeof e8 && null !== e8;
}
function Ol(e8) {
  return Pl(e8) && "[object Date]" === Bl(e8);
}
function Nl(e8) {
  return Pl(e8) && ("[object Error]" === Bl(e8) || e8 instanceof Error);
}
function Ll(e8) {
  return "function" == typeof e8;
}
function Dl(e8) {
  return null === e8 || "boolean" == typeof e8 || "number" == typeof e8 || "string" == typeof e8 || "symbol" == typeof e8 || void 0 === e8;
}
function $l(e8) {
  return C.isBuffer(e8);
}
function Bl(e8) {
  return Object.prototype.toString.call(e8);
}
function Kl(e8) {
  return e8 < 10 ? "0" + e8.toString(10) : e8.toString(10);
}
yl.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, yl.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
var jl = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Ul() {
  var e8, t3;
  console.log("%s - %s", (e8 = /* @__PURE__ */ new Date(), t3 = [Kl(e8.getHours()), Kl(e8.getMinutes()), Kl(e8.getSeconds())].join(":"), [e8.getDate(), jl[e8.getMonth()], t3].join(" ")), hl.apply(null, arguments));
}
function Hl(e8, t3) {
  if (!t3 || !Pl(t3)) return e8;
  for (var n2 = Object.keys(t3), r3 = n2.length; r3--; ) e8[n2[r3]] = t3[n2[r3]];
  return e8;
}
function Fl(e8, t3) {
  return Object.prototype.hasOwnProperty.call(e8, t3);
}
var zl = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
function ql(e8) {
  if ("function" != typeof e8) throw new TypeError('The "original" argument must be of type Function');
  if (zl && e8[zl]) {
    var t3;
    if ("function" != typeof (t3 = e8[zl])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(t3, zl, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
  }
  function t3() {
    for (var t4, n2, r3 = new Promise(function(e9, r4) {
      t4 = e9, n2 = r4;
    }), i2 = [], o = 0; o < arguments.length; o++) i2.push(arguments[o]);
    i2.push(function(e9, r4) {
      e9 ? n2(e9) : t4(r4);
    });
    try {
      e8.apply(this, i2);
    } catch (e9) {
      n2(e9);
    }
    return r3;
  }
  return Object.setPrototypeOf(t3, Object.getPrototypeOf(e8)), zl && Object.defineProperty(t3, zl, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, dl(e8));
}
function Wl(e8, t3) {
  if (!e8) {
    var n2 = new Error("Promise was rejected with a falsy value");
    n2.reason = e8, e8 = n2;
  }
  return t3(e8);
}
function Vl(e8) {
  if ("function" != typeof e8) throw new TypeError('The "original" argument must be of type Function');
  function t3() {
    for (var t4 = [], n2 = 0; n2 < arguments.length; n2++) t4.push(arguments[n2]);
    var r3 = t4.pop();
    if ("function" != typeof r3) throw new TypeError("The last argument must be of type Function");
    var i2 = this, o = function() {
      return r3.apply(i2, arguments);
    };
    e8.apply(this, t4).then(function(e9) {
      ua.nextTick(o.bind(null, null, e9));
    }, function(e9) {
      ua.nextTick(Wl.bind(null, e9, o));
    });
  }
  return Object.setPrototypeOf(t3, Object.getPrototypeOf(e8)), Object.defineProperties(t3, dl(e8)), t3;
}
ql.custom = zl;
var Gl;
var Yl;
var Zl;
var Jl;
var Ql = { inherits: cl, _extend: Hl, log: Ul, isBuffer: $l, isPrimitive: Dl, isFunction: Ll, isError: Nl, isDate: Ol, isObject: Pl, isRegExp: Rl, isUndefined: Tl, isSymbol: Il, isString: Ml, isNumber: xl, isNullOrUndefined: Al, isNull: kl, isBoolean: Cl, isArray: _l, inspect: yl, deprecate: fl, format: hl, debuglog: ml, promisify: ql, callbackify: Vl };
var Xl = he(Object.freeze({ __proto__: null, _extend: Hl, callbackify: Vl, debuglog: ml, default: Ql, deprecate: fl, format: hl, inherits: cl, inspect: yl, isArray: _l, isBoolean: Cl, isBuffer: $l, isDate: Ol, isError: Nl, isFunction: Ll, isNull: kl, isNullOrUndefined: Al, isNumber: xl, isObject: Pl, isPrimitive: Dl, isRegExp: Rl, isString: Ml, isSymbol: Il, isUndefined: Tl, log: Ul, promisify: ql }));
function ed() {
  if (Yl) return Gl;
  function e8(e9, t4) {
    var n3 = Object.keys(e9);
    if (Object.getOwnPropertySymbols) {
      var r4 = Object.getOwnPropertySymbols(e9);
      t4 && (r4 = r4.filter(function(t5) {
        return Object.getOwnPropertyDescriptor(e9, t5).enumerable;
      })), n3.push.apply(n3, r4);
    }
    return n3;
  }
  function t3(t4) {
    for (var r4 = 1; r4 < arguments.length; r4++) {
      var i3 = null != arguments[r4] ? arguments[r4] : {};
      r4 % 2 ? e8(Object(i3), true).forEach(function(e9) {
        n2(t4, e9, i3[e9]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(i3)) : e8(Object(i3)).forEach(function(e9) {
        Object.defineProperty(t4, e9, Object.getOwnPropertyDescriptor(i3, e9));
      });
    }
    return t4;
  }
  function n2(e9, t4, n3) {
    return (t4 = i2(t4)) in e9 ? Object.defineProperty(e9, t4, { value: n3, enumerable: true, configurable: true, writable: true }) : e9[t4] = n3, e9;
  }
  function r3(e9, t4, n3) {
    return t4 && function(e10, t5) {
      for (var n4 = 0; n4 < t5.length; n4++) {
        var r4 = t5[n4];
        r4.enumerable = r4.enumerable || false, r4.configurable = true, "value" in r4 && (r4.writable = true), Object.defineProperty(e10, i2(r4.key), r4);
      }
    }(e9.prototype, t4), Object.defineProperty(e9, "prototype", { writable: false }), e9;
  }
  function i2(e9) {
    var t4 = function(e10, t5) {
      if ("object" != typeof e10 || null === e10) return e10;
      var n3 = e10[Symbol.toPrimitive];
      if (void 0 !== n3) {
        var r4 = n3.call(e10, t5 || "default");
        if ("object" != typeof r4) return r4;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t5 ? String : Number)(e10);
    }(e9, "string");
    return "symbol" == typeof t4 ? t4 : String(t4);
  }
  Yl = 1;
  var o = ll.Buffer, s = Xl.inspect, a = s && s.custom || "inspect";
  return Gl = function() {
    function e9() {
      !function(e10, t4) {
        if (!(e10 instanceof t4)) throw new TypeError("Cannot call a class as a function");
      }(this, e9), this.head = null, this.tail = null, this.length = 0;
    }
    return r3(e9, [{ key: "push", value: function(e10) {
      var t4 = { data: e10, next: null };
      this.length > 0 ? this.tail.next = t4 : this.head = t4, this.tail = t4, ++this.length;
    } }, { key: "unshift", value: function(e10) {
      var t4 = { data: e10, next: this.head };
      0 === this.length && (this.tail = t4), this.head = t4, ++this.length;
    } }, { key: "shift", value: function() {
      if (0 !== this.length) {
        var e10 = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e10;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(e10) {
      if (0 === this.length) return "";
      for (var t4 = this.head, n3 = "" + t4.data; t4 = t4.next; ) n3 += e10 + t4.data;
      return n3;
    } }, { key: "concat", value: function(e10) {
      if (0 === this.length) return o.alloc(0);
      for (var t4, n3, r4, i3 = o.allocUnsafe(e10 >>> 0), s2 = this.head, a2 = 0; s2; ) t4 = s2.data, n3 = i3, r4 = a2, o.prototype.copy.call(t4, n3, r4), a2 += s2.data.length, s2 = s2.next;
      return i3;
    } }, { key: "consume", value: function(e10, t4) {
      var n3;
      return e10 < this.head.data.length ? (n3 = this.head.data.slice(0, e10), this.head.data = this.head.data.slice(e10)) : n3 = e10 === this.head.data.length ? this.shift() : t4 ? this._getString(e10) : this._getBuffer(e10), n3;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(e10) {
      var t4 = this.head, n3 = 1, r4 = t4.data;
      for (e10 -= r4.length; t4 = t4.next; ) {
        var i3 = t4.data, o2 = e10 > i3.length ? i3.length : e10;
        if (o2 === i3.length ? r4 += i3 : r4 += i3.slice(0, e10), 0 === (e10 -= o2)) {
          o2 === i3.length ? (++n3, t4.next ? this.head = t4.next : this.head = this.tail = null) : (this.head = t4, t4.data = i3.slice(o2));
          break;
        }
        ++n3;
      }
      return this.length -= n3, r4;
    } }, { key: "_getBuffer", value: function(e10) {
      var t4 = o.allocUnsafe(e10), n3 = this.head, r4 = 1;
      for (n3.data.copy(t4), e10 -= n3.data.length; n3 = n3.next; ) {
        var i3 = n3.data, s2 = e10 > i3.length ? i3.length : e10;
        if (i3.copy(t4, t4.length - e10, 0, s2), 0 === (e10 -= s2)) {
          s2 === i3.length ? (++r4, n3.next ? this.head = n3.next : this.head = this.tail = null) : (this.head = n3, n3.data = i3.slice(s2));
          break;
        }
        ++r4;
      }
      return this.length -= r4, t4;
    } }, { key: a, value: function(e10, n3) {
      return s(this, t3(t3({}, n3), {}, { depth: 0, customInspect: false }));
    } }]), e9;
  }(), Gl;
}
function td() {
  if (Jl) return Zl;
  function e8(e9, r3) {
    n2(e9, r3), t3(e9);
  }
  function t3(e9) {
    e9._writableState && !e9._writableState.emitClose || e9._readableState && !e9._readableState.emitClose || e9.emit("close");
  }
  function n2(e9, t4) {
    e9.emit("error", t4);
  }
  return Jl = 1, Zl = { destroy: function(r3, i2) {
    var o = this, s = this._readableState && this._readableState.destroyed, a = this._writableState && this._writableState.destroyed;
    return s || a ? (i2 ? i2(r3) : r3 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, ua.nextTick(n2, this, r3)) : ua.nextTick(n2, this, r3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(r3 || null, function(n3) {
      !i2 && n3 ? o._writableState ? o._writableState.errorEmitted ? ua.nextTick(t3, o) : (o._writableState.errorEmitted = true, ua.nextTick(e8, o, n3)) : ua.nextTick(e8, o, n3) : i2 ? (ua.nextTick(t3, o), i2(n3)) : ua.nextTick(t3, o);
    }), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }, errorOrDestroy: function(e9, t4) {
    var n3 = e9._readableState, r3 = e9._writableState;
    n3 && n3.autoDestroy || r3 && r3.autoDestroy ? e9.destroy(t4) : e9.emit("error", t4);
  } }, Zl;
}
var nd = {};
var rd;
var id;
var od = {};
function sd(e8, t3, n2) {
  n2 || (n2 = Error);
  var r3 = function(e9) {
    var n3, r4;
    function i2(n4, r5, i3) {
      return e9.call(this, function(e10, n5, r6) {
        return "string" == typeof t3 ? t3 : t3(e10, n5, r6);
      }(n4, r5, i3)) || this;
    }
    return r4 = e9, (n3 = i2).prototype = Object.create(r4.prototype), n3.prototype.constructor = n3, n3.__proto__ = r4, i2;
  }(n2);
  r3.prototype.name = n2.name, r3.prototype.code = e8, od[e8] = r3;
}
function ad(e8, t3) {
  if (Array.isArray(e8)) {
    var n2 = e8.length;
    return e8 = e8.map(function(e9) {
      return String(e9);
    }), n2 > 2 ? "one of ".concat(t3, " ").concat(e8.slice(0, n2 - 1).join(", "), ", or ") + e8[n2 - 1] : 2 === n2 ? "one of ".concat(t3, " ").concat(e8[0], " or ").concat(e8[1]) : "of ".concat(t3, " ").concat(e8[0]);
  }
  return "of ".concat(t3, " ").concat(String(e8));
}
function cd() {
  if (id) return rd;
  id = 1;
  var e8 = nd.codes.ERR_INVALID_OPT_VALUE;
  return rd = { getHighWaterMark: function(t3, n2, r3, i2) {
    var o = function(e9, t4, n3) {
      return null != e9.highWaterMark ? e9.highWaterMark : t4 ? e9[n3] : null;
    }(n2, i2, r3);
    if (null != o) {
      if (!isFinite(o) || Math.floor(o) !== o || o < 0) throw new e8(i2 ? r3 : "highWaterMark", o);
      return Math.floor(o);
    }
    return t3.objectMode ? 16 : 16384;
  } };
}
sd("ERR_INVALID_OPT_VALUE", function(e8, t3) {
  return 'The value "' + t3 + '" is invalid for option "' + e8 + '"';
}, TypeError), sd("ERR_INVALID_ARG_TYPE", function(e8, t3, n2) {
  var r3, i2, o;
  if ("string" == typeof t3 && (i2 = "not ", t3.substr(0, i2.length) === i2) ? (r3 = "must not be", t3 = t3.replace(/^not /, "")) : r3 = "must be", function(e9, t4, n3) {
    return (void 0 === n3 || n3 > e9.length) && (n3 = e9.length), e9.substring(n3 - t4.length, n3) === t4;
  }(e8, " argument")) o = "The ".concat(e8, " ").concat(r3, " ").concat(ad(t3, "type"));
  else {
    var s = function(e9, t4, n3) {
      return "number" != typeof n3 && (n3 = 0), !(n3 + t4.length > e9.length) && -1 !== e9.indexOf(t4, n3);
    }(e8, ".") ? "property" : "argument";
    o = 'The "'.concat(e8, '" ').concat(s, " ").concat(r3, " ").concat(ad(t3, "type"));
  }
  return o += ". Received type ".concat(typeof n2);
}, TypeError), sd("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), sd("ERR_METHOD_NOT_IMPLEMENTED", function(e8) {
  return "The " + e8 + " method is not implemented";
}), sd("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), sd("ERR_STREAM_DESTROYED", function(e8) {
  return "Cannot call " + e8 + " after a stream was destroyed";
}), sd("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), sd("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), sd("ERR_STREAM_WRITE_AFTER_END", "write after end"), sd("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), sd("ERR_UNKNOWN_ENCODING", function(e8) {
  return "Unknown encoding: " + e8;
}, TypeError), sd("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), nd.codes = od;
var ld;
var dd;
var ud;
var hd;
var fd;
var pd;
var gd = "function" == typeof Object.create ? function(e8, t3) {
  e8.super_ = t3, e8.prototype = Object.create(t3.prototype, { constructor: { value: e8, enumerable: false, writable: true, configurable: true } });
} : function(e8, t3) {
  e8.super_ = t3;
  var n2 = function() {
  };
  n2.prototype = t3.prototype, e8.prototype = new n2(), e8.prototype.constructor = e8;
};
var md = he(Object.freeze({ __proto__: null, default: gd }));
function yd() {
  if (dd) return ld;
  function e8(e9) {
    try {
      if (!de.localStorage) return false;
    } catch (e10) {
      return false;
    }
    var t3 = de.localStorage[e9];
    return null != t3 && "true" === String(t3).toLowerCase();
  }
  return dd = 1, ld = function(t3, n2) {
    if (e8("noDeprecation")) return t3;
    var r3 = false;
    return function() {
      if (!r3) {
        if (e8("throwDeprecation")) throw new Error(n2);
        e8("traceDeprecation") ? console.trace(n2) : console.warn(n2), r3 = true;
      }
      return t3.apply(this, arguments);
    };
  }, ld;
}
function vd() {
  if (hd) return ud;
  function e8(e9) {
    var t4 = this;
    this.next = null, this.entry = null, this.finish = function() {
      !function(e10, t5, n3) {
        var r4 = e10.entry;
        e10.entry = null;
        for (; r4; ) {
          var i3 = r4.callback;
          t5.pendingcb--, i3(n3), r4 = r4.next;
        }
        t5.corkedRequestsFree.next = e10;
      }(t4, e9);
    };
  }
  var t3;
  hd = 1, ud = E2, E2.WritableState = w2;
  var n2 = { deprecate: yd() }, r3 = al(), i2 = ll.Buffer, o = (void 0 !== de ? de : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var s, a = td(), c2 = cd().getHighWaterMark, l3 = nd.codes, d3 = l3.ERR_INVALID_ARG_TYPE, u2 = l3.ERR_METHOD_NOT_IMPLEMENTED, h3 = l3.ERR_MULTIPLE_CALLBACK, f2 = l3.ERR_STREAM_CANNOT_PIPE, p3 = l3.ERR_STREAM_DESTROYED, g3 = l3.ERR_STREAM_NULL_VALUES, m2 = l3.ERR_STREAM_WRITE_AFTER_END, y3 = l3.ERR_UNKNOWN_ENCODING, v2 = a.errorOrDestroy;
  function b3() {
  }
  function w2(n3, r4, i3) {
    t3 = t3 || bd(), n3 = n3 || {}, "boolean" != typeof i3 && (i3 = r4 instanceof t3), this.objectMode = !!n3.objectMode, i3 && (this.objectMode = this.objectMode || !!n3.writableObjectMode), this.highWaterMark = c2(this, n3, "writableHighWaterMark", i3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var o2 = false === n3.decodeStrings;
    this.decodeStrings = !o2, this.defaultEncoding = n3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e9) {
      !function(e10, t4) {
        var n4 = e10._writableState, r5 = n4.sync, i4 = n4.writecb;
        if ("function" != typeof i4) throw new h3();
        if (function(e11) {
          e11.writing = false, e11.writecb = null, e11.length -= e11.writelen, e11.writelen = 0;
        }(n4), t4) !function(e11, t5, n5, r6, i5) {
          --t5.pendingcb, n5 ? (ua.nextTick(i5, r6), ua.nextTick(x3, e11, t5), e11._writableState.errorEmitted = true, v2(e11, r6)) : (i5(r6), e11._writableState.errorEmitted = true, v2(e11, r6), x3(e11, t5));
        }(e10, n4, r5, t4, i4);
        else {
          var o3 = k3(n4) || e10.destroyed;
          o3 || n4.corked || n4.bufferProcessing || !n4.bufferedRequest || C3(e10, n4), r5 ? ua.nextTick(_3, e10, n4, o3, i4) : _3(e10, n4, o3, i4);
        }
      }(r4, e9);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== n3.emitClose, this.autoDestroy = !!n3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e8(this);
  }
  function E2(e9) {
    var n3 = this instanceof (t3 = t3 || bd());
    if (!n3 && !s.call(E2, this)) return new E2(e9);
    this._writableState = new w2(e9, this, n3), this.writable = true, e9 && ("function" == typeof e9.write && (this._write = e9.write), "function" == typeof e9.writev && (this._writev = e9.writev), "function" == typeof e9.destroy && (this._destroy = e9.destroy), "function" == typeof e9.final && (this._final = e9.final)), r3.call(this);
  }
  function S3(e9, t4, n3, r4, i3, o2, s2) {
    t4.writelen = r4, t4.writecb = s2, t4.writing = true, t4.sync = true, t4.destroyed ? t4.onwrite(new p3("write")) : n3 ? e9._writev(i3, t4.onwrite) : e9._write(i3, o2, t4.onwrite), t4.sync = false;
  }
  function _3(e9, t4, n3, r4) {
    n3 || function(e10, t5) {
      0 === t5.length && t5.needDrain && (t5.needDrain = false, e10.emit("drain"));
    }(e9, t4), t4.pendingcb--, r4(), x3(e9, t4);
  }
  function C3(t4, n3) {
    n3.bufferProcessing = true;
    var r4 = n3.bufferedRequest;
    if (t4._writev && r4 && r4.next) {
      var i3 = n3.bufferedRequestCount, o2 = new Array(i3), s2 = n3.corkedRequestsFree;
      s2.entry = r4;
      for (var a2 = 0, c3 = true; r4; ) o2[a2] = r4, r4.isBuf || (c3 = false), r4 = r4.next, a2 += 1;
      o2.allBuffers = c3, S3(t4, n3, true, n3.length, o2, "", s2.finish), n3.pendingcb++, n3.lastBufferedRequest = null, s2.next ? (n3.corkedRequestsFree = s2.next, s2.next = null) : n3.corkedRequestsFree = new e8(n3), n3.bufferedRequestCount = 0;
    } else {
      for (; r4; ) {
        var l4 = r4.chunk, d4 = r4.encoding, u3 = r4.callback;
        if (S3(t4, n3, false, n3.objectMode ? 1 : l4.length, l4, d4, u3), r4 = r4.next, n3.bufferedRequestCount--, n3.writing) break;
      }
      null === r4 && (n3.lastBufferedRequest = null);
    }
    n3.bufferedRequest = r4, n3.bufferProcessing = false;
  }
  function k3(e9) {
    return e9.ending && 0 === e9.length && null === e9.bufferedRequest && !e9.finished && !e9.writing;
  }
  function A3(e9, t4) {
    e9._final(function(n3) {
      t4.pendingcb--, n3 && v2(e9, n3), t4.prefinished = true, e9.emit("prefinish"), x3(e9, t4);
    });
  }
  function x3(e9, t4) {
    var n3 = k3(t4);
    if (n3 && (function(e10, t5) {
      t5.prefinished || t5.finalCalled || ("function" != typeof e10._final || t5.destroyed ? (t5.prefinished = true, e10.emit("prefinish")) : (t5.pendingcb++, t5.finalCalled = true, ua.nextTick(A3, e10, t5)));
    }(e9, t4), 0 === t4.pendingcb && (t4.finished = true, e9.emit("finish"), t4.autoDestroy))) {
      var r4 = e9._readableState;
      (!r4 || r4.autoDestroy && r4.endEmitted) && e9.destroy();
    }
    return n3;
  }
  return md(E2, r3), w2.prototype.getBuffer = function() {
    for (var e9 = this.bufferedRequest, t4 = []; e9; ) t4.push(e9), e9 = e9.next;
    return t4;
  }, function() {
    try {
      Object.defineProperty(w2.prototype, "buffer", { get: n2.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch (e9) {
    }
  }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (s = Function.prototype[Symbol.hasInstance], Object.defineProperty(E2, Symbol.hasInstance, { value: function(e9) {
    return !!s.call(this, e9) || this === E2 && (e9 && e9._writableState instanceof w2);
  } })) : s = function(e9) {
    return e9 instanceof this;
  }, E2.prototype.pipe = function() {
    v2(this, new f2());
  }, E2.prototype.write = function(e9, t4, n3) {
    var r4, s2 = this._writableState, a2 = false, c3 = !s2.objectMode && (r4 = e9, i2.isBuffer(r4) || r4 instanceof o);
    return c3 && !i2.isBuffer(e9) && (e9 = function(e10) {
      return i2.from(e10);
    }(e9)), "function" == typeof t4 && (n3 = t4, t4 = null), c3 ? t4 = "buffer" : t4 || (t4 = s2.defaultEncoding), "function" != typeof n3 && (n3 = b3), s2.ending ? function(e10, t5) {
      var n4 = new m2();
      v2(e10, n4), ua.nextTick(t5, n4);
    }(this, n3) : (c3 || function(e10, t5, n4, r5) {
      var i3;
      return null === n4 ? i3 = new g3() : "string" == typeof n4 || t5.objectMode || (i3 = new d3("chunk", ["string", "Buffer"], n4)), !i3 || (v2(e10, i3), ua.nextTick(r5, i3), false);
    }(this, s2, e9, n3)) && (s2.pendingcb++, a2 = function(e10, t5, n4, r5, o2, s3) {
      if (!n4) {
        var a3 = function(e11, t6, n5) {
          e11.objectMode || false === e11.decodeStrings || "string" != typeof t6 || (t6 = i2.from(t6, n5));
          return t6;
        }(t5, r5, o2);
        r5 !== a3 && (n4 = true, o2 = "buffer", r5 = a3);
      }
      var c4 = t5.objectMode ? 1 : r5.length;
      t5.length += c4;
      var l4 = t5.length < t5.highWaterMark;
      l4 || (t5.needDrain = true);
      if (t5.writing || t5.corked) {
        var d4 = t5.lastBufferedRequest;
        t5.lastBufferedRequest = { chunk: r5, encoding: o2, isBuf: n4, callback: s3, next: null }, d4 ? d4.next = t5.lastBufferedRequest : t5.bufferedRequest = t5.lastBufferedRequest, t5.bufferedRequestCount += 1;
      } else S3(e10, t5, false, c4, r5, o2, s3);
      return l4;
    }(this, s2, c3, e9, t4, n3)), a2;
  }, E2.prototype.cork = function() {
    this._writableState.corked++;
  }, E2.prototype.uncork = function() {
    var e9 = this._writableState;
    e9.corked && (e9.corked--, e9.writing || e9.corked || e9.bufferProcessing || !e9.bufferedRequest || C3(this, e9));
  }, E2.prototype.setDefaultEncoding = function(e9) {
    if ("string" == typeof e9 && (e9 = e9.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e9 + "").toLowerCase()) > -1)) throw new y3(e9);
    return this._writableState.defaultEncoding = e9, this;
  }, Object.defineProperty(E2.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(E2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), E2.prototype._write = function(e9, t4, n3) {
    n3(new u2("_write()"));
  }, E2.prototype._writev = null, E2.prototype.end = function(e9, t4, n3) {
    var r4 = this._writableState;
    return "function" == typeof e9 ? (n3 = e9, e9 = null, t4 = null) : "function" == typeof t4 && (n3 = t4, t4 = null), null != e9 && this.write(e9, t4), r4.corked && (r4.corked = 1, this.uncork()), r4.ending || function(e10, t5, n4) {
      t5.ending = true, x3(e10, t5), n4 && (t5.finished ? ua.nextTick(n4) : e10.once("finish", n4));
      t5.ended = true, e10.writable = false;
    }(this, r4, n3), this;
  }, Object.defineProperty(E2.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(E2.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._writableState && this._writableState.destroyed;
  }, set: function(e9) {
    this._writableState && (this._writableState.destroyed = e9);
  } }), E2.prototype.destroy = a.destroy, E2.prototype._undestroy = a.undestroy, E2.prototype._destroy = function(e9, t4) {
    t4(e9);
  }, ud;
}
function bd() {
  if (pd) return fd;
  pd = 1;
  var e8 = Object.keys || function(e9) {
    var t4 = [];
    for (var n3 in e9) t4.push(n3);
    return t4;
  };
  fd = s;
  var t3 = Dd(), n2 = vd();
  md(s, t3);
  for (var r3 = e8(n2.prototype), i2 = 0; i2 < r3.length; i2++) {
    var o = r3[i2];
    s.prototype[o] || (s.prototype[o] = n2.prototype[o]);
  }
  function s(e9) {
    if (!(this instanceof s)) return new s(e9);
    t3.call(this, e9), n2.call(this, e9), this.allowHalfOpen = true, e9 && (false === e9.readable && (this.readable = false), false === e9.writable && (this.writable = false), false === e9.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a)));
  }
  function a() {
    this._writableState.ended || ua.nextTick(c2, this);
  }
  function c2(e9) {
    e9.end();
  }
  return Object.defineProperty(s.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(s.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(s.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(s.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
  }, set: function(e9) {
    void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e9, this._writableState.destroyed = e9);
  } }), fd;
}
var wd = C.isEncoding || function(e8) {
  switch (e8 && e8.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function Ed(e8) {
  switch (this.encoding = (e8 || "utf8").toLowerCase().replace(/[-_]/, ""), function(e9) {
    if (e9 && !wd(e9)) throw new Error("Unknown encoding: " + e9);
  }(e8), this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2, this.detectIncompleteChar = _d;
      break;
    case "base64":
      this.surrogateSize = 3, this.detectIncompleteChar = Cd;
      break;
    default:
      return void (this.write = Sd);
  }
  this.charBuffer = new C(6), this.charReceived = 0, this.charLength = 0;
}
function Sd(e8) {
  return e8.toString(this.encoding);
}
function _d(e8) {
  this.charReceived = e8.length % 2, this.charLength = this.charReceived ? 2 : 0;
}
function Cd(e8) {
  this.charReceived = e8.length % 3, this.charLength = this.charReceived ? 3 : 0;
}
Ed.prototype.write = function(e8) {
  for (var t3 = ""; this.charLength; ) {
    var n2 = e8.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : e8.length;
    if (e8.copy(this.charBuffer, this.charReceived, 0, n2), this.charReceived += n2, this.charReceived < this.charLength) return "";
    if (e8 = e8.slice(n2, e8.length), !((i2 = (t3 = this.charBuffer.slice(0, this.charLength).toString(this.encoding)).charCodeAt(t3.length - 1)) >= 55296 && i2 <= 56319)) {
      if (this.charReceived = this.charLength = 0, 0 === e8.length) return t3;
      break;
    }
    this.charLength += this.surrogateSize, t3 = "";
  }
  this.detectIncompleteChar(e8);
  var r3 = e8.length;
  this.charLength && (e8.copy(this.charBuffer, 0, e8.length - this.charReceived, r3), r3 -= this.charReceived);
  var i2;
  r3 = (t3 += e8.toString(this.encoding, 0, r3)).length - 1;
  if ((i2 = t3.charCodeAt(r3)) >= 55296 && i2 <= 56319) {
    var o = this.surrogateSize;
    return this.charLength += o, this.charReceived += o, this.charBuffer.copy(this.charBuffer, o, 0, o), e8.copy(this.charBuffer, 0, 0, o), t3.substring(0, r3);
  }
  return t3;
}, Ed.prototype.detectIncompleteChar = function(e8) {
  for (var t3 = e8.length >= 3 ? 3 : e8.length; t3 > 0; t3--) {
    var n2 = e8[e8.length - t3];
    if (1 == t3 && n2 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (t3 <= 2 && n2 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (t3 <= 3 && n2 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = t3;
}, Ed.prototype.end = function(e8) {
  var t3 = "";
  if (e8 && e8.length && (t3 = this.write(e8)), this.charReceived) {
    var n2 = this.charReceived, r3 = this.charBuffer, i2 = this.encoding;
    t3 += r3.slice(0, n2).toString(i2);
  }
  return t3;
};
var kd = he(Object.freeze({ __proto__: null, StringDecoder: Ed }));
var Ad = nd.codes.ERR_STREAM_PREMATURE_CLOSE;
function xd() {
}
var Md;
var Id;
var Td;
var Rd;
var Pd;
var Od;
var Nd = function e5(t3, n2, r3) {
  if ("function" == typeof n2) return e5(t3, null, n2);
  n2 || (n2 = {}), r3 = /* @__PURE__ */ function(e8) {
    var t4 = false;
    return function() {
      if (!t4) {
        t4 = true;
        for (var n3 = arguments.length, r4 = new Array(n3), i3 = 0; i3 < n3; i3++) r4[i3] = arguments[i3];
        e8.apply(this, r4);
      }
    };
  }(r3 || xd);
  var i2 = n2.readable || false !== n2.readable && t3.readable, o = n2.writable || false !== n2.writable && t3.writable, s = function() {
    t3.writable || c2();
  }, a = t3._writableState && t3._writableState.finished, c2 = function() {
    o = false, a = true, i2 || r3.call(t3);
  }, l3 = t3._readableState && t3._readableState.endEmitted, d3 = function() {
    i2 = false, l3 = true, o || r3.call(t3);
  }, u2 = function(e8) {
    r3.call(t3, e8);
  }, h3 = function() {
    var e8;
    return i2 && !l3 ? (t3._readableState && t3._readableState.ended || (e8 = new Ad()), r3.call(t3, e8)) : o && !a ? (t3._writableState && t3._writableState.ended || (e8 = new Ad()), r3.call(t3, e8)) : void 0;
  }, f2 = function() {
    t3.req.on("finish", c2);
  };
  return !function(e8) {
    return e8.setHeader && "function" == typeof e8.abort;
  }(t3) ? o && !t3._writableState && (t3.on("end", s), t3.on("close", s)) : (t3.on("complete", c2), t3.on("abort", h3), t3.req ? f2() : t3.on("request", f2)), t3.on("end", d3), t3.on("finish", c2), false !== n2.error && t3.on("error", u2), t3.on("close", h3), function() {
    t3.removeListener("complete", c2), t3.removeListener("abort", h3), t3.removeListener("request", f2), t3.req && t3.req.removeListener("finish", c2), t3.removeListener("end", s), t3.removeListener("close", s), t3.removeListener("finish", c2), t3.removeListener("end", d3), t3.removeListener("error", u2), t3.removeListener("close", h3);
  };
};
function Ld() {
  if (Id) return Md;
  var e8;
  function t3(e9, t4, n3) {
    return (t4 = function(e10) {
      var t5 = function(e11, t6) {
        if ("object" != typeof e11 || null === e11) return e11;
        var n4 = e11[Symbol.toPrimitive];
        if (void 0 !== n4) {
          var r4 = n4.call(e11, t6 || "default");
          if ("object" != typeof r4) return r4;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t6 ? String : Number)(e11);
      }(e10, "string");
      return "symbol" == typeof t5 ? t5 : String(t5);
    }(t4)) in e9 ? Object.defineProperty(e9, t4, { value: n3, enumerable: true, configurable: true, writable: true }) : e9[t4] = n3, e9;
  }
  Id = 1;
  var n2 = Nd, r3 = Symbol("lastResolve"), i2 = Symbol("lastReject"), o = Symbol("error"), s = Symbol("ended"), a = Symbol("lastPromise"), c2 = Symbol("handlePromise"), l3 = Symbol("stream");
  function d3(e9, t4) {
    return { value: e9, done: t4 };
  }
  function u2(e9) {
    var t4 = e9[r3];
    if (null !== t4) {
      var n3 = e9[l3].read();
      null !== n3 && (e9[a] = null, e9[r3] = null, e9[i2] = null, t4(d3(n3, false)));
    }
  }
  function h3(e9) {
    ua.nextTick(u2, e9);
  }
  var f2 = Object.getPrototypeOf(function() {
  }), p3 = Object.setPrototypeOf((t3(e8 = { get stream() {
    return this[l3];
  }, next: function() {
    var e9 = this, t4 = this[o];
    if (null !== t4) return Promise.reject(t4);
    if (this[s]) return Promise.resolve(d3(void 0, true));
    if (this[l3].destroyed) return new Promise(function(t5, n4) {
      ua.nextTick(function() {
        e9[o] ? n4(e9[o]) : t5(d3(void 0, true));
      });
    });
    var n3, r4 = this[a];
    if (r4) n3 = new Promise(/* @__PURE__ */ function(e10, t5) {
      return function(n4, r5) {
        e10.then(function() {
          t5[s] ? n4(d3(void 0, true)) : t5[c2](n4, r5);
        }, r5);
      };
    }(r4, this));
    else {
      var i3 = this[l3].read();
      if (null !== i3) return Promise.resolve(d3(i3, false));
      n3 = new Promise(this[c2]);
    }
    return this[a] = n3, n3;
  } }, Symbol.asyncIterator, function() {
    return this;
  }), t3(e8, "return", function() {
    var e9 = this;
    return new Promise(function(t4, n3) {
      e9[l3].destroy(null, function(e10) {
        e10 ? n3(e10) : t4(d3(void 0, true));
      });
    });
  }), e8), f2);
  return Md = function(e9) {
    var u3, f3 = Object.create(p3, (t3(u3 = {}, l3, { value: e9, writable: true }), t3(u3, r3, { value: null, writable: true }), t3(u3, i2, { value: null, writable: true }), t3(u3, o, { value: null, writable: true }), t3(u3, s, { value: e9._readableState.endEmitted, writable: true }), t3(u3, c2, { value: function(e10, t4) {
      var n3 = f3[l3].read();
      n3 ? (f3[a] = null, f3[r3] = null, f3[i2] = null, e10(d3(n3, false))) : (f3[r3] = e10, f3[i2] = t4);
    }, writable: true }), u3));
    return f3[a] = null, n2(e9, function(e10) {
      if (e10 && "ERR_STREAM_PREMATURE_CLOSE" !== e10.code) {
        var t4 = f3[i2];
        return null !== t4 && (f3[a] = null, f3[r3] = null, f3[i2] = null, t4(e10)), void (f3[o] = e10);
      }
      var n3 = f3[r3];
      null !== n3 && (f3[a] = null, f3[r3] = null, f3[i2] = null, n3(d3(void 0, true))), f3[s] = true;
    }), e9.on("readable", h3.bind(null, f3)), f3;
  }, Md;
}
function Dd() {
  if (Od) return Pd;
  var e8;
  Od = 1, Pd = E2, E2.ReadableState = w2, lc.EventEmitter;
  var t3 = function(e9, t4) {
    return e9.listeners(t4).length;
  }, n2 = al(), r3 = ll.Buffer, i2 = (void 0 !== de ? de : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var o, s = Xl;
  o = s && s.debuglog ? s.debuglog("stream") : function() {
  };
  var a, c2, l3, d3 = ed(), u2 = td(), h3 = cd().getHighWaterMark, f2 = nd.codes, p3 = f2.ERR_INVALID_ARG_TYPE, g3 = f2.ERR_STREAM_PUSH_AFTER_EOF, m2 = f2.ERR_METHOD_NOT_IMPLEMENTED, y3 = f2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  md(E2, n2);
  var v2 = u2.errorOrDestroy, b3 = ["error", "close", "destroy", "pause", "resume"];
  function w2(t4, n3, r4) {
    e8 = e8 || bd(), t4 = t4 || {}, "boolean" != typeof r4 && (r4 = n3 instanceof e8), this.objectMode = !!t4.objectMode, r4 && (this.objectMode = this.objectMode || !!t4.readableObjectMode), this.highWaterMark = h3(this, t4, "readableHighWaterMark", r4), this.buffer = new d3(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.destroyed = false, this.defaultEncoding = t4.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t4.encoding && (a || (a = kd.StringDecoder), this.decoder = new a(t4.encoding), this.encoding = t4.encoding);
  }
  function E2(t4) {
    if (e8 = e8 || bd(), !(this instanceof E2)) return new E2(t4);
    var r4 = this instanceof e8;
    this._readableState = new w2(t4, this, r4), this.readable = true, t4 && ("function" == typeof t4.read && (this._read = t4.read), "function" == typeof t4.destroy && (this._destroy = t4.destroy)), n2.call(this);
  }
  function S3(e9, t4, n3, s2, a2) {
    o("readableAddChunk", t4);
    var c3, l4 = e9._readableState;
    if (null === t4) l4.reading = false, function(e10, t5) {
      if (o("onEofChunk"), t5.ended) return;
      if (t5.decoder) {
        var n4 = t5.decoder.end();
        n4 && n4.length && (t5.buffer.push(n4), t5.length += t5.objectMode ? 1 : n4.length);
      }
      t5.ended = true, t5.sync ? A3(e10) : (t5.needReadable = false, t5.emittedReadable || (t5.emittedReadable = true, x3(e10)));
    }(e9, l4);
    else if (a2 || (c3 = function(e10, t5) {
      var n4;
      o2 = t5, r3.isBuffer(o2) || o2 instanceof i2 || "string" == typeof t5 || void 0 === t5 || e10.objectMode || (n4 = new p3("chunk", ["string", "Buffer", "Uint8Array"], t5));
      var o2;
      return n4;
    }(l4, t4)), c3) v2(e9, c3);
    else if (l4.objectMode || t4 && t4.length > 0) if ("string" == typeof t4 || l4.objectMode || Object.getPrototypeOf(t4) === r3.prototype || (t4 = function(e10) {
      return r3.from(e10);
    }(t4)), s2) l4.endEmitted ? v2(e9, new y3()) : _3(e9, l4, t4, true);
    else if (l4.ended) v2(e9, new g3());
    else {
      if (l4.destroyed) return false;
      l4.reading = false, l4.decoder && !n3 ? (t4 = l4.decoder.write(t4), l4.objectMode || 0 !== t4.length ? _3(e9, l4, t4, false) : M3(e9, l4)) : _3(e9, l4, t4, false);
    }
    else s2 || (l4.reading = false, M3(e9, l4));
    return !l4.ended && (l4.length < l4.highWaterMark || 0 === l4.length);
  }
  function _3(e9, t4, n3, r4) {
    t4.flowing && 0 === t4.length && !t4.sync ? (t4.awaitDrain = 0, e9.emit("data", n3)) : (t4.length += t4.objectMode ? 1 : n3.length, r4 ? t4.buffer.unshift(n3) : t4.buffer.push(n3), t4.needReadable && A3(e9)), M3(e9, t4);
  }
  Object.defineProperty(E2.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._readableState && this._readableState.destroyed;
  }, set: function(e9) {
    this._readableState && (this._readableState.destroyed = e9);
  } }), E2.prototype.destroy = u2.destroy, E2.prototype._undestroy = u2.undestroy, E2.prototype._destroy = function(e9, t4) {
    t4(e9);
  }, E2.prototype.push = function(e9, t4) {
    var n3, i3 = this._readableState;
    return i3.objectMode ? n3 = true : "string" == typeof e9 && ((t4 = t4 || i3.defaultEncoding) !== i3.encoding && (e9 = r3.from(e9, t4), t4 = ""), n3 = true), S3(this, e9, t4, false, n3);
  }, E2.prototype.unshift = function(e9) {
    return S3(this, e9, null, true, false);
  }, E2.prototype.isPaused = function() {
    return false === this._readableState.flowing;
  }, E2.prototype.setEncoding = function(e9) {
    a || (a = kd.StringDecoder);
    var t4 = new a(e9);
    this._readableState.decoder = t4, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var n3 = this._readableState.buffer.head, r4 = ""; null !== n3; ) r4 += t4.write(n3.data), n3 = n3.next;
    return this._readableState.buffer.clear(), "" !== r4 && this._readableState.buffer.push(r4), this._readableState.length = r4.length, this;
  };
  var C3 = 1073741824;
  function k3(e9, t4) {
    return e9 <= 0 || 0 === t4.length && t4.ended ? 0 : t4.objectMode ? 1 : e9 != e9 ? t4.flowing && t4.length ? t4.buffer.head.data.length : t4.length : (e9 > t4.highWaterMark && (t4.highWaterMark = function(e10) {
      return e10 >= C3 ? e10 = C3 : (e10--, e10 |= e10 >>> 1, e10 |= e10 >>> 2, e10 |= e10 >>> 4, e10 |= e10 >>> 8, e10 |= e10 >>> 16, e10++), e10;
    }(e9)), e9 <= t4.length ? e9 : t4.ended ? t4.length : (t4.needReadable = true, 0));
  }
  function A3(e9) {
    var t4 = e9._readableState;
    o("emitReadable", t4.needReadable, t4.emittedReadable), t4.needReadable = false, t4.emittedReadable || (o("emitReadable", t4.flowing), t4.emittedReadable = true, ua.nextTick(x3, e9));
  }
  function x3(e9) {
    var t4 = e9._readableState;
    o("emitReadable_", t4.destroyed, t4.length, t4.ended), t4.destroyed || !t4.length && !t4.ended || (e9.emit("readable"), t4.emittedReadable = false), t4.needReadable = !t4.flowing && !t4.ended && t4.length <= t4.highWaterMark, O3(e9);
  }
  function M3(e9, t4) {
    t4.readingMore || (t4.readingMore = true, ua.nextTick(I3, e9, t4));
  }
  function I3(e9, t4) {
    for (; !t4.reading && !t4.ended && (t4.length < t4.highWaterMark || t4.flowing && 0 === t4.length); ) {
      var n3 = t4.length;
      if (o("maybeReadMore read 0"), e9.read(0), n3 === t4.length) break;
    }
    t4.readingMore = false;
  }
  function T2(e9) {
    var t4 = e9._readableState;
    t4.readableListening = e9.listenerCount("readable") > 0, t4.resumeScheduled && !t4.paused ? t4.flowing = true : e9.listenerCount("data") > 0 && e9.resume();
  }
  function R3(e9) {
    o("readable nexttick read 0"), e9.read(0);
  }
  function P3(e9, t4) {
    o("resume", t4.reading), t4.reading || e9.read(0), t4.resumeScheduled = false, e9.emit("resume"), O3(e9), t4.flowing && !t4.reading && e9.read(0);
  }
  function O3(e9) {
    var t4 = e9._readableState;
    for (o("flow", t4.flowing); t4.flowing && null !== e9.read(); ) ;
  }
  function N3(e9, t4) {
    return 0 === t4.length ? null : (t4.objectMode ? n3 = t4.buffer.shift() : !e9 || e9 >= t4.length ? (n3 = t4.decoder ? t4.buffer.join("") : 1 === t4.buffer.length ? t4.buffer.first() : t4.buffer.concat(t4.length), t4.buffer.clear()) : n3 = t4.buffer.consume(e9, t4.decoder), n3);
    var n3;
  }
  function L3(e9) {
    var t4 = e9._readableState;
    o("endReadable", t4.endEmitted), t4.endEmitted || (t4.ended = true, ua.nextTick(D3, t4, e9));
  }
  function D3(e9, t4) {
    if (o("endReadableNT", e9.endEmitted, e9.length), !e9.endEmitted && 0 === e9.length && (e9.endEmitted = true, t4.readable = false, t4.emit("end"), e9.autoDestroy)) {
      var n3 = t4._writableState;
      (!n3 || n3.autoDestroy && n3.finished) && t4.destroy();
    }
  }
  function $3(e9, t4) {
    for (var n3 = 0, r4 = e9.length; n3 < r4; n3++) if (e9[n3] === t4) return n3;
    return -1;
  }
  return E2.prototype.read = function(e9) {
    o("read", e9), e9 = parseInt(e9, 10);
    var t4 = this._readableState, n3 = e9;
    if (0 !== e9 && (t4.emittedReadable = false), 0 === e9 && t4.needReadable && ((0 !== t4.highWaterMark ? t4.length >= t4.highWaterMark : t4.length > 0) || t4.ended)) return o("read: emitReadable", t4.length, t4.ended), 0 === t4.length && t4.ended ? L3(this) : A3(this), null;
    if (0 === (e9 = k3(e9, t4)) && t4.ended) return 0 === t4.length && L3(this), null;
    var r4, i3 = t4.needReadable;
    return o("need readable", i3), (0 === t4.length || t4.length - e9 < t4.highWaterMark) && o("length less than watermark", i3 = true), t4.ended || t4.reading ? o("reading or ended", i3 = false) : i3 && (o("do read"), t4.reading = true, t4.sync = true, 0 === t4.length && (t4.needReadable = true), this._read(t4.highWaterMark), t4.sync = false, t4.reading || (e9 = k3(n3, t4))), null === (r4 = e9 > 0 ? N3(e9, t4) : null) ? (t4.needReadable = t4.length <= t4.highWaterMark, e9 = 0) : (t4.length -= e9, t4.awaitDrain = 0), 0 === t4.length && (t4.ended || (t4.needReadable = true), n3 !== e9 && t4.ended && L3(this)), null !== r4 && this.emit("data", r4), r4;
  }, E2.prototype._read = function(e9) {
    v2(this, new m2("_read()"));
  }, E2.prototype.pipe = function(e9, n3) {
    var r4 = this, i3 = this._readableState;
    switch (i3.pipesCount) {
      case 0:
        i3.pipes = e9;
        break;
      case 1:
        i3.pipes = [i3.pipes, e9];
        break;
      default:
        i3.pipes.push(e9);
    }
    i3.pipesCount += 1, o("pipe count=%d opts=%j", i3.pipesCount, n3);
    var s2 = (!n3 || false !== n3.end) && e9 !== ua.stdout && e9 !== ua.stderr ? c3 : g4;
    function a2(t4, n4) {
      o("onunpipe"), t4 === r4 && n4 && false === n4.hasUnpiped && (n4.hasUnpiped = true, o("cleanup"), e9.removeListener("close", f3), e9.removeListener("finish", p4), e9.removeListener("drain", l4), e9.removeListener("error", h4), e9.removeListener("unpipe", a2), r4.removeListener("end", c3), r4.removeListener("end", g4), r4.removeListener("data", u3), d4 = true, !i3.awaitDrain || e9._writableState && !e9._writableState.needDrain || l4());
    }
    function c3() {
      o("onend"), e9.end();
    }
    i3.endEmitted ? ua.nextTick(s2) : r4.once("end", s2), e9.on("unpipe", a2);
    var l4 = /* @__PURE__ */ function(e10) {
      return function() {
        var n4 = e10._readableState;
        o("pipeOnDrain", n4.awaitDrain), n4.awaitDrain && n4.awaitDrain--, 0 === n4.awaitDrain && t3(e10, "data") && (n4.flowing = true, O3(e10));
      };
    }(r4);
    e9.on("drain", l4);
    var d4 = false;
    function u3(t4) {
      o("ondata");
      var n4 = e9.write(t4);
      o("dest.write", n4), false === n4 && ((1 === i3.pipesCount && i3.pipes === e9 || i3.pipesCount > 1 && -1 !== $3(i3.pipes, e9)) && !d4 && (o("false write response, pause", i3.awaitDrain), i3.awaitDrain++), r4.pause());
    }
    function h4(n4) {
      o("onerror", n4), g4(), e9.removeListener("error", h4), 0 === t3(e9, "error") && v2(e9, n4);
    }
    function f3() {
      e9.removeListener("finish", p4), g4();
    }
    function p4() {
      o("onfinish"), e9.removeListener("close", f3), g4();
    }
    function g4() {
      o("unpipe"), r4.unpipe(e9);
    }
    return r4.on("data", u3), function(e10, t4, n4) {
      if ("function" == typeof e10.prependListener) return e10.prependListener(t4, n4);
      e10._events && e10._events[t4] ? Array.isArray(e10._events[t4]) ? e10._events[t4].unshift(n4) : e10._events[t4] = [n4, e10._events[t4]] : e10.on(t4, n4);
    }(e9, "error", h4), e9.once("close", f3), e9.once("finish", p4), e9.emit("pipe", r4), i3.flowing || (o("pipe resume"), r4.resume()), e9;
  }, E2.prototype.unpipe = function(e9) {
    var t4 = this._readableState, n3 = { hasUnpiped: false };
    if (0 === t4.pipesCount) return this;
    if (1 === t4.pipesCount) return e9 && e9 !== t4.pipes || (e9 || (e9 = t4.pipes), t4.pipes = null, t4.pipesCount = 0, t4.flowing = false, e9 && e9.emit("unpipe", this, n3)), this;
    if (!e9) {
      var r4 = t4.pipes, i3 = t4.pipesCount;
      t4.pipes = null, t4.pipesCount = 0, t4.flowing = false;
      for (var o2 = 0; o2 < i3; o2++) r4[o2].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var s2 = $3(t4.pipes, e9);
    return -1 === s2 || (t4.pipes.splice(s2, 1), t4.pipesCount -= 1, 1 === t4.pipesCount && (t4.pipes = t4.pipes[0]), e9.emit("unpipe", this, n3)), this;
  }, E2.prototype.on = function(e9, t4) {
    var r4 = n2.prototype.on.call(this, e9, t4), i3 = this._readableState;
    return "data" === e9 ? (i3.readableListening = this.listenerCount("readable") > 0, false !== i3.flowing && this.resume()) : "readable" === e9 && (i3.endEmitted || i3.readableListening || (i3.readableListening = i3.needReadable = true, i3.flowing = false, i3.emittedReadable = false, o("on readable", i3.length, i3.reading), i3.length ? A3(this) : i3.reading || ua.nextTick(R3, this))), r4;
  }, E2.prototype.addListener = E2.prototype.on, E2.prototype.removeListener = function(e9, t4) {
    var r4 = n2.prototype.removeListener.call(this, e9, t4);
    return "readable" === e9 && ua.nextTick(T2, this), r4;
  }, E2.prototype.removeAllListeners = function(e9) {
    var t4 = n2.prototype.removeAllListeners.apply(this, arguments);
    return "readable" !== e9 && void 0 !== e9 || ua.nextTick(T2, this), t4;
  }, E2.prototype.resume = function() {
    var e9 = this._readableState;
    return e9.flowing || (o("resume"), e9.flowing = !e9.readableListening, function(e10, t4) {
      t4.resumeScheduled || (t4.resumeScheduled = true, ua.nextTick(P3, e10, t4));
    }(this, e9)), e9.paused = false, this;
  }, E2.prototype.pause = function() {
    return o("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (o("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  }, E2.prototype.wrap = function(e9) {
    var t4 = this, n3 = this._readableState, r4 = false;
    for (var i3 in e9.on("end", function() {
      if (o("wrapped end"), n3.decoder && !n3.ended) {
        var e10 = n3.decoder.end();
        e10 && e10.length && t4.push(e10);
      }
      t4.push(null);
    }), e9.on("data", function(i4) {
      (o("wrapped data"), n3.decoder && (i4 = n3.decoder.write(i4)), n3.objectMode && null == i4) || (n3.objectMode || i4 && i4.length) && (t4.push(i4) || (r4 = true, e9.pause()));
    }), e9) void 0 === this[i3] && "function" == typeof e9[i3] && (this[i3] = /* @__PURE__ */ function(t5) {
      return function() {
        return e9[t5].apply(e9, arguments);
      };
    }(i3));
    for (var s2 = 0; s2 < b3.length; s2++) e9.on(b3[s2], this.emit.bind(this, b3[s2]));
    return this._read = function(t5) {
      o("wrapped _read", t5), r4 && (r4 = false, e9.resume());
    }, this;
  }, "function" == typeof Symbol && (E2.prototype[Symbol.asyncIterator] = function() {
    return void 0 === c2 && (c2 = Ld()), c2(this);
  }), Object.defineProperty(E2.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(E2.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(E2.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e9) {
    this._readableState && (this._readableState.flowing = e9);
  } }), E2._fromList = N3, Object.defineProperty(E2.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } }), "function" == typeof Symbol && (E2.from = function(e9, t4) {
    return void 0 === l3 && (l3 = Rd ? Td : (Rd = 1, Td = function() {
      throw new Error("Readable.from is not available in the browser");
    })), l3(E2, e9, t4);
  }), Pd;
}
var $d = qd;
var Bd = nd.codes;
var Kd = Bd.ERR_METHOD_NOT_IMPLEMENTED;
var jd = Bd.ERR_MULTIPLE_CALLBACK;
var Ud = Bd.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var Hd = Bd.ERR_TRANSFORM_WITH_LENGTH_0;
var Fd = bd();
function zd(e8, t3) {
  var n2 = this._transformState;
  n2.transforming = false;
  var r3 = n2.writecb;
  if (null === r3) return this.emit("error", new jd());
  n2.writechunk = null, n2.writecb = null, null != t3 && this.push(t3), r3(e8);
  var i2 = this._readableState;
  i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
}
function qd(e8) {
  if (!(this instanceof qd)) return new qd(e8);
  Fd.call(this, e8), this._transformState = { afterTransform: zd.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e8 && ("function" == typeof e8.transform && (this._transform = e8.transform), "function" == typeof e8.flush && (this._flush = e8.flush)), this.on("prefinish", Wd);
}
function Wd() {
  var e8 = this;
  "function" != typeof this._flush || this._readableState.destroyed ? Vd(this, null, null) : this._flush(function(t3, n2) {
    Vd(e8, t3, n2);
  });
}
function Vd(e8, t3, n2) {
  if (t3) return e8.emit("error", t3);
  if (null != n2 && e8.push(n2), e8._writableState.length) throw new Hd();
  if (e8._transformState.transforming) throw new Ud();
  return e8.push(null);
}
md(qd, Fd), qd.prototype.push = function(e8, t3) {
  return this._transformState.needTransform = false, Fd.prototype.push.call(this, e8, t3);
}, qd.prototype._transform = function(e8, t3, n2) {
  n2(new Kd("_transform()"));
}, qd.prototype._write = function(e8, t3, n2) {
  var r3 = this._transformState;
  if (r3.writecb = n2, r3.writechunk = e8, r3.writeencoding = t3, !r3.transforming) {
    var i2 = this._readableState;
    (r3.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
  }
}, qd.prototype._read = function(e8) {
  var t3 = this._transformState;
  null === t3.writechunk || t3.transforming ? t3.needTransform = true : (t3.transforming = true, this._transform(t3.writechunk, t3.writeencoding, t3.afterTransform));
}, qd.prototype._destroy = function(e8, t3) {
  Fd.prototype._destroy.call(this, e8, function(e9) {
    t3(e9);
  });
};
var Gd;
var Yd = Jd;
var Zd = $d;
function Jd(e8) {
  if (!(this instanceof Jd)) return new Jd(e8);
  Zd.call(this, e8);
}
md(Jd, Zd), Jd.prototype._transform = function(e8, t3, n2) {
  n2(null, e8);
};
var Qd = nd.codes;
var Xd = Qd.ERR_MISSING_ARGS;
var eu = Qd.ERR_STREAM_DESTROYED;
function tu(e8) {
  if (e8) throw e8;
}
function nu(e8) {
  e8();
}
function ru(e8, t3) {
  return e8.pipe(t3);
}
var iu = function() {
  for (var e8 = arguments.length, t3 = new Array(e8), n2 = 0; n2 < e8; n2++) t3[n2] = arguments[n2];
  var r3, i2 = function(e9) {
    return e9.length ? "function" != typeof e9[e9.length - 1] ? tu : e9.pop() : tu;
  }(t3);
  if (Array.isArray(t3[0]) && (t3 = t3[0]), t3.length < 2) throw new Xd("streams");
  var o = t3.map(function(e9, n3) {
    var s = n3 < t3.length - 1;
    return function(e10, t4, n4, r4) {
      r4 = /* @__PURE__ */ function(e11) {
        var t5 = false;
        return function() {
          t5 || (t5 = true, e11.apply(void 0, arguments));
        };
      }(r4);
      var i3 = false;
      e10.on("close", function() {
        i3 = true;
      }), void 0 === Gd && (Gd = Nd), Gd(e10, { readable: t4, writable: n4 }, function(e11) {
        if (e11) return r4(e11);
        i3 = true, r4();
      });
      var o2 = false;
      return function(t5) {
        if (!i3 && !o2) return o2 = true, function(e11) {
          return e11.setHeader && "function" == typeof e11.abort;
        }(e10) ? e10.abort() : "function" == typeof e10.destroy ? e10.destroy() : void r4(t5 || new eu("pipe"));
      };
    }(e9, s, n3 > 0, function(e10) {
      r3 || (r3 = e10), e10 && o.forEach(nu), s || (o.forEach(nu), i2(r3));
    });
  });
  return t3.reduce(ru);
};
!function(e8, t3) {
  (t3 = sl.exports = Dd()).Stream = t3, t3.Readable = t3, t3.Writable = vd(), t3.Duplex = bd(), t3.Transform = $d, t3.PassThrough = Yd, t3.finished = Nd, t3.pipeline = iu;
}(0, sl.exports);
var ou = sl.exports;
function su(e8 = {}) {
  const t3 = {}, n2 = new ou.Duplex({ objectMode: true, read: () => {
  }, write: function(n3, o, s) {
    let a = null;
    try {
      !n3.id ? function(n4) {
        (e8 == null ? void 0 : e8.retryOnMessage) && n4.method === e8.retryOnMessage && Object.values(t3).forEach(({ req: e9, retryCount: n5 = 0 }) => {
          if (!e9.id) return;
          if (n5 >= 3) throw new Error(`StreamMiddleware - Retry limit exceeded for request id "${e9.id}"`);
          const r4 = t3[e9.id];
          r4 && (r4.retryCount = n5 + 1), i2(e9);
        });
        r3.emit("notification", n4);
      }(n3) : function(e9) {
        const { id: n4 } = e9;
        if (null === n4) return;
        const r4 = t3[n4];
        if (!r4) return void console.warn(`StreamMiddleware - Unknown response id "${n4}"`);
        delete t3[n4], Object.assign(r4.res, e9), setTimeout(r4.end);
      }(n3);
    } catch (e9) {
      a = e9;
    }
    s(a);
  } }), r3 = new Pc();
  return { events: r3, middleware: (e9, n3, r4, o) => {
    t3[e9.id] = { req: e9, res: n3, next: r4, end: o }, i2(e9);
  }, stream: n2 };
  function i2(e9) {
    n2.push(e9);
  }
}
var au = {};
var cu = { exports: {} };
var lu = function e6(t3, n2) {
  if (t3 && n2) return e6(t3)(n2);
  if ("function" != typeof t3) throw new TypeError("need wrapper function");
  return Object.keys(t3).forEach(function(e8) {
    r3[e8] = t3[e8];
  }), r3;
  function r3() {
    for (var e8 = new Array(arguments.length), n3 = 0; n3 < e8.length; n3++) e8[n3] = arguments[n3];
    var r4 = t3.apply(this, e8), i2 = e8[e8.length - 1];
    return "function" == typeof r4 && r4 !== i2 && Object.keys(i2).forEach(function(e9) {
      r4[e9] = i2[e9];
    }), r4;
  }
};
var du = lu;
function uu(e8) {
  var t3 = function() {
    return t3.called ? t3.value : (t3.called = true, t3.value = e8.apply(this, arguments));
  };
  return t3.called = false, t3;
}
function hu(e8) {
  var t3 = function() {
    if (t3.called) throw new Error(t3.onceError);
    return t3.called = true, t3.value = e8.apply(this, arguments);
  }, n2 = e8.name || "Function wrapped with `once`";
  return t3.onceError = n2 + " shouldn't be called more than once", t3.called = false, t3;
}
cu.exports = du(uu), cu.exports.strict = du(hu), uu.proto = uu(function() {
  Object.defineProperty(Function.prototype, "once", { value: function() {
    return uu(this);
  }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
    return hu(this);
  }, configurable: true });
});
var fu = cu.exports;
var pu = {};
Object.defineProperty(pu, "__esModule", { value: true }), pu.Substream = void 0;
var gu = ou;
var mu = class extends gu.Duplex {
  constructor({ parent: e8, name: t3 }) {
    super({ objectMode: true }), this._parent = e8, this._name = t3;
  }
  _read() {
  }
  _write(e8, t3, n2) {
    this._parent.push({ name: this._name, data: e8 }), n2();
  }
};
pu.Substream = mu;
var yu = de && de.__importDefault || function(e8) {
  return e8 && e8.__esModule ? e8 : { default: e8 };
};
Object.defineProperty(au, "__esModule", { value: true }), au.ObjectMultiplex = void 0;
var vu = ou;
var bu = yu(fu);
var wu = pu;
var Eu = Symbol("IGNORE_SUBSTREAM");
var Su = class extends vu.Duplex {
  constructor(e8 = {}) {
    super(Object.assign(Object.assign({}, e8), { objectMode: true })), this._substreams = {};
  }
  createStream(e8) {
    if (this.destroyed) throw new Error(`ObjectMultiplex - parent stream for name "${e8}" already destroyed`);
    if (this._readableState.ended || this._writableState.ended) throw new Error(`ObjectMultiplex - parent stream for name "${e8}" already ended`);
    if (!e8) throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[e8]) throw new Error(`ObjectMultiplex - Substream for name "${e8}" already exists`);
    const t3 = new wu.Substream({ parent: this, name: e8 });
    return this._substreams[e8] = t3, function(e9, t4) {
      const n2 = (0, bu.default)(t4);
      (0, vu.finished)(e9, { readable: false }, n2), (0, vu.finished)(e9, { writable: false }, n2);
    }(this, (e9) => t3.destroy(e9 || void 0)), t3;
  }
  ignoreStream(e8) {
    if (!e8) throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[e8]) throw new Error(`ObjectMultiplex - Substream for name "${e8}" already exists`);
    this._substreams[e8] = Eu;
  }
  _read() {
  }
  _write(e8, t3, n2) {
    const { name: r3, data: i2 } = e8;
    if (!r3) return console.warn(`ObjectMultiplex - malformed chunk without name "${e8}"`), n2();
    const o = this._substreams[r3];
    return o ? (o !== Eu && o.push(i2), n2()) : (console.warn(`ObjectMultiplex - orphaned data for stream "${r3}"`), n2());
  }
};
au.ObjectMultiplex = Su;
var _u = ue(au.ObjectMultiplex);
var Cu = (e8) => null !== e8 && "object" == typeof e8 && "function" == typeof e8.pipe;
Cu.writable = (e8) => Cu(e8) && false !== e8.writable && "function" == typeof e8._write && "object" == typeof e8._writableState, Cu.readable = (e8) => Cu(e8) && false !== e8.readable && "function" == typeof e8._read && "object" == typeof e8._readableState, Cu.duplex = (e8) => Cu.writable(e8) && Cu.readable(e8), Cu.transform = (e8) => Cu.duplex(e8) && "function" == typeof e8._transform;
var ku;
var Au = Cu;
var xu = class extends ol {
  constructor(e8, { jsonRpcStreamName: t3, logger: n2 = console, maxEventListeners: r3 = 100, rpcMiddleware: i2 = [] }) {
    if (super({ logger: n2, maxEventListeners: r3, rpcMiddleware: i2 }), !Au.duplex(e8)) throw new Error(is.errors.invalidDuplexStream());
    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
    const o = new _u();
    ou.pipeline(e8, o, e8, this._handleStreamDisconnect.bind(this, "MetaMask")), this._jsonRpcConnection = su({ retryOnMessage: "METAMASK_EXTENSION_CONNECT_CAN_RETRY" }), ou.pipeline(this._jsonRpcConnection.stream, o.createStream(t3), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "MetaMask RpcProvider")), this._rpcEngine.push(this._jsonRpcConnection.middleware), this._jsonRpcConnection.events.on("notification", (t4) => {
      const { method: n3, params: r4 } = t4;
      "metamask_accountsChanged" === n3 ? this._handleAccountsChanged(r4) : "metamask_unlockStateChanged" === n3 ? this._handleUnlockStateChanged(r4) : "metamask_chainChanged" === n3 ? this._handleChainChanged(r4) : Dc.includes(n3) ? this.emit("message", { type: n3, data: r4 }) : "METAMASK_STREAM_FAILURE" === n3 && e8.destroy(new Error(is.errors.permanentlyDisconnected()));
    });
  }
  async _initializeStateAsync() {
    let e8;
    try {
      e8 = await this.request({ method: "metamask_getProviderState" });
    } catch (e9) {
      this._log.error("MetaMask: Failed to get initial state. Please report this bug.", e9);
    }
    this._initializeState(e8);
  }
  _handleStreamDisconnect(e8, t3) {
    let n2 = `MetaMask: Lost connection to "${e8}".`;
    (t3 == null ? void 0 : t3.stack) && (n2 += `
${t3.stack}`), this._log.warn(n2), this.listenerCount("error") > 0 && this.emit("error", n2), this._handleDisconnect(false, t3 ? t3.message : void 0);
  }
  _handleChainChanged({ chainId: e8, networkVersion: t3 } = {}) {
    jc(e8) && ((e9) => Boolean(e9) && "string" == typeof e9)(t3) ? "loading" === t3 ? this._handleDisconnect(true) : super._handleChainChanged({ chainId: e8 }) : this._log.error(is.errors.invalidNetworkParams(), { chainId: e8, networkVersion: t3 });
  }
};
var Mu = class extends xu {
  constructor(e8, { jsonRpcStreamName: t3 = "metamask-provider", logger: n2 = console, maxEventListeners: r3 = 100, shouldSendMetadata: i2 } = {}) {
    if (super(e8, { jsonRpcStreamName: t3, logger: n2, maxEventListeners: r3, rpcMiddleware: $c(n2) }), this._sentWarnings = { chainId: false, networkVersion: false, selectedAddress: false, enable: false, experimentalMethods: false, send: false, events: { close: false, data: false, networkChanged: false, notification: false } }, Gc(this, ku, void 0), this._initializeStateAsync(), Yc(this, ku, null), this.isMetaMask = true, this._sendSync = this._sendSync.bind(this), this.enable = this.enable.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this._warnOfDeprecation = this._warnOfDeprecation.bind(this), this._metamask = this._getExperimentalApi(), this._jsonRpcConnection.events.on("notification", (e9) => {
      const { method: t4 } = e9;
      Dc.includes(t4) && (this.emit("data", e9), this.emit("notification", e9.params.result));
    }), i2) if ("complete" === document.readyState) Hc(this._rpcEngine, this._log);
    else {
      const e9 = () => {
        Hc(this._rpcEngine, this._log), window.removeEventListener("DOMContentLoaded", e9);
      };
      window.addEventListener("DOMContentLoaded", e9);
    }
  }
  get chainId() {
    return this._sentWarnings.chainId || (this._log.warn(is.warnings.chainIdDeprecation), this._sentWarnings.chainId = true), super.chainId;
  }
  get networkVersion() {
    return this._sentWarnings.networkVersion || (this._log.warn(is.warnings.networkVersionDeprecation), this._sentWarnings.networkVersion = true), Vc(this, ku);
  }
  get selectedAddress() {
    return this._sentWarnings.selectedAddress || (this._log.warn(is.warnings.selectedAddressDeprecation), this._sentWarnings.selectedAddress = true), super.selectedAddress;
  }
  sendAsync(e8, t3) {
    this._rpcRequest(e8, t3);
  }
  addListener(e8, t3) {
    return this._warnOfDeprecation(e8), super.addListener(e8, t3);
  }
  on(e8, t3) {
    return this._warnOfDeprecation(e8), super.on(e8, t3);
  }
  once(e8, t3) {
    return this._warnOfDeprecation(e8), super.once(e8, t3);
  }
  prependListener(e8, t3) {
    return this._warnOfDeprecation(e8), super.prependListener(e8, t3);
  }
  prependOnceListener(e8, t3) {
    return this._warnOfDeprecation(e8), super.prependOnceListener(e8, t3);
  }
  _handleDisconnect(e8, t3) {
    super._handleDisconnect(e8, t3), Vc(this, ku) && !e8 && Yc(this, ku, null);
  }
  _warnOfDeprecation(e8) {
    var _a2;
    false === ((_a2 = this._sentWarnings) == null ? void 0 : _a2.events[e8]) && (this._log.warn(is.warnings.events[e8]), this._sentWarnings.events[e8] = true);
  }
  async enable() {
    return this._sentWarnings.enable || (this._log.warn(is.warnings.enableDeprecation), this._sentWarnings.enable = true), new Promise((e8, t3) => {
      try {
        this._rpcRequest({ method: "eth_requestAccounts", params: [] }, Kc(e8, t3));
      } catch (e9) {
        t3(e9);
      }
    });
  }
  send(e8, t3) {
    return this._sentWarnings.send || (this._log.warn(is.warnings.sendDeprecation), this._sentWarnings.send = true), "string" != typeof e8 || t3 && !Array.isArray(t3) ? e8 && "object" == typeof e8 && "function" == typeof t3 ? this._rpcRequest(e8, t3) : this._sendSync(e8) : new Promise((n2, r3) => {
      try {
        this._rpcRequest({ method: e8, params: t3 }, Kc(n2, r3, false));
      } catch (e9) {
        r3(e9);
      }
    });
  }
  _sendSync(e8) {
    let t3;
    switch (e8.method) {
      case "eth_accounts":
        t3 = this.selectedAddress ? [this.selectedAddress] : [];
        break;
      case "eth_coinbase":
        t3 = this.selectedAddress ?? null;
        break;
      case "eth_uninstallFilter":
        this._rpcRequest(e8, Uc), t3 = true;
        break;
      case "net_version":
        t3 = Vc(this, ku) ?? null;
        break;
      default:
        throw new Error(is.errors.unsupportedSync(e8.method));
    }
    return { id: e8.id, jsonrpc: e8.jsonrpc, result: t3 };
  }
  _getExperimentalApi() {
    return new Proxy({ isUnlocked: async () => (this._state.initialized || await new Promise((e8) => {
      this.on("_initialized", () => e8());
    }), this._state.isUnlocked), requestBatch: async (e8) => {
      if (!Array.isArray(e8)) throw Xa({ message: "Batch requests must be made with an array of request objects.", data: e8 });
      return new Promise((t3, n2) => {
        this._rpcRequest(e8, Kc(t3, n2));
      });
    } }, { get: (e8, t3, ...n2) => (this._sentWarnings.experimentalMethods || (this._log.warn(is.warnings.experimentalMethods), this._sentWarnings.experimentalMethods = true), Reflect.get(e8, t3, ...n2)) });
  }
  _handleChainChanged({ chainId: e8, networkVersion: t3 } = {}) {
    super._handleChainChanged({ chainId: e8, networkVersion: t3 }), this._state.isConnected && t3 !== Vc(this, ku) && (Yc(this, ku, t3), this._state.initialized && this.emit("networkChanged", Vc(this, ku)));
  }
};
ku = /* @__PURE__ */ new WeakMap();
var Iu = (0, import_debug.default)("MM_SDK");
var Tu;
Iu.color = "#FFAC1C";
var Ru = {};
var Pu = {};
Object.defineProperty(Pu, "__esModule", { value: true }), Pu.EthereumProviderError = Pu.EthereumRpcError = void 0;
var Ou = $a;
var Nu = class extends Error {
  constructor(e8, t3, n2) {
    if (!Number.isInteger(e8)) throw new Error('"code" must be an integer.');
    if (!t3 || "string" != typeof t3) throw new Error('"message" must be a nonempty string.');
    super(t3), this.code = e8, void 0 !== n2 && (this.data = n2);
  }
  serialize() {
    const e8 = { code: this.code, message: this.message };
    return void 0 !== this.data && (e8.data = this.data), this.stack && (e8.stack = this.stack), e8;
  }
  toString() {
    return Ou.default(this.serialize(), Lu, 2);
  }
};
Pu.EthereumRpcError = Nu;
function Lu(e8, t3) {
  if ("[Circular]" !== t3) return t3;
}
Pu.EthereumProviderError = class extends Nu {
  constructor(e8, t3, n2) {
    if (!function(e9) {
      return Number.isInteger(e9) && e9 >= 1e3 && e9 <= 4999;
    }(e8)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e8, t3, n2);
  }
};
var Du = {};
var $u = {};
Object.defineProperty($u, "__esModule", { value: true }), $u.errorValues = $u.errorCodes = void 0, $u.errorCodes = { rpc: { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 }, provider: { userRejectedRequest: 4001, unauthorized: 4100, unsupportedMethod: 4200, disconnected: 4900, chainDisconnected: 4901 } }, $u.errorValues = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } }, function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.serializeError = e8.isValidCode = e8.getMessageFromCode = e8.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t3 = $u, n2 = Pu, r3 = t3.errorCodes.rpc.internal, i2 = "Unspecified error message. This is a bug, please report it.", o = { code: r3, message: s(r3) };
  function s(n3, r4 = i2) {
    if (Number.isInteger(n3)) {
      const r5 = n3.toString();
      if (d3(t3.errorValues, r5)) return t3.errorValues[r5].message;
      if (c2(n3)) return e8.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return r4;
  }
  function a(e9) {
    if (!Number.isInteger(e9)) return false;
    const n3 = e9.toString();
    return !!t3.errorValues[n3] || !!c2(e9);
  }
  function c2(e9) {
    return e9 >= -32099 && e9 <= -32e3;
  }
  function l3(e9) {
    return e9 && "object" == typeof e9 && !Array.isArray(e9) ? Object.assign({}, e9) : e9;
  }
  function d3(e9, t4) {
    return Object.prototype.hasOwnProperty.call(e9, t4);
  }
  e8.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.", e8.getMessageFromCode = s, e8.isValidCode = a, e8.serializeError = function(e9, { fallbackError: t4 = o, shouldIncludeStack: r4 = false } = {}) {
    var i3, c3;
    if (!t4 || !Number.isInteger(t4.code) || "string" != typeof t4.message) throw new Error("Must provide fallback error with integer number code and string message.");
    if (e9 instanceof n2.EthereumRpcError) return e9.serialize();
    const u2 = {};
    if (e9 && "object" == typeof e9 && !Array.isArray(e9) && d3(e9, "code") && a(e9.code)) {
      const t5 = e9;
      u2.code = t5.code, t5.message && "string" == typeof t5.message ? (u2.message = t5.message, d3(t5, "data") && (u2.data = t5.data)) : (u2.message = s(u2.code), u2.data = { originalError: l3(e9) });
    } else {
      u2.code = t4.code;
      const n3 = null === (i3 = e9) || void 0 === i3 ? void 0 : i3.message;
      u2.message = n3 && "string" == typeof n3 ? n3 : t4.message, u2.data = { originalError: l3(e9) };
    }
    const h3 = null === (c3 = e9) || void 0 === c3 ? void 0 : c3.stack;
    return r4 && e9 && h3 && "string" == typeof h3 && (u2.stack = h3), u2;
  };
}(Du);
var Bu = {};
Object.defineProperty(Bu, "__esModule", { value: true }), Bu.ethErrors = void 0;
var Ku = Pu;
var ju = Du;
var Uu = $u;
function Hu(e8, t3) {
  const [n2, r3] = zu(t3);
  return new Ku.EthereumRpcError(e8, n2 || ju.getMessageFromCode(e8), r3);
}
function Fu(e8, t3) {
  const [n2, r3] = zu(t3);
  return new Ku.EthereumProviderError(e8, n2 || ju.getMessageFromCode(e8), r3);
}
function zu(e8) {
  if (e8) {
    if ("string" == typeof e8) return [e8];
    if ("object" == typeof e8 && !Array.isArray(e8)) {
      const { message: t3, data: n2 } = e8;
      if (t3 && "string" != typeof t3) throw new Error("Must specify string message.");
      return [t3 || void 0, n2];
    }
  }
  return [];
}
Bu.ethErrors = { rpc: { parse: (e8) => Hu(Uu.errorCodes.rpc.parse, e8), invalidRequest: (e8) => Hu(Uu.errorCodes.rpc.invalidRequest, e8), invalidParams: (e8) => Hu(Uu.errorCodes.rpc.invalidParams, e8), methodNotFound: (e8) => Hu(Uu.errorCodes.rpc.methodNotFound, e8), internal: (e8) => Hu(Uu.errorCodes.rpc.internal, e8), server: (e8) => {
  if (!e8 || "object" != typeof e8 || Array.isArray(e8)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
  const { code: t3 } = e8;
  if (!Number.isInteger(t3) || t3 > -32005 || t3 < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
  return Hu(t3, e8);
}, invalidInput: (e8) => Hu(Uu.errorCodes.rpc.invalidInput, e8), resourceNotFound: (e8) => Hu(Uu.errorCodes.rpc.resourceNotFound, e8), resourceUnavailable: (e8) => Hu(Uu.errorCodes.rpc.resourceUnavailable, e8), transactionRejected: (e8) => Hu(Uu.errorCodes.rpc.transactionRejected, e8), methodNotSupported: (e8) => Hu(Uu.errorCodes.rpc.methodNotSupported, e8), limitExceeded: (e8) => Hu(Uu.errorCodes.rpc.limitExceeded, e8) }, provider: { userRejectedRequest: (e8) => Fu(Uu.errorCodes.provider.userRejectedRequest, e8), unauthorized: (e8) => Fu(Uu.errorCodes.provider.unauthorized, e8), unsupportedMethod: (e8) => Fu(Uu.errorCodes.provider.unsupportedMethod, e8), disconnected: (e8) => Fu(Uu.errorCodes.provider.disconnected, e8), chainDisconnected: (e8) => Fu(Uu.errorCodes.provider.chainDisconnected, e8), custom: (e8) => {
  if (!e8 || "object" != typeof e8 || Array.isArray(e8)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
  const { code: t3, message: n2, data: r3 } = e8;
  if (!n2 || "string" != typeof n2) throw new Error('"message" must be a nonempty string');
  return new Ku.EthereumProviderError(t3, n2, r3);
} } }, function(e8) {
  Object.defineProperty(e8, "__esModule", { value: true }), e8.getMessageFromCode = e8.serializeError = e8.EthereumProviderError = e8.EthereumRpcError = e8.ethErrors = e8.errorCodes = void 0;
  const t3 = Pu;
  Object.defineProperty(e8, "EthereumRpcError", { enumerable: true, get: function() {
    return t3.EthereumRpcError;
  } }), Object.defineProperty(e8, "EthereumProviderError", { enumerable: true, get: function() {
    return t3.EthereumProviderError;
  } });
  const n2 = Du;
  Object.defineProperty(e8, "serializeError", { enumerable: true, get: function() {
    return n2.serializeError;
  } }), Object.defineProperty(e8, "getMessageFromCode", { enumerable: true, get: function() {
    return n2.getMessageFromCode;
  } });
  const r3 = Bu;
  Object.defineProperty(e8, "ethErrors", { enumerable: true, get: function() {
    return r3.ethErrors;
  } });
  const i2 = $u;
  Object.defineProperty(e8, "errorCodes", { enumerable: true, get: function() {
    return i2.errorCodes;
  } });
}(Ru);
var qu = { exports: {} };
qu.exports = function(e8) {
  var t3 = {};
  function n2(r3) {
    if (t3[r3]) return t3[r3].exports;
    var i2 = t3[r3] = { i: r3, l: false, exports: {} };
    return e8[r3].call(i2.exports, i2, i2.exports, n2), i2.l = true, i2.exports;
  }
  return n2.m = e8, n2.c = t3, n2.d = function(e9, t4, r3) {
    n2.o(e9, t4) || Object.defineProperty(e9, t4, { enumerable: true, get: r3 });
  }, n2.r = function(e9) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e9, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e9, "__esModule", { value: true });
  }, n2.t = function(e9, t4) {
    if (1 & t4 && (e9 = n2(e9)), 8 & t4) return e9;
    if (4 & t4 && "object" == typeof e9 && e9 && e9.__esModule) return e9;
    var r3 = /* @__PURE__ */ Object.create(null);
    if (n2.r(r3), Object.defineProperty(r3, "default", { enumerable: true, value: e9 }), 2 & t4 && "string" != typeof e9) for (var i2 in e9) n2.d(r3, i2, (function(t5) {
      return e9[t5];
    }).bind(null, i2));
    return r3;
  }, n2.n = function(e9) {
    var t4 = e9 && e9.__esModule ? function() {
      return e9.default;
    } : function() {
      return e9;
    };
    return n2.d(t4, "a", t4), t4;
  }, n2.o = function(e9, t4) {
    return Object.prototype.hasOwnProperty.call(e9, t4);
  }, n2.p = "", n2(n2.s = 90);
}({ 17: function(e8, t3, n2) {
  t3.__esModule = true, t3.default = void 0;
  var r3 = n2(18), i2 = function() {
    function e9() {
    }
    return e9.getFirstMatch = function(e10, t4) {
      var n3 = t4.match(e10);
      return n3 && n3.length > 0 && n3[1] || "";
    }, e9.getSecondMatch = function(e10, t4) {
      var n3 = t4.match(e10);
      return n3 && n3.length > 1 && n3[2] || "";
    }, e9.matchAndReturnConst = function(e10, t4, n3) {
      if (e10.test(t4)) return n3;
    }, e9.getWindowsVersionName = function(e10) {
      switch (e10) {
        case "NT":
          return "NT";
        case "XP":
        case "NT 5.1":
          return "XP";
        case "NT 5.0":
          return "2000";
        case "NT 5.2":
          return "2003";
        case "NT 6.0":
          return "Vista";
        case "NT 6.1":
          return "7";
        case "NT 6.2":
          return "8";
        case "NT 6.3":
          return "8.1";
        case "NT 10.0":
          return "10";
        default:
          return;
      }
    }, e9.getMacOSVersionName = function(e10) {
      var t4 = e10.split(".").splice(0, 2).map(function(e11) {
        return parseInt(e11, 10) || 0;
      });
      if (t4.push(0), 10 === t4[0]) switch (t4[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
    }, e9.getAndroidVersionName = function(e10) {
      var t4 = e10.split(".").splice(0, 2).map(function(e11) {
        return parseInt(e11, 10) || 0;
      });
      if (t4.push(0), !(1 === t4[0] && t4[1] < 5)) return 1 === t4[0] && t4[1] < 6 ? "Cupcake" : 1 === t4[0] && t4[1] >= 6 ? "Donut" : 2 === t4[0] && t4[1] < 2 ? "Eclair" : 2 === t4[0] && 2 === t4[1] ? "Froyo" : 2 === t4[0] && t4[1] > 2 ? "Gingerbread" : 3 === t4[0] ? "Honeycomb" : 4 === t4[0] && t4[1] < 1 ? "Ice Cream Sandwich" : 4 === t4[0] && t4[1] < 4 ? "Jelly Bean" : 4 === t4[0] && t4[1] >= 4 ? "KitKat" : 5 === t4[0] ? "Lollipop" : 6 === t4[0] ? "Marshmallow" : 7 === t4[0] ? "Nougat" : 8 === t4[0] ? "Oreo" : 9 === t4[0] ? "Pie" : void 0;
    }, e9.getVersionPrecision = function(e10) {
      return e10.split(".").length;
    }, e9.compareVersions = function(t4, n3, r4) {
      void 0 === r4 && (r4 = false);
      var i3 = e9.getVersionPrecision(t4), o = e9.getVersionPrecision(n3), s = Math.max(i3, o), a = 0, c2 = e9.map([t4, n3], function(t5) {
        var n4 = s - e9.getVersionPrecision(t5), r5 = t5 + new Array(n4 + 1).join(".0");
        return e9.map(r5.split("."), function(e10) {
          return new Array(20 - e10.length).join("0") + e10;
        }).reverse();
      });
      for (r4 && (a = s - Math.min(i3, o)), s -= 1; s >= a; ) {
        if (c2[0][s] > c2[1][s]) return 1;
        if (c2[0][s] === c2[1][s]) {
          if (s === a) return 0;
          s -= 1;
        } else if (c2[0][s] < c2[1][s]) return -1;
      }
    }, e9.map = function(e10, t4) {
      var n3, r4 = [];
      if (Array.prototype.map) return Array.prototype.map.call(e10, t4);
      for (n3 = 0; n3 < e10.length; n3 += 1) r4.push(t4(e10[n3]));
      return r4;
    }, e9.find = function(e10, t4) {
      var n3, r4;
      if (Array.prototype.find) return Array.prototype.find.call(e10, t4);
      for (n3 = 0, r4 = e10.length; n3 < r4; n3 += 1) {
        var i3 = e10[n3];
        if (t4(i3, n3)) return i3;
      }
    }, e9.assign = function(e10) {
      for (var t4, n3, r4 = e10, i3 = arguments.length, o = new Array(i3 > 1 ? i3 - 1 : 0), s = 1; s < i3; s++) o[s - 1] = arguments[s];
      if (Object.assign) return Object.assign.apply(Object, [e10].concat(o));
      var a = function() {
        var e11 = o[t4];
        "object" == typeof e11 && null !== e11 && Object.keys(e11).forEach(function(t5) {
          r4[t5] = e11[t5];
        });
      };
      for (t4 = 0, n3 = o.length; t4 < n3; t4 += 1) a();
      return e10;
    }, e9.getBrowserAlias = function(e10) {
      return r3.BROWSER_ALIASES_MAP[e10];
    }, e9.getBrowserTypeByAlias = function(e10) {
      return r3.BROWSER_MAP[e10] || "";
    }, e9;
  }();
  t3.default = i2, e8.exports = t3.default;
}, 18: function(e8, t3, n2) {
  t3.__esModule = true, t3.ENGINE_MAP = t3.OS_MAP = t3.PLATFORMS_MAP = t3.BROWSER_MAP = t3.BROWSER_ALIASES_MAP = void 0, t3.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" }, t3.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" }, t3.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" }, t3.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" }, t3.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
}, 90: function(e8, t3, n2) {
  t3.__esModule = true, t3.default = void 0;
  var r3, i2 = (r3 = n2(91)) && r3.__esModule ? r3 : { default: r3 }, o = n2(18);
  function s(e9, t4) {
    for (var n3 = 0; n3 < t4.length; n3++) {
      var r4 = t4[n3];
      r4.enumerable = r4.enumerable || false, r4.configurable = true, "value" in r4 && (r4.writable = true), Object.defineProperty(e9, r4.key, r4);
    }
  }
  var a = function() {
    function e9() {
    }
    var t4, n3, r4;
    return e9.getParser = function(e10, t5) {
      if (void 0 === t5 && (t5 = false), "string" != typeof e10) throw new Error("UserAgent should be a string");
      return new i2.default(e10, t5);
    }, e9.parse = function(e10) {
      return new i2.default(e10).getResult();
    }, t4 = e9, r4 = [{ key: "BROWSER_MAP", get: function() {
      return o.BROWSER_MAP;
    } }, { key: "ENGINE_MAP", get: function() {
      return o.ENGINE_MAP;
    } }, { key: "OS_MAP", get: function() {
      return o.OS_MAP;
    } }, { key: "PLATFORMS_MAP", get: function() {
      return o.PLATFORMS_MAP;
    } }], (n3 = null) && s(t4.prototype, n3), r4 && s(t4, r4), e9;
  }();
  t3.default = a, e8.exports = t3.default;
}, 91: function(e8, t3, n2) {
  t3.__esModule = true, t3.default = void 0;
  var r3 = c2(n2(92)), i2 = c2(n2(93)), o = c2(n2(94)), s = c2(n2(95)), a = c2(n2(17));
  function c2(e9) {
    return e9 && e9.__esModule ? e9 : { default: e9 };
  }
  var l3 = function() {
    function e9(e10, t5) {
      if (void 0 === t5 && (t5 = false), null == e10 || "" === e10) throw new Error("UserAgent parameter can't be empty");
      this._ua = e10, this.parsedResult = {}, true !== t5 && this.parse();
    }
    var t4 = e9.prototype;
    return t4.getUA = function() {
      return this._ua;
    }, t4.test = function(e10) {
      return e10.test(this._ua);
    }, t4.parseBrowser = function() {
      var e10 = this;
      this.parsedResult.browser = {};
      var t5 = a.default.find(r3.default, function(t6) {
        if ("function" == typeof t6.test) return t6.test(e10);
        if (t6.test instanceof Array) return t6.test.some(function(t7) {
          return e10.test(t7);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t5 && (this.parsedResult.browser = t5.describe(this.getUA())), this.parsedResult.browser;
    }, t4.getBrowser = function() {
      return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
    }, t4.getBrowserName = function(e10) {
      return e10 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
    }, t4.getBrowserVersion = function() {
      return this.getBrowser().version;
    }, t4.getOS = function() {
      return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
    }, t4.parseOS = function() {
      var e10 = this;
      this.parsedResult.os = {};
      var t5 = a.default.find(i2.default, function(t6) {
        if ("function" == typeof t6.test) return t6.test(e10);
        if (t6.test instanceof Array) return t6.test.some(function(t7) {
          return e10.test(t7);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t5 && (this.parsedResult.os = t5.describe(this.getUA())), this.parsedResult.os;
    }, t4.getOSName = function(e10) {
      var t5 = this.getOS().name;
      return e10 ? String(t5).toLowerCase() || "" : t5 || "";
    }, t4.getOSVersion = function() {
      return this.getOS().version;
    }, t4.getPlatform = function() {
      return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
    }, t4.getPlatformType = function(e10) {
      void 0 === e10 && (e10 = false);
      var t5 = this.getPlatform().type;
      return e10 ? String(t5).toLowerCase() || "" : t5 || "";
    }, t4.parsePlatform = function() {
      var e10 = this;
      this.parsedResult.platform = {};
      var t5 = a.default.find(o.default, function(t6) {
        if ("function" == typeof t6.test) return t6.test(e10);
        if (t6.test instanceof Array) return t6.test.some(function(t7) {
          return e10.test(t7);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t5 && (this.parsedResult.platform = t5.describe(this.getUA())), this.parsedResult.platform;
    }, t4.getEngine = function() {
      return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
    }, t4.getEngineName = function(e10) {
      return e10 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
    }, t4.parseEngine = function() {
      var e10 = this;
      this.parsedResult.engine = {};
      var t5 = a.default.find(s.default, function(t6) {
        if ("function" == typeof t6.test) return t6.test(e10);
        if (t6.test instanceof Array) return t6.test.some(function(t7) {
          return e10.test(t7);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t5 && (this.parsedResult.engine = t5.describe(this.getUA())), this.parsedResult.engine;
    }, t4.parse = function() {
      return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
    }, t4.getResult = function() {
      return a.default.assign({}, this.parsedResult);
    }, t4.satisfies = function(e10) {
      var t5 = this, n3 = {}, r4 = 0, i3 = {}, o2 = 0;
      if (Object.keys(e10).forEach(function(t6) {
        var s3 = e10[t6];
        "string" == typeof s3 ? (i3[t6] = s3, o2 += 1) : "object" == typeof s3 && (n3[t6] = s3, r4 += 1);
      }), r4 > 0) {
        var s2 = Object.keys(n3), c3 = a.default.find(s2, function(e11) {
          return t5.isOS(e11);
        });
        if (c3) {
          var l4 = this.satisfies(n3[c3]);
          if (void 0 !== l4) return l4;
        }
        var d3 = a.default.find(s2, function(e11) {
          return t5.isPlatform(e11);
        });
        if (d3) {
          var u2 = this.satisfies(n3[d3]);
          if (void 0 !== u2) return u2;
        }
      }
      if (o2 > 0) {
        var h3 = Object.keys(i3), f2 = a.default.find(h3, function(e11) {
          return t5.isBrowser(e11, true);
        });
        if (void 0 !== f2) return this.compareVersion(i3[f2]);
      }
    }, t4.isBrowser = function(e10, t5) {
      void 0 === t5 && (t5 = false);
      var n3 = this.getBrowserName().toLowerCase(), r4 = e10.toLowerCase(), i3 = a.default.getBrowserTypeByAlias(r4);
      return t5 && i3 && (r4 = i3.toLowerCase()), r4 === n3;
    }, t4.compareVersion = function(e10) {
      var t5 = [0], n3 = e10, r4 = false, i3 = this.getBrowserVersion();
      if ("string" == typeof i3) return ">" === e10[0] || "<" === e10[0] ? (n3 = e10.substr(1), "=" === e10[1] ? (r4 = true, n3 = e10.substr(2)) : t5 = [], ">" === e10[0] ? t5.push(1) : t5.push(-1)) : "=" === e10[0] ? n3 = e10.substr(1) : "~" === e10[0] && (r4 = true, n3 = e10.substr(1)), t5.indexOf(a.default.compareVersions(i3, n3, r4)) > -1;
    }, t4.isOS = function(e10) {
      return this.getOSName(true) === String(e10).toLowerCase();
    }, t4.isPlatform = function(e10) {
      return this.getPlatformType(true) === String(e10).toLowerCase();
    }, t4.isEngine = function(e10) {
      return this.getEngineName(true) === String(e10).toLowerCase();
    }, t4.is = function(e10, t5) {
      return void 0 === t5 && (t5 = false), this.isBrowser(e10, t5) || this.isOS(e10) || this.isPlatform(e10);
    }, t4.some = function(e10) {
      var t5 = this;
      return void 0 === e10 && (e10 = []), e10.some(function(e11) {
        return t5.is(e11);
      });
    }, e9;
  }();
  t3.default = l3, e8.exports = t3.default;
}, 92: function(e8, t3, n2) {
  t3.__esModule = true, t3.default = void 0;
  var r3, i2 = (r3 = n2(17)) && r3.__esModule ? r3 : { default: r3 }, o = /version\/(\d+(\.?_?\d+)+)/i, s = [{ test: [/googlebot/i], describe: function(e9) {
    var t4 = { name: "Googlebot" }, n3 = i2.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/opera/i], describe: function(e9) {
    var t4 = { name: "Opera" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/opr\/|opios/i], describe: function(e9) {
    var t4 = { name: "Opera" }, n3 = i2.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/SamsungBrowser/i], describe: function(e9) {
    var t4 = { name: "Samsung Internet for Android" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/Whale/i], describe: function(e9) {
    var t4 = { name: "NAVER Whale Browser" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/MZBrowser/i], describe: function(e9) {
    var t4 = { name: "MZ Browser" }, n3 = i2.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/focus/i], describe: function(e9) {
    var t4 = { name: "Focus" }, n3 = i2.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/swing/i], describe: function(e9) {
    var t4 = { name: "Swing" }, n3 = i2.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/coast/i], describe: function(e9) {
    var t4 = { name: "Opera Coast" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e9) {
    var t4 = { name: "Opera Touch" }, n3 = i2.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/yabrowser/i], describe: function(e9) {
    var t4 = { name: "Yandex Browser" }, n3 = i2.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/ucbrowser/i], describe: function(e9) {
    var t4 = { name: "UC Browser" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/Maxthon|mxios/i], describe: function(e9) {
    var t4 = { name: "Maxthon" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/epiphany/i], describe: function(e9) {
    var t4 = { name: "Epiphany" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/puffin/i], describe: function(e9) {
    var t4 = { name: "Puffin" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/sleipnir/i], describe: function(e9) {
    var t4 = { name: "Sleipnir" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/k-meleon/i], describe: function(e9) {
    var t4 = { name: "K-Meleon" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/micromessenger/i], describe: function(e9) {
    var t4 = { name: "WeChat" }, n3 = i2.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/qqbrowser/i], describe: function(e9) {
    var t4 = { name: /qqbrowserlite/i.test(e9) ? "QQ Browser Lite" : "QQ Browser" }, n3 = i2.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/msie|trident/i], describe: function(e9) {
    var t4 = { name: "Internet Explorer" }, n3 = i2.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/\sedg\//i], describe: function(e9) {
    var t4 = { name: "Microsoft Edge" }, n3 = i2.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/edg([ea]|ios)/i], describe: function(e9) {
    var t4 = { name: "Microsoft Edge" }, n3 = i2.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/vivaldi/i], describe: function(e9) {
    var t4 = { name: "Vivaldi" }, n3 = i2.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/seamonkey/i], describe: function(e9) {
    var t4 = { name: "SeaMonkey" }, n3 = i2.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/sailfish/i], describe: function(e9) {
    var t4 = { name: "Sailfish" }, n3 = i2.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/silk/i], describe: function(e9) {
    var t4 = { name: "Amazon Silk" }, n3 = i2.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/phantom/i], describe: function(e9) {
    var t4 = { name: "PhantomJS" }, n3 = i2.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/slimerjs/i], describe: function(e9) {
    var t4 = { name: "SlimerJS" }, n3 = i2.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e9) {
    var t4 = { name: "BlackBerry" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(e9) {
    var t4 = { name: "WebOS Browser" }, n3 = i2.default.getFirstMatch(o, e9) || i2.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/bada/i], describe: function(e9) {
    var t4 = { name: "Bada" }, n3 = i2.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/tizen/i], describe: function(e9) {
    var t4 = { name: "Tizen" }, n3 = i2.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/qupzilla/i], describe: function(e9) {
    var t4 = { name: "QupZilla" }, n3 = i2.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e9) {
    var t4 = { name: "Firefox" }, n3 = i2.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/electron/i], describe: function(e9) {
    var t4 = { name: "Electron" }, n3 = i2.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/MiuiBrowser/i], describe: function(e9) {
    var t4 = { name: "Miui" }, n3 = i2.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/chromium/i], describe: function(e9) {
    var t4 = { name: "Chromium" }, n3 = i2.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e9) || i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/chrome|crios|crmo/i], describe: function(e9) {
    var t4 = { name: "Chrome" }, n3 = i2.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/GSA/i], describe: function(e9) {
    var t4 = { name: "Google Search" }, n3 = i2.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: function(e9) {
    var t4 = !e9.test(/like android/i), n3 = e9.test(/android/i);
    return t4 && n3;
  }, describe: function(e9) {
    var t4 = { name: "Android Browser" }, n3 = i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/playstation 4/i], describe: function(e9) {
    var t4 = { name: "PlayStation 4" }, n3 = i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/safari|applewebkit/i], describe: function(e9) {
    var t4 = { name: "Safari" }, n3 = i2.default.getFirstMatch(o, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/.*/i], describe: function(e9) {
    var t4 = -1 !== e9.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
    return { name: i2.default.getFirstMatch(t4, e9), version: i2.default.getSecondMatch(t4, e9) };
  } }];
  t3.default = s, e8.exports = t3.default;
}, 93: function(e8, t3, n2) {
  t3.__esModule = true, t3.default = void 0;
  var r3, i2 = (r3 = n2(17)) && r3.__esModule ? r3 : { default: r3 }, o = n2(18), s = [{ test: [/Roku\/DVP/], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e9);
    return { name: o.OS_MAP.Roku, version: t4 };
  } }, { test: [/windows phone/i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e9);
    return { name: o.OS_MAP.WindowsPhone, version: t4 };
  } }, { test: [/windows /i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e9), n3 = i2.default.getWindowsVersionName(t4);
    return { name: o.OS_MAP.Windows, version: t4, versionName: n3 };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e9) {
    var t4 = { name: o.OS_MAP.iOS }, n3 = i2.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/macintosh/i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e9).replace(/[_\s]/g, "."), n3 = i2.default.getMacOSVersionName(t4), r4 = { name: o.OS_MAP.MacOS, version: t4 };
    return n3 && (r4.versionName = n3), r4;
  } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e9).replace(/[_\s]/g, ".");
    return { name: o.OS_MAP.iOS, version: t4 };
  } }, { test: function(e9) {
    var t4 = !e9.test(/like android/i), n3 = e9.test(/android/i);
    return t4 && n3;
  }, describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e9), n3 = i2.default.getAndroidVersionName(t4), r4 = { name: o.OS_MAP.Android, version: t4 };
    return n3 && (r4.versionName = n3), r4;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e9), n3 = { name: o.OS_MAP.WebOS };
    return t4 && t4.length && (n3.version = t4), n3;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e9) || i2.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e9) || i2.default.getFirstMatch(/\bbb(\d+)/i, e9);
    return { name: o.OS_MAP.BlackBerry, version: t4 };
  } }, { test: [/bada/i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e9);
    return { name: o.OS_MAP.Bada, version: t4 };
  } }, { test: [/tizen/i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e9);
    return { name: o.OS_MAP.Tizen, version: t4 };
  } }, { test: [/linux/i], describe: function() {
    return { name: o.OS_MAP.Linux };
  } }, { test: [/CrOS/], describe: function() {
    return { name: o.OS_MAP.ChromeOS };
  } }, { test: [/PlayStation 4/], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e9);
    return { name: o.OS_MAP.PlayStation4, version: t4 };
  } }];
  t3.default = s, e8.exports = t3.default;
}, 94: function(e8, t3, n2) {
  t3.__esModule = true, t3.default = void 0;
  var r3, i2 = (r3 = n2(17)) && r3.__esModule ? r3 : { default: r3 }, o = n2(18), s = [{ test: [/googlebot/i], describe: function() {
    return { type: "bot", vendor: "Google" };
  } }, { test: [/huawei/i], describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/(can-l01)/i, e9) && "Nova", n3 = { type: o.PLATFORMS_MAP.mobile, vendor: "Huawei" };
    return t4 && (n3.model = t4), n3;
  } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
    return { type: o.PLATFORMS_MAP.tablet, vendor: "Nexus" };
  } }, { test: [/ipad/i], describe: function() {
    return { type: o.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
    return { type: o.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/kftt build/i], describe: function() {
    return { type: o.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
  } }, { test: [/silk/i], describe: function() {
    return { type: o.PLATFORMS_MAP.tablet, vendor: "Amazon" };
  } }, { test: [/tablet(?! pc)/i], describe: function() {
    return { type: o.PLATFORMS_MAP.tablet };
  } }, { test: function(e9) {
    var t4 = e9.test(/ipod|iphone/i), n3 = e9.test(/like (ipod|iphone)/i);
    return t4 && !n3;
  }, describe: function(e9) {
    var t4 = i2.default.getFirstMatch(/(ipod|iphone)/i, e9);
    return { type: o.PLATFORMS_MAP.mobile, vendor: "Apple", model: t4 };
  } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
    return { type: o.PLATFORMS_MAP.mobile, vendor: "Nexus" };
  } }, { test: [/[^-]mobi/i], describe: function() {
    return { type: o.PLATFORMS_MAP.mobile };
  } }, { test: function(e9) {
    return "blackberry" === e9.getBrowserName(true);
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
  } }, { test: function(e9) {
    return "bada" === e9.getBrowserName(true);
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.mobile };
  } }, { test: function(e9) {
    return "windows phone" === e9.getBrowserName();
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
  } }, { test: function(e9) {
    var t4 = Number(String(e9.getOSVersion()).split(".")[0]);
    return "android" === e9.getOSName(true) && t4 >= 3;
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.tablet };
  } }, { test: function(e9) {
    return "android" === e9.getOSName(true);
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.mobile };
  } }, { test: function(e9) {
    return "macos" === e9.getOSName(true);
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.desktop, vendor: "Apple" };
  } }, { test: function(e9) {
    return "windows" === e9.getOSName(true);
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.desktop };
  } }, { test: function(e9) {
    return "linux" === e9.getOSName(true);
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.desktop };
  } }, { test: function(e9) {
    return "playstation 4" === e9.getOSName(true);
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.tv };
  } }, { test: function(e9) {
    return "roku" === e9.getOSName(true);
  }, describe: function() {
    return { type: o.PLATFORMS_MAP.tv };
  } }];
  t3.default = s, e8.exports = t3.default;
}, 95: function(e8, t3, n2) {
  t3.__esModule = true, t3.default = void 0;
  var r3, i2 = (r3 = n2(17)) && r3.__esModule ? r3 : { default: r3 }, o = n2(18), s = [{ test: function(e9) {
    return "microsoft edge" === e9.getBrowserName(true);
  }, describe: function(e9) {
    if (/\sedg\//i.test(e9)) return { name: o.ENGINE_MAP.Blink };
    var t4 = i2.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e9);
    return { name: o.ENGINE_MAP.EdgeHTML, version: t4 };
  } }, { test: [/trident/i], describe: function(e9) {
    var t4 = { name: o.ENGINE_MAP.Trident }, n3 = i2.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: function(e9) {
    return e9.test(/presto/i);
  }, describe: function(e9) {
    var t4 = { name: o.ENGINE_MAP.Presto }, n3 = i2.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: function(e9) {
    var t4 = e9.test(/gecko/i), n3 = e9.test(/like gecko/i);
    return t4 && !n3;
  }, describe: function(e9) {
    var t4 = { name: o.ENGINE_MAP.Gecko }, n3 = i2.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
    return { name: o.ENGINE_MAP.Blink };
  } }, { test: [/(apple)?webkit/i], describe: function(e9) {
    var t4 = { name: o.ENGINE_MAP.WebKit }, n3 = i2.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e9);
    return n3 && (t4.version = n3), t4;
  } }];
  t3.default = s, e8.exports = t3.default;
} });
var Wu = ue(qu.exports);
var Vu = { Initialized: "initialized", DisplayURI: "display_uri", ProviderUpdate: "provider_update", ConnectWithResponse: "connectWithResponse", ConnectionStatus: "connection_status", ServiceStatus: "service_status" };
var Gu = class _Gu {
  constructor({ shouldSetOnWindow: e8, connectionStream: t3, shouldSendMetadata: n2 = false, shouldShimWeb3: r3, sdkInstance: i2 }) {
    const o = new Ju({ connectionStream: t3, shouldSendMetadata: n2, shouldSetOnWindow: e8, shouldShimWeb3: r3, autoRequestAccounts: false }), s = new Proxy(o, { deleteProperty: () => true });
    if (this.provider = s, this.sdkInstance = i2, e8 && "undefined" != typeof window) try {
      a = o, window.ethereum = a, window.dispatchEvent(new Event("ethereum#initialized"));
    } catch (e9) {
      Iu("[Ethereum] Unable to set global provider - window.ethereum may be read-only", e9);
    }
    var a;
    if (r3 && "undefined" != typeof window) try {
      !function(e9, t4 = console) {
        let n3 = false, r4 = false;
        if (!window.web3) {
          const i3 = "__isMetaMaskShim__";
          let o2 = { currentProvider: e9 };
          Object.defineProperty(o2, i3, { value: true, enumerable: true, configurable: false, writable: false }), o2 = new Proxy(o2, { get: (o3, s2, ...a2) => ("currentProvider" !== s2 || n3 ? "currentProvider" === s2 || s2 === i3 || r4 || (r4 = true, t4.error("MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), e9.request({ method: "metamask_logWeb3ShimUsage" }).catch((e10) => {
            t4.debug("MetaMask: Failed to log web3 shim usage.", e10);
          })) : (n3 = true, t4.warn("You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3")), Reflect.get(o3, s2, ...a2)), set: (...e10) => (t4.warn("You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), Reflect.set(...e10)) }), Object.defineProperty(window, "web3", { value: o2, enumerable: false, configurable: true, writable: true });
        }
      }(this.provider);
    } catch (e9) {
      Iu("[Ethereum] Unable to shim web3 - window.web3 may be read-only", e9);
    }
    this.provider.on("display_uri", (e9) => {
      this.sdkInstance.emit(Vu.DisplayURI, e9);
    }), this.provider.on("_initialized", () => {
      const e9 = { chainId: this.provider.getChainId(), isConnected: this.provider.isConnected(), isMetaMask: this.provider.isMetaMask, selectedAddress: this.provider.getSelectedAddress(), networkVersion: this.provider.getNetworkVersion() };
      this.sdkInstance.emit(Vu.Initialized, e9), Iu("[Ethereum: constructor()] provider initialized", e9);
    });
  }
  static init(e8) {
    var t3;
    return Iu("[Ethereum: init()] Initializing Ethereum service"), this.instance = new _Gu(e8), null === (t3 = this.instance) || void 0 === t3 ? void 0 : t3.provider;
  }
  static destroy() {
  }
  static getInstance() {
    var e8;
    if (!(null === (e8 = this.instance) || void 0 === e8 ? void 0 : e8.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance;
  }
  static getProvider() {
    var e8;
    if (!(null === (e8 = this.instance) || void 0 === e8 ? void 0 : e8.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance.provider;
  }
};
var Yu = class _Yu {
  constructor({ useDeepLink: e8, preferredOpenLink: t3, debug: n2 = false }) {
    this.state = { platformType: void 0, useDeeplink: false, preferredOpenLink: void 0, debug: false }, this.state.platformType = this.getPlatformType(), this.state.useDeeplink = e8, this.state.preferredOpenLink = t3, this.state.debug = n2;
  }
  openDeeplink(e8, t3, n2) {
    return function(e9, t4, n3, r3) {
      const { state: i2 } = e9;
      Iu(`[PlatfformManager: openDeeplink()] universalLink --> ${t4}`), Iu(`[PlatfformManager: openDeeplink()] deepLink --> ${n3}`);
      try {
        if (i2.preferredOpenLink) return void i2.preferredOpenLink(i2.useDeeplink ? n3 : t4, r3);
        if (Iu(`[PlatfformManager: openDeeplink()] open link now useDeepLink=${i2.useDeeplink} link=${i2.useDeeplink ? n3 : t4}`), i2.useDeeplink) "undefined" != typeof window && (window.location.href = n3);
        else if ("undefined" != typeof document) {
          const e10 = document.createElement("a");
          e10.href = t4, e10.target = "_self", e10.rel = "noreferrer noopener", e10.click();
        }
      } catch (e10) {
        console.log("[PlatfformManager: openDeeplink()] can't open link", e10);
      }
    }(this, e8, t3, n2);
  }
  isReactNative() {
    var e8;
    return this.isNotBrowser() && "undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.navigator) && "ReactNative" === (null === (e8 = window.navigator) || void 0 === e8 ? void 0 : e8.product);
  }
  isMetaMaskInstalled() {
    return function() {
      const e8 = Gu.getProvider() || (null === window || void 0 === window ? void 0 : window.ethereum);
      return Iu(`[PlatfformManager: isMetaMaskInstalled()] isMetaMask=${null == e8 ? void 0 : e8.isMetaMask} isConnected=${null == e8 ? void 0 : e8.isConnected()}`), (null == e8 ? void 0 : e8.isMetaMask) && (null == e8 ? void 0 : e8.isConnected());
    }();
  }
  isDesktopWeb() {
    return this.isBrowser() && !this.isMobileWeb();
  }
  isMobile() {
    var e8, t3;
    const n2 = Wu.parse(window.navigator.userAgent);
    return "mobile" === (null === (e8 = null == n2 ? void 0 : n2.platform) || void 0 === e8 ? void 0 : e8.type) || "tablet" === (null === (t3 = null == n2 ? void 0 : n2.platform) || void 0 === t3 ? void 0 : t3.type);
  }
  isSecure() {
    return this.isReactNative() || this.isMobileWeb();
  }
  isMetaMaskMobileWebView() {
    return "undefined" != typeof window && (Boolean(window.ReactNativeWebView) && Boolean(navigator.userAgent.endsWith("MetaMaskMobile")));
  }
  isMobileWeb() {
    return this.state.platformType === Uo.MobileWeb;
  }
  static isNotBrowser() {
    var e8;
    return "undefined" == typeof window || !(null === window || void 0 === window ? void 0 : window.navigator) || void 0 !== l && "ReactNative" === (null === (e8 = null == l ? void 0 : l.navigator) || void 0 === e8 ? void 0 : e8.product) || "ReactNative" === (null === navigator || void 0 === navigator ? void 0 : navigator.product);
  }
  isNotBrowser() {
    return _Yu.isNotBrowser();
  }
  static isBrowser() {
    return !this.isNotBrowser();
  }
  isBrowser() {
    return _Yu.isBrowser();
  }
  isNodeJS() {
    return this.isNotBrowser() && !this.isReactNative();
  }
  isUseDeepLink() {
    return this.state.useDeeplink;
  }
  getPlatformType() {
    return function(e8) {
      const { state: t3 } = e8;
      return t3.platformType ? t3.platformType : e8.isReactNative() ? Uo.ReactNative : e8.isNotBrowser() ? Uo.NonBrowser : e8.isMetaMaskMobileWebView() ? Uo.MetaMaskMobileWebview : e8.isMobile() ? Uo.MobileWeb : Uo.DesktopWeb;
    }(this);
  }
};
var Zu = (e8) => c(void 0, void 0, void 0, function* () {
  if (Yu.isBrowser()) {
    const { StorageManagerWeb: t4 } = yield Promise.resolve().then(function() {
      return cf;
    });
    return new t4(e8);
  }
  const t3 = { persistChannelConfig: () => c(void 0, void 0, void 0, function* () {
  }), getPersistedChannelConfig: () => c(void 0, void 0, void 0, function* () {
  }), persistAccounts: () => c(void 0, void 0, void 0, function* () {
  }), getCachedAccounts: () => c(void 0, void 0, void 0, function* () {
    return [];
  }), persistChainId: () => c(void 0, void 0, void 0, function* () {
  }), getCachedChainId: () => c(void 0, void 0, void 0, function* () {
  }), terminate: () => c(void 0, void 0, void 0, function* () {
  }) };
  return Promise.resolve(t3);
});
var Ju = class extends Mu {
  constructor({ connectionStream: e8, shouldSendMetadata: t3, autoRequestAccounts: n2 = false }) {
    super(e8, { logger: console, maxEventListeners: 100, shouldSendMetadata: t3 }), this.state = { accounts: null, autoRequestAccounts: false, providerStateRequested: false, chainId: "", networkVersion: "" }, Iu(`[SDKProvider: constructor()] autoRequestAccounts=${n2}`), this.state.autoRequestAccounts = n2;
  }
  forceInitializeState() {
    return c(this, void 0, void 0, function* () {
      return Iu(`[SDKProvider: forceInitializeState()] autoRequestAccounts=${this.state.autoRequestAccounts}`), this._initializeStateAsync();
    });
  }
  _setConnected() {
    Iu("[SDKProvider: _setConnected()] Setting connected state"), this._state.isConnected = true;
  }
  getState() {
    return this._state;
  }
  getSDKProviderState() {
    return this.state;
  }
  getSelectedAddress() {
    var e8;
    const { accounts: t3 } = this._state;
    return t3 && 0 !== t3.length ? (null === (e8 = t3[0]) || void 0 === e8 ? void 0 : e8.toLowerCase()) || "" : (Iu("[SDKProvider: getSelectedAddress] No accounts found"), null);
  }
  getChainId() {
    return this.state.chainId;
  }
  getNetworkVersion() {
    return this.state.networkVersion;
  }
  setSDKProviderState(e8) {
    this.state = Object.assign(Object.assign({}, this.state), e8);
  }
  handleAccountsChanged(e8, t3) {
    return this._handleAccountsChanged(e8, t3);
  }
  handleDisconnect({ terminate: e8 = false }) {
    !function({ terminate: e9 = false, instance: t3 }) {
      const { state: n2 } = t3;
      Iu(`[SDKProvider: handleDisconnect()] cleaning up provider state terminate=${e9}`, t3), e9 && (t3._state.accounts = null, t3._state.isUnlocked = false, t3._state.isPermanentlyDisconnected = true, t3._state.initialized = false), t3._handleAccountsChanged([]), t3._state.isConnected = false, t3.emit("disconnect", Ru.ethErrors.provider.disconnected()), n2.providerStateRequested = false;
    }({ terminate: e8, instance: this });
  }
  _initializeStateAsync() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        var t3, n2;
        return c(this, void 0, void 0, function* () {
          void 0 === e8.state && (e8.state = { accounts: null, autoRequestAccounts: false, providerStateRequested: false, chainId: "" });
          const { state: r3 } = e8;
          let i2;
          if (r3.providerStateRequested) Iu("[SDKProvider: initializeStateAsync()] initialization already in progress");
          else {
            let o;
            r3.providerStateRequested = true;
            let s = null, a = false, c2 = false;
            const l3 = yield Zu({ enabled: true });
            if (l3) {
              const e9 = yield l3.getPersistedChannelConfig({});
              a = null !== (t3 = null == e9 ? void 0 : e9.relayPersistence) && void 0 !== t3 && t3, o = yield l3.getCachedChainId();
              const n3 = yield l3.getCachedAccounts();
              n3.length > 0 && (s = n3[0]);
            }
            if (Iu(`[SDKProvider: initializeStateAsync()] relayPersistence=${a}`, { relayPersistence: a, cachedChainId: o, cachedSelectedAddress: s }), a) if (o && s) i2 = { accounts: [s], chainId: o, isUnlocked: false }, c2 = true;
            else try {
              i2 = yield e8.request({ method: "metamask_getProviderState" });
            } catch (t4) {
              return e8._log.error("MetaMask: Failed to get initial state. Please report this bug.", t4), void (r3.providerStateRequested = false);
            }
            if (0 === (null === (n2 = null == i2 ? void 0 : i2.accounts) || void 0 === n2 ? void 0 : n2.length)) if (e8.getSelectedAddress()) i2.accounts = [e8.getSelectedAddress()];
            else {
              Iu("[SDKProvider: initializeStateAsync()] Fetch accounts remotely.");
              const t4 = yield e8.request({ method: "eth_requestAccounts", params: [] });
              i2.accounts = t4;
            }
            e8._initializeState(i2), r3.providerStateRequested = false, c2 && (e8._state.isConnected = true, e8.emit("connect", { chainId: null == i2 ? void 0 : i2.chainId }));
          }
        });
      }(this);
    });
  }
  _initializeState(e8) {
    return Iu("[SDKProvider: _initializeState()]", e8), function(e9, t3, n2) {
      return Iu("[SDKProvider: initializeState()] set state._initialized to false"), e9._state.initialized = false, t3(n2);
    }(this, super._initializeState.bind(this), e8);
  }
  _handleChainChanged({ chainId: e8, networkVersion: t3 } = {}) {
    this.state.chainId = e8, this.state.networkVersion = t3, function({ instance: e9, chainId: t4, networkVersion: r3, superHandleChainChanged: i2 }) {
      Iu(`[SDKProvider: handleChainChanged()] chainId=${t4} networkVersion=${r3}`);
      let o = r3;
      r3 || (Iu("[SDKProvider: handleChainChanged()] forced network version to prevent provider error"), o = "1"), t4 !== Tu && (import_sdk_analytics.analytics.track("sdk_used_chain", { caip_chain_id: `eip155:${parseInt(null != t4 ? t4 : "0x1", 16)}` }), Tu = t4), e9._state.isConnected = true, e9.emit("connect", { chainId: t4 }), i2({ chainId: t4, networkVersion: o });
    }({ instance: this, chainId: e8, networkVersion: t3, superHandleChainChanged: super._handleChainChanged.bind(this) });
  }
};
var Qu;
var Xu = { name: "@metamask/sdk", version: "0.33.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk", directory: "packages/sdk" }, main: "dist/node/cjs/metamask-sdk.js", module: "dist/browser/es/metamask-sdk.js", browser: "dist/browser/es/metamask-sdk.js", unpkg: "dist/browser/umd/metamask-sdk.js", "react-native": "dist/react-native/es/metamask-sdk.js", types: "dist/types/src/index.d.ts", sideEffects: false, files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:clean": "yarn clean && yarn build", "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", typecheck: "tsc --noEmit", clean: "rimraf ./dist", size: "node bundle-size && size-limit", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", prepack: "../../scripts/prepack.sh", "publish:preview": "yarn npm publish --tag preview", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:coverage": 'jest --coverage --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": 'jest -c ./jest.config.ts --detectOpenHandles  --testPathIgnorePatterns "/e2e/"', watch: "rollup -c -w", dev: 'concurrently "tsc --watch" "rollup -c -w --bundleConfigAsCjs"', "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs" }, dependencies: { "@babel/runtime": "^7.26.0", "@metamask/onboarding": "^1.0.1", "@metamask/providers": "16.1.0", "@metamask/sdk-analytics": "workspace:*", "@metamask/sdk-communication-layer": "workspace:*", "@metamask/sdk-install-modal-web": "workspace:*", "@paulmillr/qr": "^0.2.1", bowser: "^2.9.0", "cross-fetch": "^4.0.0", debug: "^4.3.4", eciesjs: "^0.4.11", "eth-rpc-errors": "^4.0.3", eventemitter2: "^6.4.9", "obj-multiplex": "^1.0.0", pump: "^3.0.0", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1", tslib: "^2.6.0", util: "^0.12.4", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@react-native-async-storage/async-storage": "^1.19.6", "@rollup/plugin-alias": "^5.1.1", "@rollup/plugin-commonjs": "^25.0.7", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.1", "@size-limit/preset-big-lib": "^11.0.2", "@types/dom-screen-wake-lock": "^1.0.2", "@types/node": "^20.1.3", "@types/pump": "^1.1.1", "@types/qrcode-terminal": "^0.12.0", "@types/uuid": "^10.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", "browserify-zlib": "^0.2.0", buffer: "^6.0.3", concurrently: "^9.1.2", "crypto-browserify": "^3.12.0", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", "https-browserify": "^1.0.0", jest: "^29.3.1", "jest-environment-jsdom": "^29.3.1", prettier: "^2.3.0", process: "^0.11.10", rimraf: "^4.4.0", rollup: "^4.26.0", "rollup-plugin-analyzer": "^4.0.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.0.2", "stream-browserify": "^3.0.0", "stream-http": "^3.2.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^4.3.2", url: "^0.11.0", webpack: "^5.0.0" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "eciesjs>secp256k1": false, "socket.io-client>engine.io-client>ws>bufferutil": false, "socket.io-client>engine.io-client>ws>utf-8-validate": false, "@metamask/sdk-communication-layer>bufferutil": false, "@metamask/sdk-communication-layer>eciesjs>secp256k1": false, "@metamask/sdk-communication-layer>utf-8-validate": false } } };
!function(e8) {
  e8.INPAGE = "metamask-inpage", e8.CONTENT_SCRIPT = "metamask-contentscript", e8.PROVIDER = "metamask-provider";
}(Qu || (Qu = {}));
var eh = "direct";
var th = "https://metamask.app.link/connect";
var nh = "metamask://connect";
var rh = { NAME: "MetaMask", RDNS: ["io.metamask", "io.metamask.flask"] };
var ih = /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u;
var oh = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", WALLET_SWITCHETHETHEREUMCHAIN: "wallet_switchEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" };
var sh = { [oh.ETH_REQUESTACCOUNTS]: true, [oh.ETH_SENDTRANSACTION]: true, [oh.ETH_SIGNTRANSACTION]: true, [oh.ETH_SIGN]: true, [oh.PERSONAL_SIGN]: true, [oh.ETH_ACCOUNTS]: false, [oh.ETH_CHAINID]: false, [oh.PERSONAL_SIGN]: true, [oh.ETH_SIGNTYPEDDATA]: true, [oh.ETH_SIGNTYPEDDATA_V3]: true, [oh.ETH_SIGNTYPEDDATA_V4]: true, [oh.WALLET_REQUESTPERMISSIONS]: true, [oh.WALLET_GETPERMISSIONS]: true, [oh.WALLET_WATCHASSET]: true, [oh.WALLET_ADDETHEREUMCHAIN]: true, [oh.WALLET_SWITCHETHETHEREUMCHAIN]: true, [oh.METAMASK_CONNECTSIGN]: true, [oh.METAMASK_CONNECTWITH]: true, [oh.PERSONAL_EC_RECOVER]: true, [oh.METAMASK_BATCH]: true, [oh.METAMASK_OPEN]: true };
var ah = Object.keys(sh).filter((e8) => true === sh[e8]).map((e8) => e8.toLowerCase());
var ch = ["eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sign"].map((e8) => e8.toLowerCase());
var lh = ".sdk-comm";
var dh = "providerType";
var uh = ".MMSDK_cached_address";
var hh = ".MMSDK_cached_chainId";
var fh = { CHAIN_CHANGED: "chainChanged", ACCOUNTS_CHANGED: "accountsChanged", DISCONNECT: "disconnect", CONNECT: "connect", CONNECTED: "connected" };
var ph = 1e6;
var gh;
!function(e8) {
  e8.TERMINATE = "terminate", e8.EXTENSION = "extension", e8.INITIALIZED = "initialized";
}(gh || (gh = {}));
var mh = "undefined" != typeof window && window.localStorage;
function yh({ instance: e8, msg: t3 }) {
  return c(this, void 0, void 0, function* () {
    if (e8._initialized || (Iu("[MetaMaskSDK: connectAndSign()] provider not ready -- wait for init()"), yield e8.init()), Iu(`[MetaMaskSDK: connectAndSign()] activeProvider=${e8.activeProvider}`), !e8.activeProvider) throw new Error("SDK state invalid -- undefined provider");
    const n2 = /^0x([0-9A-Fa-f]{2})*$/u.test(t3) ? t3 : function(e9) {
      let t4;
      if (void 0 !== C) t4 = C.from(e9, "utf8").toString("hex");
      else if ("undefined" != typeof TextEncoder) {
        const n3 = new TextEncoder().encode(e9);
        t4 = Array.from(n3).map((e10) => e10.toString(16).padStart(2, "0")).join("");
      } else {
        if ("object" != typeof l || !("Buffer" in l)) throw new Error("Unable to convert string to hex: No available method.");
        t4 = l.Buffer.from(e9, "utf8").toString("hex");
      }
      return `0x${t4}`;
    }(t3);
    return e8.activeProvider.request({ method: oh.METAMASK_CONNECTWITH, params: [{ method: oh.PERSONAL_SIGN, params: [n2] }] });
  });
}
function vh(e8) {
  var t3, n2;
  return c(this, void 0, void 0, function* () {
    Iu("[MetaMaskSDK: connectWithExtensionProvider()] ", e8), e8.sdkProvider = e8.activeProvider, e8.activeProvider = window.extension, window.ethereum = window.extension;
    try {
      const e9 = yield null === (t3 = window.extension) || void 0 === t3 ? void 0 : t3.request({ method: "eth_requestAccounts" });
      Iu(`[MetaMaskSDK: connectWithExtensionProvider()] accounts=${e9}`);
    } catch (e9) {
      return void console.warn("[MetaMaskSDK: connectWithExtensionProvider()] can't request accounts error", e9);
    }
    localStorage.setItem(dh, "extension"), e8.extensionActive = true, e8.emit(Vu.ProviderUpdate, gh.EXTENSION), e8.options.enableAnalytics && (null === (n2 = e8.analytics) || void 0 === n2 || n2.send({ event: Ao.SDK_USE_EXTENSION }));
  });
}
function bh(e8) {
  let t3;
  if (void 0 !== C) t3 = C.from(e8, "utf8").toString("base64");
  else if ("function" == typeof btoa) t3 = btoa(encodeURIComponent(e8).replace(/%([0-9A-F]{2})/gu, (e9, t4) => String.fromCharCode(parseInt(t4, 16))));
  else {
    if ("object" != typeof l || !("Buffer" in l)) throw new Error("Unable to base64 encode: No available method.");
    t3 = l.Buffer.from(e8, "utf8").toString("base64");
  }
  return t3;
}
function wh(e8, t3, n2, r3) {
  var i2, o, s, a, l3, d3, u2, h3, f2, p3, g3, m2, y3, v2, b3, w2, E2, S3, _3, k3;
  return c(this, void 0, void 0, function* () {
    const n3 = null === (i2 = e8.state.remote) || void 0 === i2 ? void 0 : i2.isReady(), c2 = null === (o = e8.state.remote) || void 0 === o ? void 0 : o.isConnected(), A3 = null === (s = e8.state.remote) || void 0 === s ? void 0 : s.isPaused(), x3 = Gu.getProvider(), M3 = null === (a = e8.state.remote) || void 0 === a ? void 0 : a.getChannelId(), I3 = null === (l3 = e8.state.remote) || void 0 === l3 ? void 0 : l3.isAuthorized(), { deeplinkProtocol: T2 } = e8.state, { method: R3, data: P3, triggeredInstaller: O3 } = ((e9) => {
      var t4, n4, r4, i3;
      let o2;
      C.isBuffer(e9) ? (o2 = e9.toJSON(), o2._isBuffer = true) : o2 = e9;
      const s2 = null === (t4 = null == o2 ? void 0 : o2.data) || void 0 === t4 ? void 0 : t4.method;
      let a2 = false;
      return "object" == typeof (null === (n4 = null == o2 ? void 0 : o2.data) || void 0 === n4 ? void 0 : n4.params) && true === (null === (i3 = null === (r4 = null == o2 ? void 0 : o2.data) || void 0 === r4 ? void 0 : r4.params) || void 0 === i3 ? void 0 : i3.__triggeredInstaller) && (a2 = true, o2.data.params = o2.data.params.wrappedParams), { method: s2, data: o2, triggeredInstaller: a2 };
    })(t3);
    if (Iu(`[RCPMS: write()] method='${R3}' isRemoteReady=${n3} channelId=${M3} isSocketConnected=${c2} isRemotePaused=${A3} providerConnected=${x3.isConnected()}`, t3), !M3) return R3 !== oh.METAMASK_GETPROVIDERSTATE && Iu(`[RCPMS: write()] ${R3} --> channelId is undefined`), r3(new Error("disconnected"));
    Iu(`[RCPMS: write()] remote.isPaused()=${null === (d3 = e8.state.remote) || void 0 === d3 ? void 0 : d3.isPaused()} authorized=${I3} ready=${n3} socketConnected=${c2}`, t3);
    const N3 = null === (u2 = e8.state.platformManager) || void 0 === u2 ? void 0 : u2.isSecure(), L3 = null !== (f2 = null === (h3 = e8.state.platformManager) || void 0 === h3 ? void 0 : h3.isMobileWeb()) && void 0 !== f2 && f2, D3 = null !== (g3 = null === (p3 = e8.state.remote) || void 0 === p3 ? void 0 : p3.hasDeeplinkProtocol()) && void 0 !== g3 && g3 && L3 && I3;
    try {
      if (!O3) {
        const t5 = JSON.stringify(null == P3 ? void 0 : P3.data);
        if (t5.length > ph) return r3(new Error(`Message size ${t5.length} exceeds maximum allowed size of 1000000 bytes`));
        null === (m2 = e8.state.remote) || void 0 === m2 || m2.sendMessage(null == P3 ? void 0 : P3.data).then(() => {
          Iu(`[RCPMS: _write()] ${R3} sent successfully`);
        }).catch((e9) => {
          Iu("[RCPMS: _write()] error sending message", e9);
        });
      }
      if (!N3) return Iu(`[RCPMS: _write()] unsecure platform for method ${R3} -- return callback`), r3();
      if (O3) return Iu("[RCPMS: _write()] prevent deeplink -- installation completed separately."), r3();
      const t4 = null !== (b3 = null === (v2 = null === (y3 = e8.state.remote) || void 0 === y3 ? void 0 : y3.getKeyInfo()) || void 0 === v2 ? void 0 : v2.ecies.public) && void 0 !== b3 ? b3 : "";
      let n4 = encodeURI(`channelId=${M3}&pubkey=${t4}&comm=socket&t=d&v=2`);
      if (D3) {
        const t5 = JSON.stringify(null == P3 ? void 0 : P3.data), i3 = null === (w2 = e8.state.remote) || void 0 === w2 ? void 0 : w2.encrypt(t5);
        if (!i3) return Iu("[RCPMS: _write()] error encrypting message"), r3(new Error("RemoteCommunicationPostMessageStream - disconnected"));
        n4 += `&scheme=${T2}&rpc=${bh(i3)}`;
      }
      if (!(null === (E2 = e8.state.platformManager) || void 0 === E2 ? void 0 : E2.isMetaMaskInstalled())) return Iu("[RCPMS: _write()] prevent deeplink until installation is completed."), r3();
      sh[R3] ? (Iu(`[RCPMS: _write()] redirect link for '${R3}' socketConnected=${c2} connect?${n4}`), null === (S3 = e8.state.platformManager) || void 0 === S3 || S3.openDeeplink(`${th}?${n4}`, `${nh}?${n4}`, "_self")) : (null === (_3 = e8.state.remote) || void 0 === _3 ? void 0 : _3.isPaused()) ? (Iu(`[RCPMS: _write()] MM is PAUSED! deeplink with connect! targetMethod=${R3}`), null === (k3 = e8.state.platformManager) || void 0 === k3 || k3.openDeeplink(`${th}?redirect=true&${n4}`, `${nh}?redirect=true&${n4}`, "_self")) : Iu(`[RCPMS: _write()] method ${R3} doesn't need redirect.`);
    } catch (e9) {
      return Iu("[RCPMS: _write()] error sending message", e9), r3(new Error("RemoteCommunicationPostMessageStream - disconnected"));
    }
    return r3();
  });
}
var Eh = class extends ou.Duplex {
  constructor({ name: e8, remote: t3, deeplinkProtocol: n2, platformManager: r3 }) {
    super({ objectMode: true }), this.state = { _name: null, remote: null, deeplinkProtocol: false, platformManager: null }, this.state._name = e8, this.state.remote = t3, this.state.deeplinkProtocol = n2, this.state.platformManager = r3, this._onMessage = this._onMessage.bind(this), this.state.remote.on(So.MESSAGE, this._onMessage);
  }
  _write(e8, t3, n2) {
    return c(this, void 0, void 0, function* () {
      return wh(this, e8, 0, n2);
    });
  }
  _read() {
  }
  _onMessage(e8) {
    return function(e9, t3) {
      try {
        if (Iu("[RCPMS: onMessage()] message", t3), !t3 || "object" != typeof t3) return;
        if ("object" != typeof (null == t3 ? void 0 : t3.data)) return;
        if (!(null == t3 ? void 0 : t3.name)) return void Iu("[RCPMS: onMessage()] ignore message without name", t3);
        if ((null == t3 ? void 0 : t3.name) !== Qu.PROVIDER) return void Iu(`[RCPMS: onMessage()] ignore message with wrong name message=${t3}`);
        if (C.isBuffer(t3)) {
          const n2 = C.from(t3);
          e9.push(n2);
        } else e9.push(t3);
      } catch (e10) {
        Iu(`[RCPMS: onMessage()] ignore message error err=${e10}`);
      }
    }(this, e8);
  }
  start() {
  }
};
var Sh = 1;
var _h = (e8) => new Promise((t3) => {
  setTimeout(() => {
    t3(true);
  }, e8);
});
var Ch = ({ checkInstallationOnAllCalls: t3 = false, communicationLayerPreference: n2, injectProvider: r3, shouldShimWeb3: i2, platformManager: o, installer: s, sdk: a, remoteConnection: l3, debug: d3 }) => c(void 0, void 0, void 0, function* () {
  var u2, h3;
  const f2 = (({ name: e8, remoteConnection: t4 }) => {
    if (!t4 || !(null == t4 ? void 0 : t4.getConnector())) throw new Error("Missing remote connection parameter");
    return new Eh({ name: e8, remote: null == t4 ? void 0 : t4.getConnector(), deeplinkProtocol: null == t4 ? void 0 : t4.state.deeplinkProtocol, platformManager: null == t4 ? void 0 : t4.getPlatformManager() });
  })({ name: Qu.INPAGE, target: Qu.CONTENT_SCRIPT, platformManager: o, communicationLayerPreference: n2, remoteConnection: l3 }), p3 = o.getPlatformType(), g3 = a.options.dappMetadata, m2 = `Sdk/Javascript SdkVersion/${Xu.version} Platform/${p3} dApp/${null !== (u2 = g3.url) && void 0 !== u2 ? u2 : g3.name} dAppTitle/${g3.name}`;
  let y3 = null, v2 = null;
  const b3 = null === (h3 = a.options.storage) || void 0 === h3 ? void 0 : h3.storageManager;
  if (b3) {
    try {
      const e8 = yield b3.getCachedAccounts();
      e8.length > 0 && (y3 = e8[0]);
    } catch (e8) {
      console.error(`[initializeMobileProvider] failed to get cached addresses: ${e8}`);
    }
    try {
      const e8 = yield b3.getCachedChainId();
      e8 && (v2 = e8);
    } catch (e8) {
      console.error(`[initializeMobileProvider] failed to parse cached chainId: ${e8}`);
    }
  }
  Iu(`[initializeMobileProvider] cachedAccountAddress: ${y3}, cachedChainId: ${v2}`);
  const w2 = !(!r3 || p3 === Uo.NonBrowser || p3 === Uo.ReactNative), E2 = Gu.init({ shouldSetOnWindow: w2, connectionStream: f2, shouldShimWeb3: i2, sdkInstance: a });
  let S3 = false;
  const _3 = (e8) => {
    S3 = e8;
  }, C3 = () => S3, k3 = (n3, r4, i3, d4) => c(void 0, void 0, void 0, function* () {
    var u3, h4, f3, p4, g4, w3, E3, k4, A4;
    const x4 = Gu.getProvider();
    if (S3) {
      x4.emit("display_uri", (null == l3 ? void 0 : l3.state.qrcodeLink) || ""), null == l3 || l3.showActiveModal();
      let e8 = C3();
      for (; e8; ) {
        const t4 = C3(), n4 = null == l3 ? void 0 : l3.isAuthorized();
        e8 = t4 && !n4, Iu(`[initializeMobileProvider: sendRequest()] waiting for initialization to complete - initializing: ${t4} authorized: ${n4}`), yield _h(1e3);
      }
      return Iu("[initializeMobileProvider: sendRequest()] initial method completed -- prevent installation and call provider"), i3(...r4);
    }
    const M3 = o.isMetaMaskInstalled(), I3 = null == l3 ? void 0 : l3.isConnected();
    let T2 = null, R3 = null, P3 = null;
    if (T2 = null !== (u3 = x4.getSelectedAddress()) && void 0 !== u3 ? u3 : y3, P3 = x4.getChainId() || v2, T2 && b3 && T2 !== y3 && b3.persistAccounts([T2]).catch((e8) => {
      console.error(`[initializeMobileProvider] failed to persist account: ${e8}`);
    }), P3 && (v2 = P3, b3 && b3.persistChainId(P3).catch((e8) => {
      console.error(`[initializeMobileProvider] failed to persist chainId: ${e8}`);
    })), Iu("[initializeMobileProvider: sendRequest()]", { selectedAddress: T2, chainId: P3 }), d4 && Iu(`[initializeMobileProvider: sendRequest()] method=${n3} ongoing=${S3} selectedAddress=${T2} isInstalled=${M3} checkInstallationOnAllCalls=${t3} socketConnected=${I3}`), T2 && n3.toLowerCase() === oh.ETH_ACCOUNTS.toLowerCase()) return [T2];
    if (P3 && n3.toLowerCase() === oh.ETH_CHAINID.toLowerCase()) return P3;
    const O3 = [oh.ETH_REQUESTACCOUNTS, oh.WALLET_REQUESTPERMISSIONS, oh.METAMASK_CONNECTSIGN, oh.METAMASK_CONNECTWITH], N3 = !sh[n3], L3 = null === (h4 = a.options.readonlyRPCMap) || void 0 === h4 ? void 0 : h4[P3];
    if (L3 && N3) try {
      const t4 = null === (f3 = null == r4 ? void 0 : r4[0]) || void 0 === f3 ? void 0 : f3.params, i4 = yield (({ rpcEndpoint: t5, method: n4, sdkInfo: r5, params: i5 }) => c(void 0, void 0, void 0, function* () {
        const o2 = JSON.stringify({ jsonrpc: "2.0", method: n4, params: i5, id: (Sh += 1, Sh) }), s2 = { Accept: "application/json", "Content-Type": "application/json" };
        let a2;
        t5.includes("infura") && (s2["Metamask-Sdk-Info"] = r5);
        try {
          a2 = yield (0, import_cross_fetch.default)(t5, { method: "POST", headers: s2, body: o2 });
        } catch (e8) {
          throw e8 instanceof Error ? new Error(`Failed to fetch from RPC: ${e8.message}`) : new Error(`Failed to fetch from RPC: ${e8}`);
        }
        if (!a2.ok) throw new Error(`Server responded with a status of ${a2.status}`);
        return (yield a2.json()).result;
      }))({ rpcEndpoint: L3, sdkInfo: m2, method: n3, params: t4 || [] });
      return d4 && Iu(`initializeProvider::ReadOnlyRPCResponse ${i4}`), i4;
    } catch (e8) {
      console.warn(`[initializeMobileProvider: sendRequest()] method=${n3} readOnlyRPCRequest failed:`, e8);
    }
    if ((!M3 || M3 && !I3) && n3 !== oh.METAMASK_GETPROVIDERSTATE) {
      const e8 = (null === (p4 = null == r4 ? void 0 : r4[0]) || void 0 === p4 ? void 0 : p4.params) || [];
      if (-1 !== O3.indexOf(n3) || t3) {
        _3(true);
        const t4 = n3 === oh.METAMASK_CONNECTWITH, o2 = `${Date.now()}`;
        try {
          yield s.start({ wait: false, connectWith: t4 ? { method: n3, id: o2, params: e8 } : void 0 }), yield new Promise((e9, t5) => {
            (null == l3 ? void 0 : l3.isAuthorized()) && (Iu("[initializeMobileProvider: sendRequest()] already authorized"), e9(true)), null == l3 || l3.getConnector().once(So.AUTHORIZED, () => {
              e9(true);
            }), a.once(So.PROVIDER_UPDATE, (e10) => {
              Iu(`[initializeMobileProvider: sendRequest()] PROVIDER_UPDATE --- remote provider request interupted type=${e10}`), e10 === gh.EXTENSION ? t5(So.PROVIDER_UPDATE) : t5(new Error("Connection Terminated"));
            });
          });
        } catch (t5) {
          if (gh.EXTENSION === t5) {
            if (Iu(`[initializeMobileProvider: sendRequest()] extension provider detect: re-create ${n3} on the active provider`), n3.toLowerCase() === oh.METAMASK_CONNECTSIGN.toLowerCase()) {
              const t6 = yield null === (g4 = a.getProvider()) || void 0 === g4 ? void 0 : g4.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
              if (!t6.length) throw new Error("SDK state invalid -- undefined accounts");
              const n4 = yield null === (w3 = a.getProvider()) || void 0 === w3 ? void 0 : w3.request({ method: oh.PERSONAL_SIGN, params: [e8[0], t6[0]] });
              return a.emit(Vu.ConnectWithResponse, n4), n4;
            }
            if (n3.toLowerCase() === oh.METAMASK_CONNECTWITH.toLowerCase()) {
              const [t6] = e8, n4 = yield (({ method: e9, sdk: t7, params: n5 }) => c(void 0, void 0, void 0, function* () {
                var r5, i4, o3, s2;
                if (!t7.isExtensionActive()) throw new Error("SDK state invalid -- extension is not active");
                Iu("[MetaMaskProvider: extensionConnectWithOverwrite()] Overwriting request method", e9, n5);
                const a2 = yield null === (r5 = t7.getProvider()) || void 0 === r5 ? void 0 : r5.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
                if (!a2.length) throw new Error("SDK state invalid -- undefined accounts");
                if ((null == e9 ? void 0 : e9.toLowerCase()) === oh.PERSONAL_SIGN.toLowerCase()) {
                  const r6 = { method: e9, params: [n5[0], a2[0]] };
                  return yield null === (i4 = t7.getProvider()) || void 0 === i4 ? void 0 : i4.request(r6);
                }
                if ((null == e9 ? void 0 : e9.toLowerCase()) === oh.ETH_SENDTRANSACTION.toLowerCase()) {
                  const r6 = { method: e9, params: [Object.assign(Object.assign({}, n5[0]), { from: a2[0] })] };
                  return yield null === (o3 = t7.getProvider()) || void 0 === o3 ? void 0 : o3.request(r6);
                }
                return ch.includes(e9.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${e9} -- not handled by the extension -- call separately`), a2) : yield null === (s2 = t7.getProvider()) || void 0 === s2 ? void 0 : s2.request({ method: e9, params: n5 });
              }))({ method: t6.method, sdk: a, params: t6.params });
              return a.emit(Vu.ConnectWithResponse, n4), n4;
            }
            return Iu(`[initializeMobileProvider: sendRequest()] sending '${n3}' on active provider`, e8), yield null === (E3 = a.getProvider()) || void 0 === E3 ? void 0 : E3.request({ method: n3, params: e8 });
          }
          if (t5 === So.REJECTED) throw null == l3 || l3.closeModal(), null === (k4 = a.getProvider()) || void 0 === k4 || k4.handleDisconnect({ terminate: false }), Object.assign(new Error("User rejected connection"), { code: 4001 });
          throw Iu(`[initializeMobileProvider: sendRequest()] failed to start installer: ${t5}`), t5;
        } finally {
          _3(false);
        }
        if (n3 === oh.ETH_REQUESTACCOUNTS) return R3 = yield new Promise((e9) => {
          const t5 = setInterval(() => {
            const { accounts: n4 } = x4.getState();
            n4 && (clearInterval(t5), e9(n4));
          }, 100);
        }), Iu(`[initializeMobileProvider: sendRequest()] selectedAddress: ${T2} --- SKIP rpc call`), R3;
        if (n3 === oh.METAMASK_CONNECTWITH) try {
          let e9 = 0;
          const t5 = 5, n4 = ({ resolve: n5, reject: r6 }) => {
            e9 += 1;
            const i5 = null == l3 ? void 0 : l3.getConnector().getRPCMethodTracker(), s3 = null == i5 ? void 0 : i5[o2];
            return Iu(`TRACKER: update method ${o2}`, s3), (null == s3 ? void 0 : s3.result) ? (Iu("[initializeMobileProvider: sendRequest()] found result", s3.result), a.emit(Vu.ConnectWithResponse, s3.result), void n5(s3.result)) : (null == s3 ? void 0 : s3.error) ? (Iu("[initializeMobileProvider: sendRequest()] found error", s3.error), void r6(s3.error)) : e9 >= t5 ? (Iu("[initializeMobileProvider: sendRequest()] max message count reached without result"), void r6(new Error("Max message count reached without result"))) : void Iu("[initializeMobileProvider: sendRequest()] not found yet, need to wait for next update");
          };
          let r5, i4;
          const s2 = yield new Promise((e10, t6) => {
            const s3 = null == l3 ? void 0 : l3.getConnector().getRPCMethodTracker();
            Iu(`TRACKER: method ${o2}`, s3), (null == s3 ? void 0 : s3[o2].result) ? (Iu("[initializeMobileProvider: sendRequest()] found result", null == s3 ? void 0 : s3[o2].result), e10(null == s3 ? void 0 : s3[o2].result)) : (null == s3 ? void 0 : s3[o2].error) && (Iu("[initializeMobileProvider: sendRequest()] found error", null == s3 ? void 0 : s3[o2].error), t6(null == s3 ? void 0 : s3[o2].error)), i4 = () => n4({ resolve: e10, reject: t6 }), r5 = null == l3 ? void 0 : l3.getConnector().on(So.RPC_UPDATE, i4);
          });
          return i4 && (null == r5 || r5.off(So.RPC_UPDATE, i4)), Iu("TRACKER: result", s2), s2;
        } catch (e9) {
          throw Iu("[initializeMobileProvider: sendRequest()] error:", e9), e9;
        }
        r4[0] && "object" == typeof r4[0] && (r4[0].params = { __triggeredInstaller: true, wrappedParams: r4[0].params });
        return i3(...r4);
      }
      if (o.isSecure() && sh[n3]) return i3(...r4);
      if (a.isExtensionActive()) return Iu(`[initializeMobileProvider: sendRequest()] EXTENSION active - redirect request '${n3}' to it`, r4, e8), yield null === (A4 = a.getProvider()) || void 0 === A4 ? void 0 : A4.request({ method: n3, params: e8 });
      throw Iu(`[initializeMobileProvider: sendRequest()] method=${n3} --- skip --- not connected/installed`), new Error("MetaMask is not connected/installed, please call eth_requestAccounts to connect first.");
    }
    try {
      const e8 = yield i3(...r4);
      if (Iu(`[initializeMobileProvider: sendRequest()] method=${n3} rpcResponse`, e8), n3 === oh.WALLET_REQUESTPERMISSIONS) {
        const t4 = e8.reduce((e9, t5) => {
          var n4;
          if ("eth_accounts" === t5.parentCapability) {
            const r5 = null === (n4 = t5.caveats.find((e10) => "restrictReturnedAccounts" === e10.type)) || void 0 === n4 ? void 0 : n4.value;
            r5 && e9.push(...r5);
          }
          return e9;
        }, []);
        Iu("[initializeMobileProvider: sendRequest()] accountsToPersist:", t4), t4.length > 0 && (x4.handleAccountsChanged(t4, false), null == b3 || b3.persistAccounts(t4));
      }
      return e8;
    } catch (e8) {
      throw console.error("[initializeMobileProvider: sendRequest()] error:", e8), e8;
    }
  }), { request: A3 } = E2;
  E2.request = (...e8) => c(void 0, void 0, void 0, function* () {
    return k3(null == e8 ? void 0 : e8[0].method, e8, A3, d3);
  });
  const { send: x3 } = E2;
  return E2.send = (...e8) => c(void 0, void 0, void 0, function* () {
    return k3(null == e8 ? void 0 : e8[0], e8, x3, d3);
  }), Iu("[initializeMobileProvider: sendRequest()] metamaskStream.start()"), f2.start(), E2;
});
function kh(e8) {
  var t3, n2, r3, i2;
  return c(this, void 0, void 0, function* () {
    const { options: o } = e8, s = { communicationLayerPreference: null !== (t3 = o.communicationLayerPreference) && void 0 !== t3 ? t3 : jo.SOCKET, platformManager: e8.platformManager, sdk: e8, checkInstallationOnAllCalls: o.checkInstallationOnAllCalls, injectProvider: null === (n2 = o.injectProvider) || void 0 === n2 || n2, shouldShimWeb3: null === (r3 = o.shouldShimWeb3) || void 0 === r3 || r3, extensionOnly: null === (i2 = o.extensionOnly) || void 0 === i2 || i2, installer: e8.installer, remoteConnection: e8.remoteConnection, debug: e8.debug }, a = yield Ch(s);
    e8.activeProvider = a, function(e9) {
      var t4, n3, r4, i3;
      null === (n3 = null === (t4 = e9.remoteConnection) || void 0 === t4 ? void 0 : t4.getConnector()) || void 0 === n3 || n3.on(Vu.ConnectionStatus, (t5) => {
        e9.emit(Vu.ConnectionStatus, t5);
      }), null === (i3 = null === (r4 = e9.remoteConnection) || void 0 === r4 ? void 0 : r4.getConnector()) || void 0 === i3 || i3.on(Vu.ServiceStatus, (t5) => {
        e9.emit(Vu.ServiceStatus, t5);
      });
    }(e8);
  });
}
var Ah = "sdk";
var xh = class {
  constructor({ serverUrl: e8, enabled: t3, originatorInfo: n2 }) {
    this.serverURL = fo, this.serverURL = e8, this.originatorInfo = n2, this.enabled = null == t3 || t3;
  }
  send({ event: e8, params: t3 }) {
    if (!this.enabled) return;
    const n2 = Object.assign(Object.assign({ id: Ah, event: e8, sdkVersion: Xu.version }, this.originatorInfo), { params: t3 });
    Iu(`[Analytics: send()] event: ${e8}`, n2), lo(n2, this.serverURL).catch((e9) => {
      Iu(`[Analytics: send()] error: ${e9}`);
    });
  }
};
var Mh = () => {
  if ("undefined" == typeof document) return;
  let e8;
  const t3 = document.getElementsByTagName("link");
  for (let n2 = 0; n2 < t3.length; n2++) "icon" !== t3[n2].getAttribute("rel") && "shortcut icon" !== t3[n2].getAttribute("rel") || (e8 = t3[n2].getAttribute("href"));
  return e8;
};
var Ih = 163400;
function Th(e8) {
  var t3, n2, r3;
  const { dappMetadata: i2 } = e8, o = function({ url: e9, name: t4 }) {
    var n3;
    const r4 = e9 + t4, i3 = bh(r4);
    if (!localStorage) return "";
    let o2 = null !== (n3 = localStorage.getItem(i3)) && void 0 !== n3 ? n3 : "";
    if (!o2) {
      o2 = v4_default();
      try {
        localStorage.setItem(i3, o2);
      } catch (e10) {
        return "";
      }
    }
    return o2;
  }({ url: null !== (t3 = null == i2 ? void 0 : i2.url) && void 0 !== t3 ? t3 : "no_url", name: null !== (n2 = null == i2 ? void 0 : i2.name) && void 0 !== n2 ? n2 : "no_name" }), a = null === (r3 = e8.platformManager) || void 0 === r3 ? void 0 : r3.getPlatformType(), c2 = a === Uo.DesktopWeb, l3 = a === Uo.MetaMaskMobileWebview;
  let d3 = "N/A";
  return c2 ? d3 = "extension" : l3 && (d3 = "mobile"), { id: o, from: d3 };
}
var Rh = (e8, t3, r3) => {
  if (bo(e8)) {
    if (r3 || t3 && "object" == typeof t3 && null !== t3 && "error" in t3) {
      const i2 = r3 || (null == t3 ? void 0 : t3.error);
      i2 && 4001 === i2.code ? import_sdk_analytics.analytics.track("sdk_action_rejected", { action: e8 }) : import_sdk_analytics.analytics.track("sdk_action_failed", { action: e8 });
    } else import_sdk_analytics.analytics.track("sdk_action_succeeded", { action: e8 });
  }
};
var Ph = ({ provider: e8, sdkInstance: t3 }) => {
  if ("state" in e8) throw new Error("INVALID EXTENSION PROVIDER");
  return new Proxy(e8, { get: (r3, i2) => "request" === i2 ? function(e9) {
    var i3, o;
    return c(this, void 0, void 0, function* () {
      Iu("[wrapExtensionProvider()] Overwriting request method", e9);
      const { method: s, params: a } = e9, l3 = ah.includes(s.toLowerCase()), { id: d3, from: u2 } = Th(t3);
      if (l3 && (null === (i3 = t3.analytics) || void 0 === i3 || i3.send({ event: Ao.SDK_RPC_REQUEST, params: { method: s, from: u2, id: d3 } })), bo(s) && import_sdk_analytics.analytics.track("sdk_action_requested", { action: s }), s === oh.METAMASK_BATCH && Array.isArray(a)) return (({ target: e10, args: t4, trackEvent: n2, sdkInstance: r4 }) => c(void 0, void 0, void 0, function* () {
        var i4, o2;
        if ("metamask_batch" !== t4.method) throw new Error("Invalid usage");
        const s2 = [], a2 = null !== (i4 = null == t4 ? void 0 : t4.params) && void 0 !== i4 ? i4 : [];
        for (const t5 of a2) {
          const n3 = yield null == e10 ? void 0 : e10.request({ method: t5.method, params: t5.params });
          s2.push(n3);
        }
        const { id: c2, from: l4 } = Th(r4);
        n2 && (null === (o2 = r4.analytics) || void 0 === o2 || o2.send({ event: Ao.SDK_RPC_REQUEST_DONE, params: { method: t4.method, from: l4, id: c2 } }));
        for (const e11 of s2) Rh(t4.method, e11, null);
        return s2;
      }))({ target: r3, args: e9, trackEvent: l3, sdkInstance: t3 });
      if (s.toLowerCase() === oh.METAMASK_CONNECTSIGN.toLowerCase() && Array.isArray(a)) return (({ target: e10, params: t4 }) => c(void 0, void 0, void 0, function* () {
        let n2, r4 = null;
        try {
          const r5 = yield e10.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
          if (!r5.length) throw new Error("SDK state invalid -- undefined accounts");
          return n2 = yield e10.request({ method: oh.PERSONAL_SIGN, params: [t4[0], r5[0]] }), n2;
        } catch (e11) {
          throw r4 = e11, e11;
        } finally {
          Rh(oh.PERSONAL_SIGN, n2, r4);
        }
      }))({ target: r3, params: a });
      if (s.toLowerCase() === oh.METAMASK_CONNECTWITH.toLowerCase() && Array.isArray(a)) return (({ target: e10, params: t4 }) => c(void 0, void 0, void 0, function* () {
        const [n2] = t4, r4 = n2.method, i4 = n2.params;
        let o2, s2 = null;
        try {
          const t5 = yield e10.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
          if (!Array.isArray(t5) || !t5.length) throw new Error("SDK state invalid -- undefined accounts");
          return (null == r4 ? void 0 : r4.toLowerCase()) === oh.PERSONAL_SIGN.toLowerCase() ? (o2 = yield e10.request({ method: r4, params: [i4[0], t5[0]] }), o2) : (null == r4 ? void 0 : r4.toLowerCase()) === oh.ETH_SENDTRANSACTION.toLowerCase() ? (o2 = yield e10.request({ method: r4, params: [Object.assign(Object.assign({}, i4[0]), { from: t5[0] })] }), o2) : ch.includes(r4.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${r4} -- not handled by the extension -- call separately`), o2 = t5, o2) : (o2 = yield e10.request({ method: r4, params: i4 }), o2);
        } catch (e11) {
          throw s2 = e11, e11;
        } finally {
          Rh(r4, o2, s2);
        }
      }))({ target: r3, params: a });
      let h3, f2 = null;
      try {
        return h3 = yield r3.request(e9), h3;
      } catch (e10) {
        throw f2 = e10, e10;
      } finally {
        l3 && (null === (o = t3.analytics) || void 0 === o || o.send({ event: Ao.SDK_RPC_REQUEST_DONE, params: { method: s, from: u2, id: d3 } })), Rh(s, h3, f2);
      }
    });
  } : "getChainId" === i2 ? function() {
    return e8.chainId;
  } : "getNetworkVersion" === i2 ? function() {
    return e8.networkVersion;
  } : "getSelectedAddress" === i2 ? function() {
    return e8.selectedAddress;
  } : "isConnected" === i2 ? function() {
    return e8._state.isConnected;
  } : r3[i2] });
};
var Oh;
function Nh({ mustBeMetaMask: e8, sdkInstance: t3 }) {
  return c(this, void 0, void 0, function* () {
    if ("undefined" == typeof window) throw new Error("window not available");
    try {
      const e9 = yield new Promise((e10, t4) => {
        const n2 = setTimeout(() => {
          t4(new Error("eip6963RequestProvider timed out"));
        }, 500);
        window.addEventListener(Oh.Announce, (t5) => {
          const r3 = t5, { detail: { info: i2, provider: o } = {} } = r3, { name: s, rdns: a, uuid: c2 } = null != i2 ? i2 : {};
          ih.test(c2) && s.startsWith(rh.NAME) && rh.RDNS.includes(a) && (clearTimeout(n2), e10(o));
        }), window.dispatchEvent(new Event(Oh.Request));
      });
      return Ph({ provider: e9, sdkInstance: t3 });
    } catch (n2) {
      if (!e8 && window.ethereum) return Ph({ provider: window.ethereum, sdkInstance: t3 });
      throw new Error("Provider not found");
    }
  });
}
!function(e8) {
  e8.Announce = "eip6963:announceProvider", e8.Request = "eip6963:requestProvider";
}(Oh || (Oh = {}));
var Lh = (e8) => c(void 0, void 0, void 0, function* () {
  const { options: t3 } = e8, { infuraAPIKey: n2 } = t3;
  if (!n2) return;
  const r3 = { "0x1": `https://mainnet.infura.io/v3/${n2}`, "0x5": `https://goerli.infura.io/v3/${n2}`, "0xaa36a7": `https://sepolia.infura.io/v3/${n2}`, "0xe708": `https://linea-mainnet.infura.io/v3/${n2}`, "0xe704": `https://linea-goerli.infura.io/v3/${n2}`, "0x89": `https://polygon-mainnet.infura.io/v3/${n2}`, "0x13881": `https://polygon-mumbai.infura.io/v3/${n2}`, "0x45": `https://optimism-mainnet.infura.io/v3/${n2}`, "0x1a4": `https://optimism-goerli.infura.io/v3/${n2}`, "0xa4b1": `https://arbitrum-mainnet.infura.io/v3/${n2}`, "0x66eed": `https://arbitrum-goerli.infura.io/v3/${n2}`, "0x2a15c308d": `https://palm-mainnet.infura.io/v3/${n2}`, "0x2a15c3083": `https://palm-testnet.infura.io/v3/${n2}`, "0xa86a": `https://avalanche-mainnet.infura.io/v3/${n2}`, "0xa869": `https://avalanche-fuji.infura.io/v3/${n2}`, "0x4e454152": `https://aurora-mainnet.infura.io/v3/${n2}`, "0x4e454153": `https://aurora-testnet.infura.io/v3/${n2}`, "0x534e5f4d41494e": `https://starknet-mainnet.infura.io/v3/${n2}`, "0x534e5f474f45524c49": `https://starknet-goerli.infura.io/v3/${n2}`, "0x534e5f474f45524c4932": `https://starknet-goerli2.infura.io/v3/${n2}`, "0xa4ec": `https://celo-mainnet.infura.io/v3/${n2}`, "0xaef3": `https://celo-alfajores.infura.io/v3/${n2}` };
  e8.options.readonlyRPCMap ? e8.options.readonlyRPCMap = Object.assign(Object.assign({}, e8.options.readonlyRPCMap), r3) : e8.options.readonlyRPCMap = r3;
});
var Dh = (e8) => c(void 0, void 0, void 0, function* () {
  const { options: t3 } = e8, { readonlyRPCMap: n2 } = t3;
  if (n2) try {
    Iu("[MetaMaskSDK: setupReadOnlyRPCProviders()] Setting up Readonly RPC Providers", n2), e8.setReadOnlyRPCCalls(true);
  } catch (e9) {
    throw new Error("Invalid Infura Settings");
  }
});
function $h(e8, t3, n2, r3) {
  return new (n2 || (n2 = Promise))(function(t4, i2) {
    function o(e9) {
      try {
        a(r3.next(e9));
      } catch (e10) {
        i2(e10);
      }
    }
    function s(e9) {
      try {
        a(r3.throw(e9));
      } catch (e10) {
        i2(e10);
      }
    }
    function a(e9) {
      var r4;
      e9.done ? t4(e9.value) : (r4 = e9.value, r4 instanceof n2 ? r4 : new n2(function(e10) {
        e10(r4);
      })).then(o, s);
    }
    a((r3 = r3.apply(e8, [])).next());
  });
}
function Bh(e8, t3) {
  var n2, r3, i2, o, s = { label: 0, sent: function() {
    if (1 & i2[0]) throw i2[1];
    return i2[1];
  }, trys: [], ops: [] };
  return o = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(o2) {
    return function(a2) {
      return function(o3) {
        if (n2) throw new TypeError("Generator is already executing.");
        for (; s; ) try {
          if (n2 = 1, r3 && (i2 = 2 & o3[0] ? r3.return : o3[0] ? r3.throw || ((i2 = r3.return) && i2.call(r3), 0) : r3.next) && !(i2 = i2.call(r3, o3[1])).done) return i2;
          switch (r3 = 0, i2 && (o3 = [2 & o3[0], i2.value]), o3[0]) {
            case 0:
            case 1:
              i2 = o3;
              break;
            case 4:
              return s.label++, { value: o3[1], done: false };
            case 5:
              s.label++, r3 = o3[1], o3 = [0];
              continue;
            case 7:
              o3 = s.ops.pop(), s.trys.pop();
              continue;
            default:
              if (!(i2 = s.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o3[0] && 2 !== o3[0])) {
                s = 0;
                continue;
              }
              if (3 === o3[0] && (!i2 || o3[1] > i2[0] && o3[1] < i2[3])) {
                s.label = o3[1];
                break;
              }
              if (6 === o3[0] && s.label < i2[1]) {
                s.label = i2[1], i2 = o3;
                break;
              }
              if (i2 && s.label < i2[2]) {
                s.label = i2[2], s.ops.push(o3);
                break;
              }
              i2[2] && s.ops.pop(), s.trys.pop();
              continue;
          }
          o3 = t3.call(e8, s);
        } catch (e9) {
          o3 = [6, e9], r3 = 0;
        } finally {
          n2 = i2 = 0;
        }
        if (5 & o3[0]) throw o3[1];
        return { value: o3[0] ? o3[1] : void 0, done: true };
      }([o2, a2]);
    };
  }
}
var Kh = "INSTALLED";
var jh = "NOT_INSTALLED";
var Uh = "REGISTERED";
var Hh = "REGISTERING";
var Fh = "RELOADING";
var zh = { CHROME: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn", FIREFOX: "https://addons.mozilla.org/firefox/addon/ether-metamask/", DEFAULT: "https://metamask.io" };
var qh = "REGISTRATION_IN_PROGRESS";
var Wh = "FORWARDER_ID";
var Vh = function() {
  function e8(t3) {
    var n2 = void 0 === t3 ? {} : t3, r3 = n2.forwarderOrigin, i2 = void 0 === r3 ? "https://fwd.metamask.io" : r3, o = n2.forwarderMode, s = void 0 === o ? e8.FORWARDER_MODE.INJECT : o;
    this.forwarderOrigin = i2, this.forwarderMode = s, this.state = e8.isMetaMaskInstalled() ? Kh : jh;
    var a = e8._detectBrowser();
    this.downloadUrl = a ? zh[a] : zh.DEFAULT, this._onMessage = this._onMessage.bind(this), this._onMessageFromForwarder = this._onMessageFromForwarder.bind(this), this._openForwarder = this._openForwarder.bind(this), this._openDownloadPage = this._openDownloadPage.bind(this), this.startOnboarding = this.startOnboarding.bind(this), this.stopOnboarding = this.stopOnboarding.bind(this), window.addEventListener("message", this._onMessage), s === e8.FORWARDER_MODE.INJECT && "true" === sessionStorage.getItem(qh) && e8._injectForwarder(this.forwarderOrigin);
  }
  return e8.prototype._onMessage = function(e9) {
    if (e9.origin === this.forwarderOrigin) return "metamask:reload" === e9.data.type ? this._onMessageFromForwarder(e9) : void console.debug("Unknown message from '" + e9.origin + "' with data " + JSON.stringify(e9.data));
  }, e8.prototype._onMessageUnknownStateError = function(e9) {
    throw new Error("Unknown state: '" + e9 + "'");
  }, e8.prototype._onMessageFromForwarder = function(t3) {
    return $h(this, 0, void 0, function() {
      return Bh(this, function(n2) {
        switch (n2.label) {
          case 0:
            switch (this.state) {
              case Fh:
                return [3, 1];
              case jh:
                return [3, 2];
              case Kh:
                return [3, 3];
              case Hh:
                return [3, 5];
              case Uh:
                return [3, 6];
            }
            return [3, 7];
          case 1:
            return console.debug("Ignoring message while reloading"), [3, 8];
          case 2:
            return console.debug("Reloading now to register with MetaMask"), this.state = Fh, location.reload(), [3, 8];
          case 3:
            return console.debug("Registering with MetaMask"), this.state = Hh, [4, e8._register()];
          case 4:
            return n2.sent(), this.state = Uh, t3.source.postMessage({ type: "metamask:registrationCompleted" }, t3.origin), this.stopOnboarding(), [3, 8];
          case 5:
            return console.debug("Already registering - ignoring reload message"), [3, 8];
          case 6:
            return console.debug("Already registered - ignoring reload message"), [3, 8];
          case 7:
            this._onMessageUnknownStateError(this.state), n2.label = 8;
          case 8:
            return [2];
        }
      });
    });
  }, e8.prototype.startOnboarding = function() {
    sessionStorage.setItem(qh, "true"), this._openDownloadPage(), this._openForwarder();
  }, e8.prototype.stopOnboarding = function() {
    "true" === sessionStorage.getItem(qh) && (this.forwarderMode === e8.FORWARDER_MODE.INJECT && (console.debug("Removing forwarder"), e8._removeForwarder()), sessionStorage.setItem(qh, "false"));
  }, e8.prototype._openForwarder = function() {
    this.forwarderMode === e8.FORWARDER_MODE.OPEN_TAB ? window.open(this.forwarderOrigin, "_blank") : e8._injectForwarder(this.forwarderOrigin);
  }, e8.prototype._openDownloadPage = function() {
    window.open(this.downloadUrl, "_blank");
  }, e8.isMetaMaskInstalled = function() {
    return Boolean(window.ethereum && window.ethereum.isMetaMask);
  }, e8._register = function() {
    return window.ethereum.request({ method: "wallet_registerOnboarding" });
  }, e8._injectForwarder = function(e9) {
    var t3 = document.body, n2 = document.createElement("iframe");
    n2.setAttribute("height", "0"), n2.setAttribute("width", "0"), n2.setAttribute("style", "display: none;"), n2.setAttribute("src", e9), n2.setAttribute("id", Wh), t3.insertBefore(n2, t3.children[0]);
  }, e8._removeForwarder = function() {
    var e9;
    null === (e9 = document.getElementById(Wh)) || void 0 === e9 || e9.remove();
  }, e8._detectBrowser = function() {
    var e9 = Wu.parse(window.navigator.userAgent);
    return "Firefox" === e9.browser.name ? "FIREFOX" : ["Chrome", "Chromium"].includes(e9.browser.name || "") ? "CHROME" : null;
  }, e8.FORWARDER_MODE = { INJECT: "INJECT", OPEN_TAB: "OPEN_TAB" }, e8;
}();
function Gh(e8, { wait: t3 = false }) {
  return c(this, void 0, void 0, function* () {
    return Iu(`[MetamaskInstaller: startInstaller()] wait=${t3}`), t3 && (yield _h(1e3)), yield e8.checkInstallation();
  });
}
var Yh = class {
  constructor({ remote: e8, preferDesktop: t3, platformManager: n2, debug: r3 = false }) {
    this.state = { isInstalling: false, hasInstalled: false, resendRequest: null, preferDesktop: false, platformManager: null, remote: null, debug: false, connectWith: void 0 }, this.state.remote = e8, this.state.preferDesktop = t3, this.state.platformManager = n2, this.state.debug = r3;
  }
  startDesktopOnboarding() {
    return function() {
      return c(this, void 0, void 0, function* () {
        Iu("[MetamaskInstaller: startDesktopOnboarding() starting desktop onboarding"), window.ethereum && (window.ethereum = void 0), new Vh().startOnboarding();
      });
    }();
  }
  redirectToProperInstall() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        var t3, n2;
        return c(this, void 0, void 0, function* () {
          const { state: r3 } = e8, i2 = null === (t3 = r3.platformManager) || void 0 === t3 ? void 0 : t3.getPlatformType();
          if (Iu(`[MetamaskInstaller: redirectToProperInstall()] platform=${i2}`), i2 === Uo.MetaMaskMobileWebview) return false;
          r3.isInstalling = true;
          try {
            yield null === (n2 = r3.remote) || void 0 === n2 ? void 0 : n2.startConnection({ connectWith: r3.connectWith }), r3.isInstalling = false, r3.hasInstalled = true;
          } catch (e9) {
            throw r3.isInstalling = false, e9;
          }
          return true;
        });
      }(this);
    });
  }
  checkInstallation() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        var t3;
        return c(this, void 0, void 0, function* () {
          const { state: n2 } = e8, r3 = null === (t3 = n2.platformManager) || void 0 === t3 ? void 0 : t3.isMetaMaskInstalled();
          return Iu(`[MetamaskInstaller: checkInstallation()] isInstalled=${r3}`), !!r3 || (yield e8.redirectToProperInstall());
        });
      }(this);
    });
  }
  start({ wait: e8 = false, connectWith: t3 }) {
    return c(this, void 0, void 0, function* () {
      this.state.connectWith = t3, Iu(`[MetaMaskInstaller: start()] wait=${e8}`, t3), yield Gh(this, { wait: e8 });
    });
  }
};
var Zh = class {
  constructor({ debug: e8, sdkVersion: t3 }) {
    this.containers = { install: void 0, pending: void 0, select: void 0 }, this.defined = { install: false, pending: false, select: false }, this.debug = null != e8 && e8, this.sdkVersion = t3;
  }
  loadComponent(e8) {
    return c(this, void 0, void 0, function* () {
      if (!this.defined[e8]) {
        this.defined[e8] = true;
        try {
          const e9 = yield Promise.resolve().then(function() {
            return Lp;
          });
          console.log("loader", e9), e9.defineCustomElements();
        } catch (t3) {
          console.error(`Failed to load ${e8} modal:`, t3);
        }
      }
    });
  }
  renderInstallModal(e8) {
    var t3;
    return c(this, void 0, void 0, function* () {
      this.debug && console.debug("ModalLoader: renderInstallModal", e8), this.containers.install = e8.parentElement, yield this.loadComponent("install");
      const n2 = document.createElement("mm-install-modal");
      n2.link = e8.link, n2.preferDesktop = e8.preferDesktop, n2.sdkVersion = null !== (t3 = e8.sdkVersion) && void 0 !== t3 ? t3 : this.sdkVersion, n2.addEventListener("close", ({ detail: { shouldTerminate: t4 } }) => e8.onClose(t4)), n2.addEventListener("startDesktopOnboarding", e8.metaMaskInstaller.startDesktopOnboarding), n2.addEventListener("trackAnalytics", (t4) => {
        var n3;
        return null === (n3 = e8.onAnalyticsEvent) || void 0 === n3 ? void 0 : n3.call(e8, t4.detail);
      }), e8.parentElement.appendChild(n2);
    });
  }
  renderSelectModal(e8) {
    var t3;
    return c(this, void 0, void 0, function* () {
      this.containers.select = e8.parentElement, yield this.loadComponent("select");
      const n2 = document.createElement("mm-select-modal");
      n2.link = e8.link, n2.sdkVersion = null !== (t3 = e8.sdkVersion) && void 0 !== t3 ? t3 : this.sdkVersion, n2.preferDesktop = e8.preferDesktop, n2.addEventListener("close", ({ detail: { shouldTerminate: t4 } }) => e8.onClose(t4)), n2.addEventListener("connectWithExtension", e8.connectWithExtension), e8.parentElement.appendChild(n2), setTimeout(() => this.updateQRCode(e8.link), 100);
    });
  }
  renderPendingModal(e8) {
    var t3;
    return c(this, void 0, void 0, function* () {
      this.containers.pending = e8.parentElement, yield this.loadComponent("pending");
      const n2 = document.createElement("mm-pending-modal");
      n2.sdkVersion = null !== (t3 = e8.sdkVersion) && void 0 !== t3 ? t3 : this.sdkVersion, n2.displayOTP = e8.displayOTP, n2.addEventListener("close", e8.onClose), n2.addEventListener("updateOTPValue", ({ detail: { otpValue: t4 } }) => e8.updateOTPValue(t4)), e8.onDisconnect && n2.addEventListener("disconnect", e8.onDisconnect), e8.parentElement.appendChild(n2);
    });
  }
  updateOTPValue(e8) {
    const t3 = () => {
      var t4;
      const n2 = null === (t4 = this.containers.pending) || void 0 === t4 ? void 0 : t4.querySelector("mm-pending-modal");
      return !!n2 && (n2.otpCode = e8, true);
    };
    setTimeout(() => {
      t3();
    }, 800);
  }
  updateQRCode(e8) {
    var t3, n2;
    const r3 = null === (t3 = this.containers.install) || void 0 === t3 ? void 0 : t3.querySelector("mm-install-modal");
    if (r3) r3.link = e8;
    else {
      const t4 = null === (n2 = this.containers.select) || void 0 === n2 ? void 0 : n2.querySelector("mm-select-modal");
      t4 && (t4.link = e8);
    }
  }
  unmount() {
    Object.entries(this.containers).forEach(([e8, t3]) => {
      var n2;
      null === (n2 = null == t3 ? void 0 : t3.parentNode) || void 0 === n2 || n2.removeChild(t3), this.containers[e8] = void 0;
    });
  }
};
var Jh = ({ link: e8, debug: t3, installer: n2, terminate: r3, connectWithExtension: i2, preferDesktop: o, onAnalyticsEvent: s }) => {
  let a = null, c2 = null;
  Iu("[UI: InstallModal-web: sdkWebInstallModal()] ################## Installing Modal #################"), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] link=${e8}`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e8}" --ios`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e8}" --android`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] adb shell am start -a android.intent.action.VIEW -d "${e8}"`);
  const l3 = (e9) => {
    var t4;
    Iu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web unmounting install modal -- shouldTerminate:", e9, c2), (null == c2 ? void 0 : c2.parentNode) && (null === (t4 = c2.parentNode) || void 0 === t4 || t4.removeChild(c2)), c2 = null, a = null, true === e9 && (null == r3 || r3());
  };
  return { mount: (r4) => {
    if (Iu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web mounting install modal", c2), c2) return c2.style.display = "block", void (null == a || a.updateQRCode(r4));
    a = new Zh({ debug: t3, sdkVersion: Xu.version }), c2 = document.createElement("div"), document.body.appendChild(c2), window.extension ? a.renderSelectModal({ parentElement: c2, connectWithExtension: () => {
      l3(), null == i2 || i2();
    }, onClose: l3, link: e8, preferDesktop: null != o && o }).catch((e9) => {
      console.error(e9);
    }) : a.renderInstallModal({ parentElement: c2, preferDesktop: null != o && o, link: e8, metaMaskInstaller: n2, onClose: l3, onAnalyticsEvent: s }).catch((e9) => {
      console.error("[UI: InstallModal-web: sdkWebInstallModal()]", e9);
    });
  }, unmount: l3 };
};
var Qh = ({ onDisconnect: e8, debug: t3 }) => {
  let n2 = null, r3 = null;
  const i2 = () => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web unmount", n2), (null == n2 ? void 0 : n2.parentNode) && n2.parentNode.removeChild(n2), n2 = null, r3 = null;
  }, o = (e9) => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web updateOTPValue", e9), r3 && r3.updateOTPValue(e9);
  }, s = ({ displayOTP: s2 } = { displayOTP: true }) => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web mount", n2), n2 ? n2.style.display = "block" : (r3 = new Zh({ debug: t3, sdkVersion: Xu.version }), n2 = document.createElement("div"), document.body.appendChild(n2), r3.renderPendingModal({ parentElement: n2, onClose: i2, onDisconnect: e8, updateOTPValue: o, displayOTP: s2 }).catch((e9) => {
      console.error("[UI: pendingModal-web: sdkWebPendingModal()]", e9);
    }));
  };
  return s(), { mount: s, unmount: i2, updateOTPValue: o };
};
function Xh(e8, t3) {
  var n2, r3, i2, o;
  e8.connector || (Iu("[RemoteConnection: initializeConnector()] initialize connector"), e8.connector = new ts({ anonId: t3.anonId, platformType: t3.platformManager.getPlatformType(), communicationLayerPreference: t3.communicationLayerPreference, transports: t3.transports, dappMetadata: Object.assign(Object.assign({}, t3.dappMetadata), { source: t3._source }), analytics: t3.enableAnalytics, communicationServerUrl: t3.communicationServerUrl, sdkVersion: Xu.version, context: "dapp", ecies: t3.ecies, storage: t3.storage, logging: t3.logging }), t3.timer && (Iu("[RemoteConnection: initializeConnector()] reset background timer", t3.timer), null === (r3 = null === (n2 = t3.timer) || void 0 === n2 ? void 0 : n2.stopBackgroundTimer) || void 0 === r3 || r3.call(n2), null === (o = null === (i2 = t3.timer) || void 0 === i2 ? void 0 : i2.runBackgroundTimer) || void 0 === o || o.call(i2, () => false, 1e4)));
}
function ef(e8) {
  e8.listeners.forEach(({ event: t3, handler: n2 }) => {
    var r3;
    null === (r3 = e8.connector) || void 0 === r3 || r3.off(t3, n2);
  }), e8.listeners = [];
}
function tf(e8, t3, r3) {
  return c(this, void 0, void 0, function* () {
    const i2 = setTimeout(() => {
      import_sdk_analytics.analytics.track("sdk_connection_failed", { transport_type: "websocket" });
    }, 6e4);
    return new Promise((n2, o) => {
      if (!e8.connector) return void o(new Error("No connector available"));
      Iu("[RemoteConnection: connectWithModalInstaller()]", { state: e8, options: t3, linkParams: r3 });
      const s = `${e8.useDeeplink ? nh : th}?${r3}`;
      !function(e9, t4, n3) {
        var r4, i3, o2, s2;
        e9.installModal = null === (i3 = (r4 = t4.modals).install) || void 0 === i3 ? void 0 : i3.call(r4, { link: n3, preferDesktop: e9.preferDesktop, installer: t4.getMetaMaskInstaller(), terminate: () => {
          Iu("[RemoteConnection: showInstallModal() => terminate()] terminate connection"), t4.sdk.terminate().catch((e10) => {
            console.warn("[MMSDK] failed to terminate connection", e10);
          });
        }, debug: e9.developerMode, connectWithExtension: () => {
          var e10;
          return null === (e10 = t4.connectWithExtensionProvider) || void 0 === e10 || e10.call(t4), false;
        }, onAnalyticsEvent: ({ event: n4, params: r5 }) => {
          var i4, o3, s3;
          const a = Object.assign(Object.assign({}, r5), { sdkVersion: t4.sdk.getVersion(), dappId: null === (i4 = t4.dappMetadata) || void 0 === i4 ? void 0 : i4.name, source: t4._source, url: null === (o3 = t4.dappMetadata) || void 0 === o3 ? void 0 : o3.url });
          null === (s3 = e9.analytics) || void 0 === s3 || s3.send({ event: n4, params: a });
        } }), null === (s2 = null === (o2 = e9.installModal) || void 0 === o2 ? void 0 : o2.mount) || void 0 === s2 || s2.call(o2, n3);
      }(e8, t3, s), t3.sdk.once(So.PROVIDER_UPDATE, (e9) => c(this, void 0, void 0, function* () {
        if (Iu("[RemoteConnection: connectWithModalInstaller()] once provider_update -- resolving startConnection promise"), e9 === gh.TERMINATE) {
          const e10 = { code: 4001, message: "User rejected the request." };
          return clearTimeout(i2), void o(e10);
        }
        o(e9);
      })), e8.connector.once(So.AUTHORIZED, () => {
        clearTimeout(i2), n2();
      }), e8.connector.once(So.REJECTED, () => {
        clearTimeout(i2), o(So.REJECTED);
      }), e8.connector.once(So.CLIENTS_READY, () => c(this, void 0, void 0, function* () {
        Iu("[RemoteConnection: connectWithModalInstaller()] once clients_ready -- resolving startConnection promise"), clearTimeout(i2), n2();
      }));
    });
  });
}
function nf(e8, t3) {
  function n2(t4, n3) {
    var r3;
    null === (r3 = e8.connector) || void 0 === r3 || r3.on(t4, n3), e8.listeners.push({ event: t4, handler: n3 });
  }
  e8.connector && (ef(e8), n2(So.WALLET_INIT, ({ accounts: e9, chainId: t4 }) => c(this, void 0, void 0, function* () {
    Iu(`[RemoteConnection: setupListeners() => EventType.WALLET_INIT] 'wallet_init' accounts=${e9} chainId=${t4}`);
    const n3 = Gu.getProvider();
    n3._setConnected();
    const r3 = { accounts: e9, chainId: t4, isUnlocked: false };
    n3._initializeState(r3), n3.emit("chainChanged", t4), n3.emit("accountsChanged", e9);
  })), n2(So.AUTHORIZED, () => c(this, void 0, void 0, function* () {
    var t4, n3, r3, i2;
    try {
      Iu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' closing modals", e8.pendingModal, e8.installModal);
      const o = Gu.getProvider();
      o._setConnected(), null === (n3 = null === (t4 = e8.pendingModal) || void 0 === t4 ? void 0 : t4.unmount) || void 0 === n3 || n3.call(t4), null === (i2 = null === (r3 = e8.installModal) || void 0 === r3 ? void 0 : r3.unmount) || void 0 === i2 || i2.call(r3, false), e8.otpAnswer = void 0, e8.authorized = true, Iu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' provider.state", o.getState()), yield o.forceInitializeState();
    } catch (e9) {
    }
  })), n2(So.TERMINATE, () => {
    var t4, n3, r3, i2, o;
    null === (n3 = null === (t4 = e8.pendingModal) || void 0 === t4 ? void 0 : t4.unmount) || void 0 === n3 || n3.call(t4), null === (i2 = null === (r3 = e8.installModal) || void 0 === r3 ? void 0 : r3.unmount) || void 0 === i2 || i2.call(r3, true), e8.pendingModal = void 0, e8.installModal = void 0, e8.otpAnswer = void 0, null === (o = e8.connector) || void 0 === o || o.disconnect({ terminate: true }), e8.authorized = false;
    Gu.getProvider().handleDisconnect({ terminate: true }), ef(e8), Iu("[RemoteConnection: setupListeners()] All listeners cleaned up");
  }));
}
function rf(e8, t3, { initialCheck: r3, connectWith: i2 } = {}) {
  var o, s, a, l3, d3, u2, h3, f2, p3, g3, m2, y3, v2, b3, w2, E2, S3, _3, C3;
  return c(this, void 0, void 0, function* () {
    try {
      if (Xh(e8, t3), !e8.connector) throw new Error("no connector defined");
      nf(e8);
      const k3 = Gu.getProvider();
      e8.authorized = false, k3.emit("connecting");
      const A3 = yield null === (o = e8.connector) || void 0 === o ? void 0 : o.originatorSessionConnect();
      Iu(`[RemoteConnection: startConnection()] after originatorSessionConnect initialCheck=${r3}`, A3);
      let x3 = null !== (s = null == A3 ? void 0 : A3.channelId) && void 0 !== s ? s : "", M3 = null !== (l3 = null === (a = e8.connector.getKeyInfo()) || void 0 === a ? void 0 : a.ecies.public) && void 0 !== l3 ? l3 : "", I3 = null !== (u2 = null === (d3 = e8.connector.getKeyInfo()) || void 0 === d3 ? void 0 : d3.ecies.private) && void 0 !== u2 ? u2 : "";
      if (r3 && !A3) return Promise.resolve();
      if (!A3 && !r3) {
        const t4 = yield e8.connector.generateChannelIdConnect();
        x3 = null !== (h3 = t4.channelId) && void 0 !== h3 ? h3 : "", M3 = null !== (f2 = t4.pubKey) && void 0 !== f2 ? f2 : "", I3 = null !== (p3 = t4.privKey) && void 0 !== p3 ? p3 : "";
        const n2 = Date.now();
        null === (g3 = e8.connector.state.storageManager) || void 0 === g3 || g3.persistChannelConfig({ channelId: x3, localKey: I3, lastActive: n2, validUntil: n2 + go });
      }
      if (r3 && (null == A3 ? void 0 : A3.channelId)) return (null === (m2 = e8.connector) || void 0 === m2 ? void 0 : m2.isConnected()) || (Iu(`[RemoteConnection: startConnection()] reconnecting to channel initialCheck=${r3}`, A3), yield null === (y3 = e8.connector) || void 0 === y3 ? void 0 : y3.connectToChannel({ channelId: x3 })), Promise.resolve();
      A3 && !(null === (v2 = e8.connector) || void 0 === v2 ? void 0 : v2.isConnected()) && (Iu("[RemoteConnection: startConnection()] reconnecting to channel", A3), yield null === (b3 = e8.connector) || void 0 === b3 ? void 0 : b3.connectToChannel({ channelId: x3 }));
      const T2 = (null === (w2 = e8.platformManager) || void 0 === w2 ? void 0 : w2.isSecure()) ? "" : "&t=q", R3 = Xu.version, { iconUrl: P3, name: O3, url: N3, scheme: L3 } = t3.dappMetadata || {}, D3 = null === (E2 = e8.platformManager) || void 0 === E2 ? void 0 : E2.getPlatformType();
      let $3 = "N/A";
      "undefined" != typeof window && window.location && window.location.hostname ? $3 = window.location.hostname : void 0 !== O3 ? $3 = O3 : void 0 !== N3 && ($3 = N3);
      const B3 = { url: null != N3 ? N3 : "", title: null != O3 ? O3 : "", icon: P3, scheme: null != L3 ? L3 : "", apiVersion: R3, dappId: $3 || N3 || "N/A", anonId: t3.anonId, platform: null != D3 ? D3 : "", source: null !== (S3 = t3._source) && void 0 !== S3 ? S3 : "" }, K3 = bh(JSON.stringify(B3));
      let j3 = `channelId=${x3}&v=2&comm=${null !== (_3 = e8.communicationLayerPreference) && void 0 !== _3 ? _3 : ""}&pubkey=${M3}${T2}&originatorInfo=${K3}`;
      if (i2) {
        j3 += `&rpc=${bh(JSON.stringify(i2))}`;
        const t4 = e8.connector.getRPCMethodTracker();
        t4 && (t4[`${i2.id}`] = Object.assign(Object.assign({}, i2), { id: `${i2.id}`, timestamp: Date.now() }));
      }
      const U3 = encodeURI(j3), H3 = `${e8.useDeeplink ? nh : th}?${j3}`;
      if (e8.qrcodeLink = H3, e8.developerMode && Iu(`[RemoteConnection: startConnection()] qrcodeLink=${U3}`), k3.emit("display_uri", H3), import_sdk_analytics.analytics.track("sdk_connection_initiated", { transport_type: "websocket" }), null === (C3 = e8.platformManager) || void 0 === C3 ? void 0 : C3.isSecure()) {
        const t4 = setTimeout(() => {
          import_sdk_analytics.analytics.track("sdk_connection_failed", { transport_type: "websocket" });
        }, 6e4);
        return yield function(e9, t5) {
          var n2, r4;
          return c(this, void 0, void 0, function* () {
            const i3 = `${th}?${t5}`, o2 = `${nh}?${t5}`;
            null === (r4 = null === (n2 = e9.platformManager) || void 0 === n2 ? void 0 : n2.openDeeplink) || void 0 === r4 || r4.call(n2, i3, o2, "_self");
          });
        }(e8, U3), new Promise((n2, r4) => {
          var i3, o2, s2;
          if (null === (i3 = e8.connector) || void 0 === i3 ? void 0 : i3.isAuthorized()) return clearTimeout(t4), void n2();
          null === (o2 = e8.connector) || void 0 === o2 || o2.once(So.AUTHORIZED, () => {
            clearTimeout(t4), n2();
          }), null === (s2 = e8.connector) || void 0 === s2 || s2.once(So.REJECTED, () => {
            clearTimeout(t4), r4(So.REJECTED);
          });
        });
      }
      return tf(e8, t3, U3);
    } catch (e9) {
      throw console.error("[startConnection] error", e9), e9;
    }
  });
}
var of = class {
  constructor(e8) {
    var t3, n2, r3;
    this.state = { connector: void 0, qrcodeLink: void 0, analytics: void 0, developerMode: false, authorized: false, reconnection: false, preferDesktop: false, deeplinkProtocol: false, listeners: [], communicationLayerPreference: void 0, platformManager: void 0, pendingModal: void 0, installModal: void 0, otpAnswer: void 0 }, this.options = e8;
    const i2 = true === (null === (t3 = e8.logging) || void 0 === t3 ? void 0 : t3.developerMode) || true === (null === (n2 = e8.logging) || void 0 === n2 ? void 0 : n2.sdk);
    this.state.developerMode = i2, this.state.analytics = e8.analytics, this.state.preferDesktop = null !== (r3 = e8.preferDesktop) && void 0 !== r3 && r3, this.state.useDeeplink = e8.sdk.options.useDeeplink, this.state.communicationLayerPreference = e8.communicationLayerPreference, this.state.platformManager = e8.platformManager, e8.modals.install || (e8.modals.install = Jh), e8.modals.otp || (e8.modals.otp = Qh);
  }
  startConnection(e8) {
    return c(this, void 0, void 0, function* () {
      return rf(this.state, this.options, e8);
    });
  }
  initRemoteCommunication({ sdkInstance: e8 }) {
    var t3, n2, r3;
    return c(this, void 0, void 0, function* () {
      const i2 = yield null === (n2 = null === (t3 = e8.options.storage) || void 0 === t3 ? void 0 : t3.storageManager) || void 0 === n2 ? void 0 : n2.getPersistedChannelConfig();
      if (!this.options.ecies) {
        const e9 = { privateKey: null == i2 ? void 0 : i2.localKey };
        this.options.ecies = e9;
      }
      Xh(this.state, this.options), yield null === (r3 = this.getConnector()) || void 0 === r3 ? void 0 : r3.initFromDappStorage(), nf(this.state, this.options);
    });
  }
  showActiveModal() {
    return function(e8) {
      var t3, n2, r3, i2;
      e8.authorized ? Iu("[RemoteConnection: showActiveModal()] already authorized") : e8.pendingModal ? null === (n2 = (t3 = e8.pendingModal).mount) || void 0 === n2 || n2.call(t3) : e8.installModal && (null === (i2 = (r3 = e8.installModal).mount) || void 0 === i2 || i2.call(r3, e8.qrcodeLink || ""));
    }(this.state);
  }
  closeModal() {
    var e8, t3, n2, r3;
    null === (t3 = null === (e8 = this.state.pendingModal) || void 0 === e8 ? void 0 : e8.unmount) || void 0 === t3 || t3.call(e8), null === (r3 = null === (n2 = this.state.installModal) || void 0 === n2 ? void 0 : n2.unmount) || void 0 === r3 || r3.call(n2, false);
  }
  getUniversalLink() {
    if (!this.state.qrcodeLink) throw new Error("connection not started. run startConnection() first.");
    return this.state.qrcodeLink;
  }
  getChannelConfig() {
    var e8;
    return null === (e8 = this.state.connector) || void 0 === e8 ? void 0 : e8.getChannelConfig();
  }
  getKeyInfo() {
    var e8;
    return null === (e8 = this.state.connector) || void 0 === e8 ? void 0 : e8.getKeyInfo();
  }
  getConnector() {
    if (!this.state.connector) throw new Error("invalid remote connector");
    return this.state.connector;
  }
  getPlatformManager() {
    if (!this.state.platformManager) throw new Error("PlatformManager not available");
    return this.state.platformManager;
  }
  isConnected() {
    var e8;
    return (null === (e8 = this.state.connector) || void 0 === e8 ? void 0 : e8.isReady()) || false;
  }
  isAuthorized() {
    var e8;
    return (null === (e8 = this.state.connector) || void 0 === e8 ? void 0 : e8.isAuthorized()) || false;
  }
  isPaused() {
    var e8;
    return null === (e8 = this.state.connector) || void 0 === e8 ? void 0 : e8.isPaused();
  }
  disconnect(e8) {
    var t3, n2, r3;
    Iu("[RemoteConnection: disconnect()]", e8), (null == e8 ? void 0 : e8.terminate) && (Gu.getProvider().handleDisconnect({ terminate: true }), null === (n2 = null === (t3 = this.state.pendingModal) || void 0 === t3 ? void 0 : t3.unmount) || void 0 === n2 || n2.call(t3), this.state.otpAnswer = void 0), null === (r3 = this.state.connector) || void 0 === r3 || r3.disconnect(e8), function(e9) {
      Iu("[RemoteConnection: cleanupConnector()] cleaning up connector"), e9.connector && (ef(e9), e9.connector.disconnect({ terminate: true }).catch((e10) => {
        Iu("[RemoteConnection: cleanupConnector()] error disconnecting connector", e10);
      }));
    }(this.state);
  }
};
function sf(e8) {
  var r3, i2, o, s, a, l3, d3, u2, h3, f2, p3;
  return c(this, void 0, void 0, function* () {
    const { options: g3 } = e8;
    if (g3.logging = null !== (r3 = g3.logging) && void 0 !== r3 ? r3 : {}, g3.communicationLayerPreference = null !== (i2 = g3.communicationLayerPreference) && void 0 !== i2 ? i2 : jo.SOCKET, void 0 !== g3.enableDebug && (import_debug.default.enable("MM_SDK"), console.warn("enableDebug is removed. Please use enableAnalytics instead.")), g3.enableAnalytics = null === (o = g3.enableAnalytics) || void 0 === o || o, g3.injectProvider = null === (s = g3.injectProvider) || void 0 === s || s, g3.shouldShimWeb3 = null === (a = g3.shouldShimWeb3) || void 0 === a || a, g3.extensionOnly = null === (l3 = g3.extensionOnly) || void 0 === l3 || l3, g3.useDeeplink = null === (d3 = g3.useDeeplink) || void 0 === d3 || d3, g3.storage = null !== (u2 = g3.storage) && void 0 !== u2 ? u2 : { enabled: true }, g3.headless) {
      (0, import_debug.default)("[MetaMaskSDK: performSDKInitialization()] headless mode enabled");
      const e9 = () => {
      }, n2 = { install: () => ({ mount: e9, unmount: e9 }) }, r4 = { installer: e9 };
      g3.modals = n2, g3.ui = r4;
    }
    const m2 = true === (null === (h3 = g3.logging) || void 0 === h3 ? void 0 : h3.developerMode);
    e8.debug = (null === (f2 = g3.logging) || void 0 === f2 ? void 0 : f2.sdk) || m2, Iu("[MetaMaskSDK: performSDKInitialization()] options", e8.options);
    const y3 = Object.assign({}, g3.logging);
    m2 && (y3.sdk = true, y3.eciesLayer = true, y3.keyExchangeLayer = true, y3.remoteLayer = true, y3.serviceLayer = true, y3.plaintext = true), yield function(e9) {
      var t3;
      return c(this, void 0, void 0, function* () {
        const { options: n2 } = e9;
        e9.platformManager = new Yu({ useDeepLink: null !== (t3 = n2.useDeeplink) && void 0 !== t3 && t3, preferredOpenLink: n2.openDeeplink, debug: e9.debug });
      });
    }(e8), yield function(e9) {
      var t3, n2, r4, i3, o2;
      return c(this, void 0, void 0, function* () {
        const { options: s2 } = e9, a2 = null === (t3 = e9.platformManager) || void 0 === t3 ? void 0 : t3.getPlatformType();
        e9.analytics = new xh({ serverUrl: null !== (n2 = s2.communicationServerUrl) && void 0 !== n2 ? n2 : fo, enabled: s2.enableAnalytics, originatorInfo: { url: null !== (r4 = s2.dappMetadata.url) && void 0 !== r4 ? r4 : "", title: null !== (i3 = s2.dappMetadata.name) && void 0 !== i3 ? i3 : "", dappId: e9.getDappId(), platform: null != a2 ? a2 : "", source: null !== (o2 = s2._source) && void 0 !== o2 ? o2 : "", anonId: "" } });
      });
    }(e8), yield function(e9) {
      var t3, r4, i3;
      return c(this, void 0, void 0, function* () {
        if (!e9.options.enableAnalytics) return;
        if (!(null === (t3 = e9.platformManager) || void 0 === t3 ? void 0 : t3.isBrowser()) && !(null === (r4 = e9.platformManager) || void 0 === r4 ? void 0 : r4.isReactNative())) return;
        const o2 = e9.getVersion(), s2 = e9.getDappId(), a2 = yield e9.getAnonId(), c2 = null === (i3 = e9.platformManager) || void 0 === i3 ? void 0 : i3.getPlatformType(), l4 = e9.options._source;
        import_sdk_analytics.analytics.setGlobalProperty("sdk_version", o2), import_sdk_analytics.analytics.setGlobalProperty("dapp_id", s2), import_sdk_analytics.analytics.setGlobalProperty("anon_id", a2), import_sdk_analytics.analytics.setGlobalProperty("platform", c2), import_sdk_analytics.analytics.setGlobalProperty("integration_type", l4), import_sdk_analytics.analytics.enable(), import_sdk_analytics.analytics.track("sdk_initialized", {});
      });
    }(e8), yield function(e9) {
      var t3;
      return c(this, void 0, void 0, function* () {
        const { options: n2 } = e9;
        true !== (null === (t3 = n2.storage) || void 0 === t3 ? void 0 : t3.enabled) || n2.storage.storageManager || (n2.storage.storageManager = yield Zu(n2.storage));
      });
    }(e8), yield function(e9) {
      return c(this, void 0, void 0, function* () {
        const { options: t3 } = e9, n2 = /^(http|https):\/\/[^\s]*$/;
        if (t3.dappMetadata) {
          t3.dappMetadata.iconUrl && !n2.test(t3.dappMetadata.iconUrl) && (console.warn("Invalid dappMetadata.iconUrl: URL must start with http:// or https://"), t3.dappMetadata.iconUrl = void 0), t3.dappMetadata.base64Icon && t3.dappMetadata.base64Icon.length > Ih && (console.warn("Invalid dappMetadata.base64Icon: Base64-encoded icon string length must be less than 163400 characters"), t3.dappMetadata.base64Icon = void 0), t3.dappMetadata.url && !n2.test(t3.dappMetadata.url) && console.warn("Invalid dappMetadata.url: URL must start with http:// or https://");
          const e10 = Mh();
          if (e10 && !t3.dappMetadata.iconUrl && !t3.dappMetadata.base64Icon) {
            const n3 = `${window.location.protocol}//${window.location.host}${e10}`;
            t3.dappMetadata.iconUrl = n3;
          }
        }
        e9.dappMetadata = t3.dappMetadata;
      });
    }(e8), yield Lh(e8), yield Dh(e8);
    const { metamaskBrowserExtension: v2, preferExtension: b3, shouldReturn: w2 } = yield function(e9) {
      var t3, n2, r4, i3;
      return c(this, void 0, void 0, function* () {
        const { options: o2 } = e9;
        let s2, a2 = false, l4 = false;
        if ("undefined" != typeof window && window.ethereum && !(null === (t3 = e9.platformManager) || void 0 === t3 ? void 0 : t3.isMetaMaskMobileWebView())) {
          a2 = "extension" === localStorage.getItem(dh);
          try {
            s2 = yield Nh({ mustBeMetaMask: true, sdkInstance: e9 }), window.extension = s2, s2.on(fh.CHAIN_CHANGED, (t4) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE chainChanged chainId=${t4}`), Boolean(e9.sdkProvider) && e9.getMobileProvider().emit(fh.CHAIN_CHANGED, t4);
            }), s2.on(fh.ACCOUNTS_CHANGED, (t4) => c(this, void 0, void 0, function* () {
              var n3;
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE accountsChanged accounts=${t4}`);
              const r5 = Boolean(e9.sdkProvider), i4 = Boolean(e9.extensionActive);
              if (r5 && e9.getMobileProvider().emit(fh.ACCOUNTS_CHANGED, t4), i4 && 0 === (null == t4 ? void 0 : t4.length) && 0 === (yield null === (n3 = e9.getProvider()) || void 0 === n3 ? void 0 : n3.request({ method: oh.WALLET_GETPERMISSIONS, params: [] })).length) try {
                yield e9.terminate();
              } catch (e10) {
                Iu("[MetaMaskSDK: setupExtensionPreferences()] error terminating on permissions revoked", e10);
              }
            })), s2.on(fh.DISCONNECT, (t4) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE disconnect error=${t4}`), Boolean(e9.sdkProvider) && e9.getMobileProvider().emit(fh.DISCONNECT, t4);
            }), s2.on(fh.CONNECT, (t4) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connect args=${t4}`), Boolean(e9.sdkProvider) && e9.getMobileProvider().emit(fh.CONNECT, t4);
            }), s2.on(fh.CONNECTED, (t4) => {
              Iu("[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connected", t4), Boolean(e9.sdkProvider) && e9.getMobileProvider().emit(fh.CONNECTED, t4);
            });
          } catch (e10) {
            window.extension = void 0;
          }
        } else (null === (n2 = e9.platformManager) || void 0 === n2 ? void 0 : n2.isMetaMaskMobileWebView()) && (null === (r4 = e9.analytics) || void 0 === r4 || r4.send({ event: Ao.SDK_USE_INAPP_BROWSER }), e9.activeProvider = Ph({ provider: window.ethereum, sdkInstance: e9 }), e9._initialized = true, l4 = true);
        return s2 && o2.extensionOnly && (Iu("[MetaMaskSDK: setupExtensionPreferences()] EXTENSION ONLY --- prevent sdk initialization"), null === (i3 = e9.analytics) || void 0 === i3 || i3.send({ event: Ao.SDK_USE_EXTENSION }), e9.activeProvider = s2, e9.extensionActive = true, e9.extension = s2, e9._initialized = true, l4 = true), { preferExtension: a2, shouldReturn: l4, metamaskBrowserExtension: s2 };
      });
    }(e8);
    if (w2) Iu("[MetaMaskSDK: performSDKInitialization()] shouldReturn=true --- prevent sdk initialization");
    else {
      yield function(e9, t3) {
        var n2, r4, i3, o2, s2;
        return c(this, void 0, void 0, function* () {
          const { options: a2 } = e9, c2 = Object.assign({}, a2.logging);
          e9.remoteConnection = new of({ anonId: yield e9.getAnonId(), preferDesktop: null !== (n2 = a2.preferDesktop) && void 0 !== n2 && n2, communicationLayerPreference: null !== (r4 = a2.communicationLayerPreference) && void 0 !== r4 ? r4 : jo.SOCKET, analytics: e9.analytics, dappMetadata: a2.dappMetadata, _source: a2._source, enableAnalytics: null === (i3 = a2.enableAnalytics) || void 0 === i3 || i3, timer: a2.timer, sdk: e9, platformManager: e9.platformManager, transports: a2.transports, communicationServerUrl: a2.communicationServerUrl, storage: null !== (o2 = a2.storage) && void 0 !== o2 ? o2 : { enabled: true }, getMetaMaskInstaller: () => {
            if (!e9.installer) throw new Error("Invalid SDK status -- installer not initialized");
            return e9.installer;
          }, logging: c2, connectWithExtensionProvider: void 0 === t3 ? void 0 : () => vh(e9), modals: Object.assign(Object.assign({}, a2.modals), { onPendingModalDisconnect: e9.terminate.bind(e9) }) }), yield e9.remoteConnection.initRemoteCommunication({ sdkInstance: e9 }), e9.installer = new Yh({ remote: e9.remoteConnection, preferDesktop: null !== (s2 = a2.preferDesktop) && void 0 !== s2 && s2, platformManager: e9.platformManager, debug: e9.debug });
        });
      }(e8, v2), yield kh(e8), yield function(e9, t3) {
        var n2, r4;
        return c(this, void 0, void 0, function* () {
          const { options: i3 } = e9;
          t3 ? (Iu("[MetaMaskSDK: handleAutoAndExtensionConnections()] preferExtension is detected -- connect with it."), null === (n2 = e9.analytics) || void 0 === n2 || n2.send({ event: Ao.SDK_EXTENSION_UTILIZED }), vh(e9).catch((e10) => {
            console.warn("Can't connect with MetaMask extension...", e10), localStorage.removeItem(dh);
          })) : i3.checkInstallationImmediately && ((null === (r4 = e9.platformManager) || void 0 === r4 ? void 0 : r4.isDesktopWeb()) ? (Iu("[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately"), e9.connect().catch((e10) => {
            Iu(`[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- error on autoconnect _err=${e10}`);
          })) : console.warn("[handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- only for web desktop")), e9._initialized = true;
        });
      }(e8, b3);
      try {
        yield null === (p3 = e8.remoteConnection) || void 0 === p3 ? void 0 : p3.startConnection({ initialCheck: true });
      } catch (e9) {
        console.error("[MetaMaskSDK: setupRemoteConnectionAndInstaller()] Error while checking installation", e9);
      }
      e8.emit(Vu.ProviderUpdate, gh.INITIALIZED);
    }
  });
}
var af = class extends import_eventemitter2.default {
  constructor(e8 = { storage: { enabled: true }, injectProvider: true, forceInjectProvider: false, enableAnalytics: true, shouldShimWeb3: true, useDeeplink: true, extensionOnly: true, headless: false, dappMetadata: { name: "", url: "", iconUrl: "" }, _source: eh, i18nOptions: { enabled: false } }) {
    var n2, r3, i2;
    super(), this.extensionActive = false, this._initialized = false, this.sdkInitPromise = void 0, this.debug = false, this.readonlyRPCCalls = false, this.availableLanguages = ["en"], this.ANON_ID_STORAGE_KEY = "mm-sdk-anon-id", import_debug.default.disable();
    const o = true === (null === (n2 = e8.logging) || void 0 === n2 ? void 0 : n2.developerMode);
    if (((null === (r3 = e8.logging) || void 0 === r3 ? void 0 : r3.sdk) || o) && import_debug.default.enable("MM_SDK"), Iu("[MetaMaskSDK: constructor()]: begin."), this.setMaxListeners(50), !(null === (i2 = e8.dappMetadata) || void 0 === i2 ? void 0 : i2.url)) {
      if ("undefined" == typeof window || "undefined" == typeof document) throw new Error("You must provide dAppMetadata url");
      e8.dappMetadata = Object.assign(Object.assign({}, e8.dappMetadata), { url: `${window.location.protocol}//${window.location.host}` });
    }
    this.options = e8, this.options._source || (e8._source = eh), this.init().then(() => {
      Iu("[MetaMaskSDK: constructor()]: initialized successfully."), "undefined" != typeof window && (window.mmsdk = this);
    }).catch((e9) => {
      console.error("[MetaMaskSDK: constructor()] error during initialization", e9);
    });
  }
  init() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        var t3;
        return c(this, void 0, void 0, function* () {
          if ("undefined" != typeof window && (null === (t3 = window.mmsdk) || void 0 === t3 ? void 0 : t3.isInitialized())) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), Promise.resolve(window.mmsdk);
          if (e8._initialized) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), e8.sdkInitPromise;
          if (e8.sdkInitPromise) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initializing"), e8.sdkInitPromise;
          try {
            e8.sdkInitPromise = sf(e8), yield e8.sdkInitPromise;
          } catch (e9) {
            throw console.error(e9), e9;
          }
          return e8.sdkInitPromise;
        });
      }(this);
    });
  }
  isExtensionActive() {
    return this.extensionActive;
  }
  checkExtensionAvailability() {
    var e8;
    return "undefined" != typeof window && Boolean(null === (e8 = window.ethereum) || void 0 === e8 ? void 0 : e8.isMetaMask);
  }
  connect() {
    return c(this, void 0, void 0, function* () {
      return function(e8) {
        return c(this, void 0, void 0, function* () {
          if (e8._initialized || (Iu("[MetaMaskSDK: connect()] provider not ready -- wait for init()"), yield e8.init()), Iu(`[MetaMaskSDK: connect()] isExtensionActive=${e8.isExtensionActive()} activeProvider`, e8.activeProvider), !e8.activeProvider) throw new Error("SDK state invalid -- undefined provider");
          const t3 = e8.activeProvider.getSelectedAddress();
          return t3 ? [t3] : e8.activeProvider.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
        });
      }(this);
    });
  }
  connectAndSign({ msg: e8 }) {
    return c(this, void 0, void 0, function* () {
      return yh({ instance: this, msg: e8 });
    });
  }
  connectWith(e8) {
    return c(this, void 0, void 0, function* () {
      return function({ instance: e9, rpc: t3 }) {
        return c(this, void 0, void 0, function* () {
          if (e9._initialized || (Iu("[MetaMaskSDK: connectWith()] provider not ready -- wait for init()"), yield e9.init()), Iu(`[MetaMaskSDK: connectWith()] method: ${t3.method} rpc=${t3}`), !e9.activeProvider) throw new Error("SDK state invalid -- undefined provider");
          return e9.activeProvider.request({ method: oh.METAMASK_CONNECTWITH, params: [t3] });
        });
      }({ instance: this, rpc: e8 });
    });
  }
  resume() {
    return function(e8) {
      var t3, n2, r3;
      return c(this, void 0, void 0, function* () {
        if (!(null === (n2 = null === (t3 = e8.remoteConnection) || void 0 === t3 ? void 0 : t3.getConnector()) || void 0 === n2 ? void 0 : n2.isReady())) return Iu("[MetaMaskSDK: resume()] channel is not ready -- starting connection"), void (null === (r3 = e8.remoteConnection) || void 0 === r3 || r3.startConnection());
        Iu("[MetaMaskSDK: resume()] channel is ready");
      });
    }(this);
  }
  disconnect() {
    return console.warn("MetaMaskSDK.disconnect() is deprecated, use terminate()"), this.terminate();
  }
  isAuthorized() {
    var e8;
    null === (e8 = this.remoteConnection) || void 0 === e8 || e8.isAuthorized();
  }
  terminate() {
    return function(e8) {
      var t3, n2, r3;
      return c(this, void 0, void 0, function* () {
        if (!(null === (t3 = e8.platformManager) || void 0 === t3 ? void 0 : t3.isMetaMaskMobileWebView())) {
          if (mh && (window.localStorage.removeItem(dh), window.localStorage.removeItem(hh), window.localStorage.removeItem(uh)), e8.extensionActive) {
            try {
              yield null === (n2 = e8.activeProvider) || void 0 === n2 ? void 0 : n2.request({ method: oh.WALLET_REVOKEPERMISSIONS, params: [{ eth_accounts: {} }] });
            } catch (e9) {
              Iu("[MetaMaskSDK: terminate()] error revoking permissions", e9);
            }
            return e8.options.extensionOnly ? (e8.emit(Vu.ProviderUpdate, gh.TERMINATE), void Iu("[MetaMaskSDK: terminate()] extensionOnly --- prevent switching providers")) : (e8.activeProvider = e8.sdkProvider, window.ethereum = e8.activeProvider, e8.extensionActive = false, void e8.emit(Vu.ProviderUpdate, gh.TERMINATE));
          }
          e8.emit(Vu.ProviderUpdate, gh.TERMINATE), Iu(`[MetaMaskSDK: terminate()] remoteConnection=${e8.remoteConnection}`), null === (r3 = e8.remoteConnection) || void 0 === r3 || r3.disconnect({ terminate: true, sendMessage: true });
        }
      });
    }(this);
  }
  isInitialized() {
    return this._initialized;
  }
  setReadOnlyRPCCalls(e8) {
    this.readonlyRPCCalls = e8;
  }
  hasReadOnlyRPCCalls() {
    return this.readonlyRPCCalls;
  }
  getProvider() {
    if (this.activeProvider) return this.activeProvider;
    console.warn("MetaMaskSDK: No active provider found");
  }
  getMobileProvider() {
    if (!this.sdkProvider) throw new Error("SDK state invalid -- undefined mobile provider");
    return this.sdkProvider;
  }
  getUniversalLink() {
    var e8;
    const t3 = null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getUniversalLink();
    if (!t3) throw new Error("No Universal Link available, please call eth_requestAccounts first.");
    return t3;
  }
  getChannelId() {
    var e8, t3;
    return null === (t3 = null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getChannelConfig()) || void 0 === t3 ? void 0 : t3.channelId;
  }
  getRPCHistory() {
    var e8, t3;
    return null === (t3 = null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getConnector()) || void 0 === t3 ? void 0 : t3.getRPCMethodTracker();
  }
  getVersion() {
    return Xu.version;
  }
  getDappId() {
    var e8, t3, n2, r3;
    return "undefined" == typeof window || void 0 === window.location ? null !== (r3 = null !== (t3 = null === (e8 = this.options.dappMetadata) || void 0 === e8 ? void 0 : e8.name) && void 0 !== t3 ? t3 : null === (n2 = this.options.dappMetadata) || void 0 === n2 ? void 0 : n2.url) && void 0 !== r3 ? r3 : "N/A" : window.location.hostname;
  }
  getAnonId() {
    var e8, t3;
    return c(this, void 0, void 0, function* () {
      if (this._anonId) return this._anonId;
      let n2;
      return n2 = (null === (e8 = this.platformManager) || void 0 === e8 ? void 0 : e8.isBrowser()) ? this.getBrowserAnonId() : (null === (t3 = this.platformManager) || void 0 === t3 ? void 0 : t3.isReactNative()) ? yield this.getReactNativeAnonId() : v4_default(), this._anonId = n2, n2;
    });
  }
  getBrowserAnonId() {
    const e8 = this.ANON_ID_STORAGE_KEY;
    try {
      const t3 = localStorage.getItem(e8);
      if (t3) return t3;
      const n2 = v4_default();
      return localStorage.setItem(e8, n2), n2;
    } catch (e9) {
      return console.error("[MetaMaskSDK: getBrowserAnonId()] LocalStorage access error:", e9), v4_default();
    }
  }
  getReactNativeAnonId() {
    return c(this, void 0, void 0, function* () {
      const e8 = this.ANON_ID_STORAGE_KEY;
      try {
        const t3 = __require("@react-native-async-storage/async-storage").default, n2 = yield t3.getItem(e8);
        if (n2) return n2;
        const r3 = v4_default();
        return yield t3.setItem(e8, r3), r3;
      } catch (e9) {
        return console.error("[MetaMaskSDK: getReactNativeAnonId()] Error accessing AsyncStorage:", e9), v4_default();
      }
    });
  }
  getWalletStatus() {
    var e8, t3;
    return null === (t3 = null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getConnector()) || void 0 === t3 ? void 0 : t3.getConnectionStatus();
  }
  _getChannelConfig() {
    var e8;
    return null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getChannelConfig();
  }
  _ping() {
    var e8, t3;
    null === (t3 = null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getConnector()) || void 0 === t3 || t3.ping();
  }
  _keyCheck() {
    var e8, t3;
    null === (t3 = null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getConnector()) || void 0 === t3 || t3.keyCheck();
  }
  _getServiceStatus() {
    var e8, t3;
    return null === (t3 = null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getConnector()) || void 0 === t3 ? void 0 : t3.getServiceStatus();
  }
  _getRemoteConnection() {
    return this.remoteConnection;
  }
  _getDappMetadata() {
    return this.dappMetadata;
  }
  _getKeyInfo() {
    var e8;
    return null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getKeyInfo();
  }
  _resetKeys() {
    var e8, t3;
    null === (t3 = null === (e8 = this.remoteConnection) || void 0 === e8 ? void 0 : e8.getConnector()) || void 0 === t3 || t3.resetKeys();
  }
  _getConnection() {
    return this.remoteConnection;
  }
  emit(e8, t3) {
    return super.emit(e8, t3);
  }
  on(e8, t3) {
    return super.on(e8, t3);
  }
};
var cf = Object.freeze({ __proto__: null, StorageManagerWeb: class {
  constructor({ enabled: e8 } = { enabled: false }) {
    this.enabled = false, this.enabled = e8;
  }
  persistChannelConfig(e8) {
    return c(this, void 0, void 0, function* () {
      const t3 = JSON.stringify(e8);
      Iu(`[StorageManagerWeb: persistChannelConfig()] enabled=${this.enabled}`, e8), localStorage.setItem(lh, t3);
    });
  }
  getPersistedChannelConfig() {
    return c(this, void 0, void 0, function* () {
      let e8;
      try {
        if (Iu(`[StorageManagerWeb: getPersistedChannelConfig()] enabled=${this.enabled}`), e8 = localStorage.getItem(lh), Iu("[StorageManagerWeb: getPersistedChannelConfig()]", e8), !e8) return;
        const t3 = JSON.parse(e8);
        return Iu("[StorageManagerWeb: getPersistedChannelConfig()] channelConfig", t3), t3;
      } catch (e9) {
        return void console.error("[StorageManagerWeb: getPersistedChannelConfig()] Can't find existing channel config", e9);
      }
    });
  }
  persistAccounts(e8) {
    return c(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: persistAccounts()] enabled=${this.enabled}`, e8);
      const t3 = JSON.stringify(e8);
      localStorage.setItem(uh, t3);
    });
  }
  getCachedAccounts() {
    return c(this, void 0, void 0, function* () {
      try {
        const e8 = localStorage.getItem(uh);
        return e8 ? JSON.parse(e8) : [];
      } catch (e8) {
        throw console.error("[StorageManagerWeb: getCachedAccounts()] Error reading cached accounts", e8), e8;
      }
    });
  }
  persistChainId(e8) {
    return c(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: persistChainId()] enabled=${this.enabled}`, e8), localStorage.setItem(hh, e8);
    });
  }
  getCachedChainId() {
    return c(this, void 0, void 0, function* () {
      try {
        const e8 = localStorage.getItem(hh);
        return null != e8 ? e8 : void 0;
      } catch (e8) {
        throw console.error("[StorageManagerWeb: getCachedChainId()] Error reading cached chainId", e8), e8;
      }
    });
  }
  terminate() {
    return c(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: terminate()] enabled=${this.enabled}`), localStorage.removeItem(lh);
    });
  }
} });
var lf = "hydrated";
var df = false;
var uf = false;
var hf = true;
var ff = Object.defineProperty;
var pf = /* @__PURE__ */ new WeakMap();
var gf = (e8) => pf.get(e8);
var mf = (e8, t3) => pf.set(t3.$lazyInstance$ = e8, t3);
var yf = (e8, t3) => t3 in e8;
var vf = (e8, t3) => (0, console.error)(e8, t3);
var bf = /* @__PURE__ */ new Map();
var wf = /* @__PURE__ */ new Map();
var Ef = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var Sf = "undefined" != typeof window ? window : {};
var _f = Sf.document || { head: {} };
var Cf = { $flags$: 0, $resourcesUrl$: "", jmp: (e8) => e8(), raf: (e8) => requestAnimationFrame(e8), ael: (e8, t3, n2, r3) => e8.addEventListener(t3, n2, r3), rel: (e8, t3, n2, r3) => e8.removeEventListener(t3, n2, r3), ce: (e8, t3) => new CustomEvent(e8, t3) };
var kf = (() => {
  try {
    return new CSSStyleSheet(), "function" == typeof new CSSStyleSheet().replaceSync;
  } catch (e8) {
  }
  return false;
})();
var Af = false;
var xf = [];
var Mf = [];
var If = (e8, t3) => (t4) => {
  e8.push(t4), Af || (Af = true, 4 & Cf.$flags$ ? Pf(Rf) : Cf.raf(Rf));
};
var Tf = (e8) => {
  for (let t3 = 0; t3 < e8.length; t3++) try {
    e8[t3](performance.now());
  } catch (e9) {
    vf(e9);
  }
  e8.length = 0;
};
var Rf = () => {
  Tf(xf), Tf(Mf), (Af = xf.length > 0) && Cf.raf(Rf);
};
var Pf = (e8) => ((e9) => Promise.resolve(e9))().then(e8);
var Of = If(Mf);
var Nf = {};
var Lf = (e8) => "object" === (e8 = typeof e8) || "function" === e8;
function Df(e8) {
  var t3, n2, r3;
  return null != (r3 = null == (n2 = null == (t3 = e8.head) ? void 0 : t3.querySelector('meta[name="csp-nonce"]')) ? void 0 : n2.getAttribute("content")) ? r3 : void 0;
}
((e8, t3) => {
  for (var n2 in t3) ff(e8, n2, { get: t3[n2], enumerable: true });
})({}, { err: () => Bf, map: () => Kf, ok: () => $f, unwrap: () => Hf, unwrapErr: () => Ff });
var $f = (e8) => ({ isOk: true, isErr: false, value: e8 });
var Bf = (e8) => ({ isOk: false, isErr: true, value: e8 });
function Kf(e8, t3) {
  if (e8.isOk) {
    const n2 = t3(e8.value);
    return n2 instanceof Promise ? n2.then((e9) => $f(e9)) : $f(n2);
  }
  if (e8.isErr) {
    const t4 = e8.value;
    return Bf(t4);
  }
  throw "should never get here";
}
var jf;
var Uf;
var Hf = (e8) => {
  if (e8.isOk) return e8.value;
  throw e8.value;
};
var Ff = (e8) => {
  if (e8.isErr) return e8.value;
  throw e8.value;
};
var zf = (e8, t3, ...n2) => {
  let r3 = null, i2 = false, o = false;
  const s = [], a = (t4) => {
    for (let n3 = 0; n3 < t4.length; n3++) r3 = t4[n3], Array.isArray(r3) ? a(r3) : null != r3 && "boolean" != typeof r3 && ((i2 = "function" != typeof e8 && !Lf(r3)) && (r3 = String(r3)), i2 && o ? s[s.length - 1].$text$ += r3 : s.push(i2 ? qf(null, r3) : r3), o = i2);
  };
  if (a(n2), t3) {
    const e9 = t3.className || t3.class;
    e9 && (t3.class = "object" != typeof e9 ? e9 : Object.keys(e9).filter((t4) => e9[t4]).join(" "));
  }
  if ("function" == typeof e8) return e8(null === t3 ? {} : t3, s, Vf);
  const c2 = qf(e8, null);
  return c2.$attrs$ = t3, s.length > 0 && (c2.$children$ = s), c2;
};
var qf = (e8, t3) => {
  const n2 = { $flags$: 0, $tag$: e8, $text$: t3, $elm$: null, $children$: null, $attrs$: null };
  return n2;
};
var Wf = {};
var Vf = { forEach: (e8, t3) => e8.map(Gf).forEach(t3), map: (e8, t3) => e8.map(Gf).map(t3).map(Yf) };
var Gf = (e8) => ({ vattrs: e8.$attrs$, vchildren: e8.$children$, vkey: e8.$key$, vname: e8.$name$, vtag: e8.$tag$, vtext: e8.$text$ });
var Yf = (e8) => {
  if ("function" == typeof e8.vtag) {
    const t4 = { ...e8.vattrs };
    return e8.vkey && (t4.key = e8.vkey), e8.vname && (t4.name = e8.vname), zf(e8.vtag, t4, ...e8.vchildren || []);
  }
  const t3 = qf(e8.vtag, e8.vtext);
  return t3.$attrs$ = e8.vattrs, t3.$children$ = e8.vchildren, t3.$key$ = e8.vkey, t3.$name$ = e8.vname, t3;
};
var Zf = (e8) => gf(e8).$hostElement$;
var Jf = (e8, t3, n2) => {
  const r3 = Zf(e8);
  return { emit: (e9) => Qf(r3, t3, { bubbles: !!(4 & n2), composed: !!(2 & n2), cancelable: !!(1 & n2), detail: e9 }) };
};
var Qf = (e8, t3, n2) => {
  const r3 = Cf.ce(t3, n2);
  return e8.dispatchEvent(r3), r3;
};
var Xf = /* @__PURE__ */ new WeakMap();
var ep = (e8) => {
  const t3 = e8.$cmpMeta$, n2 = e8.$hostElement$, r3 = t3.$flags$, i2 = (t3.$tagName$, () => {
  }), o = ((e9, t4, n3) => {
    var r4;
    const i3 = tp(t4), o2 = wf.get(i3);
    if (e9 = 11 === e9.nodeType ? e9 : _f, o2) if ("string" == typeof o2) {
      e9 = e9.head || e9;
      let n4, s = Xf.get(e9);
      if (s || Xf.set(e9, s = /* @__PURE__ */ new Set()), !s.has(i3)) {
        {
          n4 = _f.createElement("style"), n4.innerHTML = o2;
          const i4 = null != (r4 = Cf.$nonce$) ? r4 : Df(_f);
          if (null != i4 && n4.setAttribute("nonce", i4), !(1 & t4.$flags$)) if ("HEAD" === e9.nodeName) {
            const t5 = e9.querySelectorAll("link[rel=preconnect]"), r5 = t5.length > 0 ? t5[t5.length - 1].nextSibling : e9.querySelector("style");
            e9.insertBefore(n4, r5);
          } else if ("host" in e9) if (kf) {
            const t5 = new CSSStyleSheet();
            t5.replaceSync(o2), e9.adoptedStyleSheets = [t5, ...e9.adoptedStyleSheets];
          } else {
            const t5 = e9.querySelector("style");
            t5 ? t5.innerHTML = o2 + t5.innerHTML : e9.prepend(n4);
          }
          else e9.append(n4);
          1 & t4.$flags$ && "HEAD" !== e9.nodeName && e9.insertBefore(n4, null);
        }
        4 & t4.$flags$ && (n4.innerHTML += Ef), s && s.add(i3);
      }
    } else e9.adoptedStyleSheets.includes(o2) || (e9.adoptedStyleSheets = [...e9.adoptedStyleSheets, o2]);
    return i3;
  })(n2.shadowRoot ? n2.shadowRoot : n2.getRootNode(), t3);
  10 & r3 && 2 & r3 && (n2["s-sc"] = o, n2.classList.add(o + "-h")), i2();
};
var tp = (e8, t3) => "sc-" + e8.$tagName$;
var np = (e8, t3, n2, r3, i2, o) => {
  if (n2 !== r3) {
    let s = yf(e8, t3), a = t3.toLowerCase();
    if ("class" === t3) {
      const t4 = e8.classList, i3 = ip(n2), o2 = ip(r3);
      t4.remove(...i3.filter((e9) => e9 && !o2.includes(e9))), t4.add(...o2.filter((e9) => e9 && !i3.includes(e9)));
    } else if ("style" === t3) {
      for (const t4 in n2) r3 && null != r3[t4] || (t4.includes("-") ? e8.style.removeProperty(t4) : e8.style[t4] = "");
      for (const t4 in r3) n2 && r3[t4] === n2[t4] || (t4.includes("-") ? e8.style.setProperty(t4, r3[t4]) : e8.style[t4] = r3[t4]);
    } else if (s || "o" !== t3[0] || "n" !== t3[1]) {
      const a2 = Lf(r3);
      if ((s || a2 && null !== r3) && !i2) try {
        if (e8.tagName.includes("-")) e8[t3] = r3;
        else {
          const i3 = null == r3 ? "" : r3;
          "list" === t3 ? s = false : null != n2 && e8[t3] == i3 || ("function" == typeof e8.__lookupSetter__(t3) ? e8[t3] = i3 : e8.setAttribute(t3, i3));
        }
      } catch (e9) {
      }
      null == r3 || false === r3 ? false === r3 && "" !== e8.getAttribute(t3) || e8.removeAttribute(t3) : (!s || 4 & o || i2) && !a2 && (r3 = true === r3 ? "" : r3, e8.setAttribute(t3, r3));
    } else if (t3 = "-" === t3[2] ? t3.slice(3) : yf(Sf, a) ? a.slice(2) : a[2] + t3.slice(3), n2 || r3) {
      const i3 = t3.endsWith(op);
      t3 = t3.replace(sp, ""), n2 && Cf.rel(e8, t3, n2, i3), r3 && Cf.ael(e8, t3, r3, i3);
    }
  }
};
var rp = /\s/;
var ip = (e8) => e8 ? e8.split(rp) : [];
var op = "Capture";
var sp = new RegExp(op + "$");
var ap = (e8, t3, n2) => {
  const r3 = 11 === t3.$elm$.nodeType && t3.$elm$.host ? t3.$elm$.host : t3.$elm$, i2 = e8 && e8.$attrs$ || Nf, o = t3.$attrs$ || Nf;
  for (const e9 of cp(Object.keys(i2))) e9 in o || np(r3, e9, i2[e9], void 0, n2, t3.$flags$);
  for (const e9 of cp(Object.keys(o))) np(r3, e9, i2[e9], o[e9], n2, t3.$flags$);
};
function cp(e8) {
  return e8.includes("ref") ? [...e8.filter((e9) => "ref" !== e9), "ref"] : e8;
}
var lp = false;
var dp = false;
var up = (e8, t3, n2, r3) => {
  const i2 = t3.$children$[n2];
  let o, s, a = 0;
  if (null !== i2.$text$) o = i2.$elm$ = _f.createTextNode(i2.$text$);
  else {
    dp || (dp = "svg" === i2.$tag$), o = i2.$elm$ = _f.createElementNS(dp ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", !lp && uf && 2 & i2.$flags$ ? "slot-fb" : i2.$tag$), dp && "foreignObject" === i2.$tag$ && (dp = false), ap(null, i2, dp);
    if (!!o.getRootNode().querySelector("body") && df && ((e9) => null != e9)(jf) && o["s-si"] !== jf && o.classList.add(o["s-si"] = jf), i2.$children$) for (a = 0; a < i2.$children$.length; ++a) s = up(e8, i2, a), s && o.appendChild(s);
    "svg" === i2.$tag$ ? dp = false : "foreignObject" === o.tagName && (dp = true);
  }
  return o["s-hn"] = Uf, o;
};
var hp = (e8, t3, n2, r3, i2, o) => {
  let s, a = e8;
  for (a.shadowRoot && a.tagName === Uf && (a = a.shadowRoot); i2 <= o; ++i2) r3[i2] && (s = up(null, n2, i2), s && (r3[i2].$elm$ = s, mp(a, s, t3)));
};
var fp = (e8, t3, n2) => {
  for (let r3 = t3; r3 <= n2; ++r3) {
    const t4 = e8[r3];
    if (t4) {
      const e9 = t4.$elm$;
      e9 && e9.remove();
    }
  }
};
var pp = (e8, t3, n2 = false) => e8.$tag$ === t3.$tag$;
var gp = (e8, t3, n2 = false) => {
  const r3 = t3.$elm$ = e8.$elm$, i2 = e8.$children$, o = t3.$children$, s = t3.$tag$, a = t3.$text$;
  null === a ? (ap(e8, t3, dp = "svg" === s || "foreignObject" !== s && dp), null !== i2 && null !== o ? ((e9, t4, n3, r4, i3 = false) => {
    let o2, s2 = 0, a2 = 0, c2 = t4.length - 1, l3 = t4[0], d3 = t4[c2], u2 = r4.length - 1, h3 = r4[0], f2 = r4[u2];
    for (; s2 <= c2 && a2 <= u2; ) null == l3 ? l3 = t4[++s2] : null == d3 ? d3 = t4[--c2] : null == h3 ? h3 = r4[++a2] : null == f2 ? f2 = r4[--u2] : pp(l3, h3, i3) ? (gp(l3, h3, i3), l3 = t4[++s2], h3 = r4[++a2]) : pp(d3, f2, i3) ? (gp(d3, f2, i3), d3 = t4[--c2], f2 = r4[--u2]) : pp(l3, f2, i3) ? (gp(l3, f2, i3), mp(e9, l3.$elm$, d3.$elm$.nextSibling), l3 = t4[++s2], f2 = r4[--u2]) : pp(d3, h3, i3) ? (gp(d3, h3, i3), mp(e9, d3.$elm$, l3.$elm$), d3 = t4[--c2], h3 = r4[++a2]) : (o2 = up(t4 && t4[a2], n3, a2), h3 = r4[++a2], o2 && mp(l3.$elm$.parentNode, o2, l3.$elm$));
    s2 > c2 ? hp(e9, null == r4[u2 + 1] ? null : r4[u2 + 1].$elm$, n3, r4, a2, u2) : a2 > u2 && fp(t4, s2, c2);
  })(r3, i2, t3, o, n2) : null !== o ? (null !== e8.$text$ && (r3.textContent = ""), hp(r3, null, t3, o, 0, o.length - 1)) : !n2 && hf && null !== i2 && fp(i2, 0, i2.length - 1), dp && "svg" === s && (dp = false)) : e8.$text$ !== a && (r3.data = a);
};
var mp = (e8, t3, n2) => null == e8 ? void 0 : e8.insertBefore(t3, n2);
var yp = (e8, t3, n2 = false) => {
  const r3 = e8.$hostElement$, i2 = e8.$cmpMeta$, o = e8.$vnode$ || qf(null, null), s = (a = t3) && a.$tag$ === Wf ? t3 : zf(null, null, t3);
  var a;
  if (Uf = r3.tagName, n2 && s.$attrs$) for (const e9 of Object.keys(s.$attrs$)) r3.hasAttribute(e9) && !["key", "ref", "style", "class"].includes(e9) && (s.$attrs$[e9] = r3[e9]);
  s.$tag$ = null, s.$flags$ |= 4, e8.$vnode$ = s, s.$elm$ = o.$elm$ = r3.shadowRoot || r3, jf = r3["s-sc"], lp = 0 != (1 & i2.$flags$), gp(o, s, n2);
};
var vp = (e8, t3) => {
  t3 && !e8.$onRenderResolve$ && t3["s-p"] && t3["s-p"].push(new Promise((t4) => e8.$onRenderResolve$ = t4));
};
var bp = (e8, t3) => {
  if (e8.$flags$ |= 16, 4 & e8.$flags$) return void (e8.$flags$ |= 512);
  vp(e8, e8.$ancestorComponent$);
  return Of(() => wp(e8, t3));
};
var wp = (e8, t3) => {
  const n2 = e8.$hostElement$, r3 = (e8.$cmpMeta$.$tagName$, () => {
  }), i2 = e8.$lazyInstance$;
  if (!i2) throw new Error(`Can't render component <${n2.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);
  return r3(), Ep(void 0, () => _p(e8, i2, t3));
};
var Ep = (e8, t3) => Sp(e8) ? e8.then(t3).catch((e9) => {
  console.error(e9), t3();
}) : t3();
var Sp = (e8) => e8 instanceof Promise || e8 && e8.then && "function" == typeof e8.then;
var _p = async (e8, t3, n2) => {
  var r3;
  const i2 = e8.$hostElement$, o = (e8.$cmpMeta$.$tagName$, () => {
  }), s = i2["s-rc"];
  n2 && ep(e8);
  const a = (e8.$cmpMeta$.$tagName$, () => {
  });
  Cp(e8, t3, i2, n2), s && (s.map((e9) => e9()), i2["s-rc"] = void 0), a(), o();
  {
    const t4 = null != (r3 = i2["s-p"]) ? r3 : [], n3 = () => kp(e8);
    0 === t4.length ? n3() : (Promise.all(t4).then(n3), e8.$flags$ |= 4, t4.length = 0);
  }
};
var Cp = (e8, t3, n2, r3) => {
  try {
    t3 = t3.render(), e8.$flags$ &= -17, e8.$flags$ |= 2, yp(e8, t3, r3);
  } catch (t4) {
    vf(t4, e8.$hostElement$);
  }
  return null;
};
var kp = (e8) => {
  e8.$cmpMeta$.$tagName$;
  const t3 = e8.$hostElement$, n2 = () => {
  }, r3 = e8.$lazyInstance$, i2 = e8.$ancestorComponent$;
  64 & e8.$flags$ ? n2() : (e8.$flags$ |= 64, Mp(t3), xp(r3, "componentDidLoad"), n2(), e8.$onReadyResolve$(t3), i2 || Ap()), e8.$onRenderResolve$ && (e8.$onRenderResolve$(), e8.$onRenderResolve$ = void 0), 512 & e8.$flags$ && Pf(() => bp(e8, false)), e8.$flags$ &= -517;
};
var Ap = (e8) => {
  Mp(_f.documentElement), Pf(() => Qf(Sf, "appload", { detail: { namespace: "sdk-install-modal-web" } }));
};
var xp = (e8, t3, n2) => {
  if (e8 && e8[t3]) try {
    return e8[t3](n2);
  } catch (e9) {
    vf(e9);
  }
};
var Mp = (e8) => {
  var t3;
  return e8.classList.add(null != (t3 = lf) ? t3 : "hydrated");
};
var Ip = (e8, t3, n2, r3) => {
  const i2 = gf(e8);
  if (!i2) throw new Error(`Couldn't find host element for "${r3.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);
  const o = i2.$hostElement$, s = i2.$instanceValues$.get(t3), a = i2.$flags$, c2 = i2.$lazyInstance$;
  var l3, d3;
  l3 = n2, d3 = r3.$members$[t3][0], n2 = null == l3 || Lf(l3) ? l3 : 4 & d3 ? "false" !== l3 && ("" === l3 || !!l3) : 1 & d3 ? String(l3) : l3;
  const u2 = Number.isNaN(s) && Number.isNaN(n2);
  if ((!(8 & a) || void 0 === s) && (n2 !== s && !u2) && (i2.$instanceValues$.set(t3, n2), c2)) {
    if (r3.$watchers$ && 128 & a) {
      const e9 = r3.$watchers$[t3];
      e9 && e9.map((e10) => {
        try {
          c2[e10](n2, s, t3);
        } catch (e11) {
          vf(e11, o);
        }
      });
    }
    2 == (18 & a) && bp(i2, false);
  }
};
var Tp = (e8, t3, n2) => {
  var r3, i2;
  const o = e8.prototype;
  if (t3.$members$ || t3.$watchers$ || e8.watchers) {
    e8.watchers && !t3.$watchers$ && (t3.$watchers$ = e8.watchers);
    const s = Object.entries(null != (r3 = t3.$members$) ? r3 : {});
    if (s.map(([e9, [r4]]) => {
      (31 & r4 || 2 & n2 && 32 & r4) && Object.defineProperty(o, e9, { get() {
        return t4 = e9, gf(this).$instanceValues$.get(t4);
        var t4;
      }, set(n3) {
        Ip(this, e9, n3, t3);
      }, configurable: true, enumerable: true });
    }), 1 & n2) {
      const n3 = /* @__PURE__ */ new Map();
      o.attributeChangedCallback = function(e9, r4, i3) {
        Cf.jmp(() => {
          var s2;
          const a = n3.get(e9);
          if (this.hasOwnProperty(a)) i3 = this[a], delete this[a];
          else {
            if (o.hasOwnProperty(a) && "number" == typeof this[a] && this[a] == i3) return;
            if (null == a) {
              const n4 = gf(this), o2 = null == n4 ? void 0 : n4.$flags$;
              if (o2 && !(8 & o2) && 128 & o2 && i3 !== r4) {
                const o3 = n4.$lazyInstance$, a2 = null == (s2 = t3.$watchers$) ? void 0 : s2[e9];
                null == a2 || a2.forEach((t4) => {
                  null != o3[t4] && o3[t4].call(o3, i3, r4, e9);
                });
              }
              return;
            }
          }
          this[a] = (null !== i3 || "boolean" != typeof this[a]) && i3;
        });
      }, e8.observedAttributes = Array.from(/* @__PURE__ */ new Set([...Object.keys(null != (i2 = t3.$watchers$) ? i2 : {}), ...s.filter(([e9, t4]) => 15 & t4[0]).map(([e9, t4]) => {
        const r4 = t4[1] || e9;
        return n3.set(r4, e9), r4;
      })]));
    }
  }
  return e8;
};
var Rp = async (e8, t3, n2, r3) => {
  let i2;
  if (0 == (32 & t3.$flags$)) {
    t3.$flags$ |= 32;
    if (n2.$lazyBundleId$) {
      const e9 = ((e10, t4, n3) => {
        const r5 = e10.$tagName$.replace(/-/g, "_"), i3 = e10.$lazyBundleId$;
        if (!i3) return;
        const o2 = bf.get(i3);
        if (o2) return o2[r5];
        {
          const e11 = (e12) => (bf.set(i3, e12), e12[r5]);
          if ("mm-install-modal_3" === i3) return Promise.resolve().then(function() {
            return wg;
          }).then(e11, vf);
        }
        return /* webpackIgnore: true */ /* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ globImport_entry_js(`./${i3}.entry.js`).then((e11) => (bf.set(i3, e11), e11[r5]), vf);
      })(n2);
      if (e9 && "then" in e9) {
        const t4 = () => {
        };
        i2 = await e9, t4();
      } else i2 = e9;
      if (!i2) throw new Error(`Constructor for "${n2.$tagName$}#${t3.$modeName$}" was not found`);
      i2.isProxied || (n2.$watchers$ = i2.watchers, Tp(i2, n2, 2), i2.isProxied = true);
      const r4 = (n2.$tagName$, () => {
      });
      t3.$flags$ |= 8;
      try {
        new i2(t3);
      } catch (e10) {
        vf(e10);
      }
      t3.$flags$ &= -9, t3.$flags$ |= 128, r4(), Pp(t3.$lazyInstance$);
    } else {
      i2 = e8.constructor;
      const n3 = e8.localName;
      customElements.whenDefined(n3).then(() => t3.$flags$ |= 128);
    }
    if (i2 && i2.style) {
      let e9;
      "string" == typeof i2.style && (e9 = i2.style);
      const t4 = tp(n2);
      if (!wf.has(t4)) {
        const r4 = (n2.$tagName$, () => {
        });
        ((e10, t5, n3) => {
          let r5 = wf.get(e10);
          kf && n3 ? (r5 = r5 || new CSSStyleSheet(), "string" == typeof r5 ? r5 = t5 : r5.replaceSync(t5)) : r5 = t5, wf.set(e10, r5);
        })(t4, e9, !!(1 & n2.$flags$)), r4();
      }
    }
  }
  const o = t3.$ancestorComponent$, s = () => bp(t3, true);
  o && o["s-rc"] ? o["s-rc"].push(s) : s();
};
var Pp = (e8) => {
  xp(e8, "connectedCallback");
};
var Op = (e8) => {
  xp(e8, "disconnectedCallback");
};
var Np = (e8, t3 = {}) => {
  var n2;
  const r3 = () => {
  }, i2 = [], o = t3.exclude || [], s = Sf.customElements, a = _f.head, c2 = a.querySelector("meta[charset]"), l3 = _f.createElement("style"), d3 = [];
  let u2, h3 = true;
  Object.assign(Cf, t3), Cf.$resourcesUrl$ = new URL(t3.resourcesUrl || "./", _f.baseURI).href;
  let f2 = false;
  if (e8.map((e9) => {
    e9[1].map((t4) => {
      var n3;
      const r4 = { $flags$: t4[0], $tagName$: t4[1], $members$: t4[2], $listeners$: t4[3] };
      4 & r4.$flags$ && (f2 = true), r4.$members$ = t4[2], r4.$watchers$ = null != (n3 = t4[4]) ? n3 : {};
      const a2 = r4.$tagName$, c3 = class extends HTMLElement {
        constructor(e10) {
          if (super(e10), this.hasRegisteredEventListeners = false, ((e11, t5) => {
            const n4 = { $flags$: 0, $hostElement$: e11, $cmpMeta$: t5, $instanceValues$: /* @__PURE__ */ new Map() };
            n4.$onReadyPromise$ = new Promise((e12) => n4.$onReadyResolve$ = e12), e11["s-p"] = [], e11["s-rc"] = [], pf.set(e11, n4);
          })(e10 = this, r4), 1 & r4.$flags$) if (e10.shadowRoot) {
            if ("open" !== e10.shadowRoot.mode) throw new Error(`Unable to re-use existing shadow root for ${r4.$tagName$}! Mode is set to ${e10.shadowRoot.mode} but Stencil only supports open shadow roots.`);
          } else e10.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          gf(this), this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = true), u2 && (clearTimeout(u2), u2 = null), h3 ? d3.push(this) : Cf.jmp(() => ((e10) => {
            if (0 == (1 & Cf.$flags$)) {
              const t5 = gf(e10), n4 = t5.$cmpMeta$, r5 = (n4.$tagName$, () => {
              });
              if (1 & t5.$flags$) (null == t5 ? void 0 : t5.$lazyInstance$) ? Pp(t5.$lazyInstance$) : (null == t5 ? void 0 : t5.$onReadyPromise$) && t5.$onReadyPromise$.then(() => Pp(t5.$lazyInstance$));
              else {
                t5.$flags$ |= 1;
                {
                  let n5 = e10;
                  for (; n5 = n5.parentNode || n5.host; ) if (n5["s-p"]) {
                    vp(t5, t5.$ancestorComponent$ = n5);
                    break;
                  }
                }
                n4.$members$ && Object.entries(n4.$members$).map(([t6, [n5]]) => {
                  if (31 & n5 && e10.hasOwnProperty(t6)) {
                    const n6 = e10[t6];
                    delete e10[t6], e10[t6] = n6;
                  }
                }), Rp(e10, t5, n4);
              }
              r5();
            }
          })(this));
        }
        disconnectedCallback() {
          Cf.jmp(() => (async (e10) => {
            if (0 == (1 & Cf.$flags$)) {
              const t5 = gf(e10);
              (null == t5 ? void 0 : t5.$lazyInstance$) ? Op(t5.$lazyInstance$) : (null == t5 ? void 0 : t5.$onReadyPromise$) && t5.$onReadyPromise$.then(() => Op(t5.$lazyInstance$));
            }
          })(this));
        }
        componentOnReady() {
          return gf(this).$onReadyPromise$;
        }
      };
      r4.$lazyBundleId$ = e9[0], o.includes(a2) || s.get(a2) || (i2.push(a2), s.define(a2, Tp(c3, r4, 1)));
    });
  }), i2.length > 0 && (f2 && (l3.textContent += Ef), l3.textContent += i2.sort() + "{visibility:hidden}.hydrated{visibility:inherit}", l3.innerHTML.length)) {
    l3.setAttribute("data-styles", "");
    const e9 = null != (n2 = Cf.$nonce$) ? n2 : Df(_f);
    null != e9 && l3.setAttribute("nonce", e9), a.insertBefore(l3, c2 ? c2.nextSibling : a.firstChild);
  }
  h3 = false, d3.length ? d3.map((e9) => e9.connectedCallback()) : Cf.jmp(() => u2 = setTimeout(Ap, 30)), r3();
};
!function() {
  if ("undefined" != typeof window && void 0 !== window.Reflect && void 0 !== window.customElements) {
    var e8 = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(e8, [], this.constructor);
    }, HTMLElement.prototype = e8.prototype, HTMLElement.prototype.constructor = HTMLElement, Object.setPrototypeOf(HTMLElement, e8);
  }
}();
var Lp = Object.freeze({ __proto__: null, defineCustomElements: async (e8, t3) => {
  if ("undefined" != typeof window) return await void 0, Np([["mm-install-modal_3", [[1, "mm-install-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }], [1, "mm-pending-modal", { displayOTP: [4, "display-o-t-p"], sdkVersion: [1, "sdk-version"], otpCode: [1, "otp-code"], translationsLoaded: [32] }], [1, "mm-select-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }]]]], t3);
}, setNonce: (e8) => Cf.$nonce$ = e8 });
var Dp = { fontFamily: "Roboto, sans-serif" };
var $p = ({ className: e8 }, t3) => zf("div", { style: Dp, class: e8 }, t3);
var Bp = ({ Icon: e8, text: t3 }) => zf("div", { class: "flexContainer", style: { padding: "6", flexDirection: "row" } }, zf("div", { class: "flexItem1" }, zf(e8, null)), zf("div", { class: "flexItem11" }, zf("span", { style: { lineHeight: "2", color: "black" } }, t3)));
var Kp = () => zf("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M20.0002 7.9702V10.0302C20.0002 10.5802 19.5602 11.0302 19.0002 11.0502H17.0402C15.9602 11.0502 14.9702 10.2602 14.8802 9.1802C14.8202 8.5502 15.0602 7.9602 15.4802 7.5502C15.8502 7.1702 16.3602 6.9502 16.9202 6.9502H19.0002C19.5602 6.9702 20.0002 7.4202 20.0002 7.9702Z", fill: "#037DD6" }), zf("path", { d: "M18.47 12.55H17.04C15.14 12.55 13.54 11.12 13.38 9.3C13.29 8.26 13.67 7.22 14.43 6.48C15.07 5.82 15.96 5.45 16.92 5.45H18.47C18.76 5.45 19 5.21 18.97 4.92C18.75 2.49 17.14 0.83 14.75 0.55C14.51 0.51 14.26 0.5 14 0.5H5C4.72 0.5 4.45 0.52 4.19 0.56C1.64 0.88 0 2.78 0 5.5V12.5C0 15.26 2.24 17.5 5 17.5H14C16.8 17.5 18.73 15.75 18.97 13.08C19 12.79 18.76 12.55 18.47 12.55ZM11 6.75H5C4.59 6.75 4.25 6.41 4.25 6C4.25 5.59 4.59 5.25 5 5.25H11C11.41 5.25 11.75 5.59 11.75 6C11.75 6.41 11.41 6.75 11 6.75Z", fill: "#037DD6" }));
var jp = () => zf("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M14.44 0.0999756C12.63 0.0999756 11.01 0.979976 10 2.32998C8.99 0.979976 7.37 0.0999756 5.56 0.0999756C2.49 0.0999756 0 2.59998 0 5.68998C0 6.87998 0.19 7.97998 0.52 8.99998C2.1 14 6.97 16.99 9.38 17.81C9.72 17.93 10.28 17.93 10.62 17.81C13.03 16.99 17.9 14 19.48 8.99998C19.81 7.97998 20 6.87998 20 5.68998C20 2.59998 17.51 0.0999756 14.44 0.0999756Z", fill: "#037DD6" }));
var Up = () => zf("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M16.28 7.53V6.28C16.28 3.58 15.63 0 10 0C4.37 0 3.72 3.58 3.72 6.28V7.53C0.92 7.88 0 9.3 0 12.79V14.65C0 18.75 1.25 20 5.35 20H14.65C18.75 20 20 18.75 20 14.65V12.79C20 9.3 19.08 7.88 16.28 7.53ZM10 16.74C8.33 16.74 6.98 15.38 6.98 13.72C6.98 12.05 8.34 10.7 10 10.7C11.66 10.7 13.02 12.06 13.02 13.72C13.02 15.39 11.67 16.74 10 16.74ZM5.35 7.44C5.27 7.44 5.2 7.44 5.12 7.44V6.28C5.12 3.35 5.95 1.4 10 1.4C14.05 1.4 14.88 3.35 14.88 6.28V7.45C14.8 7.45 14.73 7.45 14.65 7.45H5.35V7.44Z", fill: "#037DD6" }));
var Hp = () => zf("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M16.4405 8.8999C20.0405 9.2099 21.5105 11.0599 21.5105 15.1099V15.2399C21.5105 19.7099 19.7205 21.4999 15.2505 21.4999H8.74047C4.27047 21.4999 2.48047 19.7099 2.48047 15.2399V15.1099C2.48047 11.0899 3.93047 9.2399 7.47047 8.9099", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), zf("path", { d: "M12 2V14.88", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), zf("path", { d: "M15.3504 12.6499L12.0004 15.9999L8.65039 12.6499", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }));
function Fp({ version: e8 }) {
  return zf("div", { style: { textAlign: "center", color: "#BBC0C5", fontSize: "12" } }, "SDK Version ", e8 ? `v${e8}` : "unknown");
}
var zp = () => zf("svg", { width: "14", height: "14", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("rect", { width: "16", height: "16", fill: "white" }), zf("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.40554 2.40554C2.94627 1.86482 3.82296 1.86482 4.36369 2.40554L8 6.04186L11.6363 2.40554C12.177 1.86482 13.0537 1.86482 13.5945 2.40554C14.1352 2.94627 14.1352 3.82296 13.5945 4.36369L9.95814 8L13.5945 11.6363C14.1352 12.177 14.1352 13.0537 13.5945 13.5945C13.0537 14.1352 12.177 14.1352 11.6363 13.5945L8 9.95814L4.36369 13.5945C3.82296 14.1352 2.94627 14.1352 2.40554 13.5945C1.86482 13.0537 1.86482 12.177 2.40554 11.6363L6.04186 8L2.40554 4.36369C1.86482 3.82296 1.86482 2.94627 2.40554 2.40554Z", fill: "#BBC0C5" }));
var qp = () => zf("svg", { width: "120", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 127 63" }, zf("path", { fill: "currentColor", d: "M71.554 48.607v13.81h-7.072v-9.568l-8.059.945c-1.77.205-2.548.79-2.548 1.864 0 1.575 1.478 2.239 4.648 2.239 1.932 0 4.073-.29 5.963-.79l-3.66 5.225c-1.479.332-2.92.496-4.44.496-6.414 0-10.074-2.57-10.074-7.132 0-4.023 2.877-6.136 9.416-6.884l8.638-1.012c-.467-2.532-2.362-3.633-6.13-3.633-3.537 0-7.443.912-10.937 2.613l1.111-6.18c3.248-1.369 6.95-2.074 10.69-2.074 8.226 0 12.461 3.444 12.461 10.075l-.008.005ZM7.938 31.315.208 62.416h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73l-7.73-31.105-14.518 17.388L7.934 31.311l.004.004ZM36.97.21 22.452 17.598 7.938.21.208 31.315h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73L36.97.21Zm53.17 48.107-6.25-.912c-1.562-.247-2.178-.747-2.178-1.617 0-1.41 1.52-2.032 4.647-2.032 3.62 0 6.868.747 10.283 2.364l-.862-6.094c-2.757-.995-5.922-1.491-9.212-1.491-7.688 0-11.886 2.696-11.886 7.547 0 3.776 2.303 5.889 7.196 6.636l6.335.954c1.603.248 2.261.87 2.261 1.865 0 1.41-1.478 2.074-4.481 2.074-3.948 0-8.225-.953-11.72-2.654l.7 6.094c3.003 1.122 6.91 1.785 10.57 1.785 7.896 0 12.007-2.78 12.007-7.715 0-3.94-2.303-6.057-7.4-6.8l-.01-.004ZM100.3 34.09v28.325h7.071V34.091H100.3Zm15.334 15.595 9.833-10.744h-8.8l-9.296 11.114 9.912 12.356h8.925l-10.574-12.73v.004Zm-16.321-25.09c0 4.56 3.66 7.13 10.074 7.13 1.52 0 2.961-.167 4.44-.495l3.66-5.225c-1.89.496-4.031.79-5.963.79-3.166 0-4.648-.664-4.648-2.239 0-1.079.783-1.659 2.549-1.864l8.058-.945v9.567h7.072v-13.81c0-6.635-4.236-10.075-12.461-10.075-3.744 0-7.442.705-10.691 2.075l-1.112 6.178c3.495-1.701 7.401-2.613 10.937-2.613 3.769 0 5.664 1.1 6.13 3.633l-8.637 1.013c-6.539.747-9.417 2.86-9.417 6.883l.009-.004Zm-19.779-1.492c0 5.725 3.29 8.627 9.787 8.627 2.59 0 4.732-.416 6.785-1.37l.903-6.261c-1.974 1.2-3.99 1.822-6.005 1.822-3.044 0-4.402-1.243-4.402-4.023v-8.295h10.732V7.84H86.601V2.948l-13.448 7.174v3.482h6.372V23.1l.008.004Zm-6.95-2.612v1.411H53.47c.862 2.873 3.423 4.187 7.97 4.187 3.62 0 6.993-.747 9.992-2.196l-.862 6.056c-2.757 1.16-6.251 1.785-9.829 1.785-9.5 0-14.68-4.23-14.68-12.066 0-7.838 5.264-12.235 13.406-12.235s13.119 4.771 13.119 13.062l-.005-.004ZM53.378 17.09h12.086c-.637-2.751-2.732-4.188-6.08-4.188-3.349 0-5.335 1.399-6.006 4.188Z" }));
function Wp(e8, t3) {
  return e8.toString(2).padStart(t3, "0");
}
function Vp(e8, t3) {
  const n2 = e8 % t3;
  return n2 >= 0 ? n2 : t3 + n2;
}
function Gp(e8, t3) {
  return new Array(e8).fill(t3);
}
function Yp(...e8) {
  let t3 = 0;
  for (const n3 of e8) t3 = Math.max(t3, n3.length);
  const n2 = [];
  for (let r3 = 0; r3 < t3; r3++) for (const t4 of e8) r3 >= t4.length || n2.push(t4[r3]);
  return new Uint8Array(n2);
}
function Zp(e8, t3, n2) {
  if (n2 < 0 || n2 + t3.length > e8.length) return false;
  for (let r3 = 0; r3 < t3.length; r3++) if (t3[r3] !== e8[n2 + r3]) return false;
  return true;
}
function Jp(e8) {
  return { has: (t3) => e8.includes(t3), decode: (t3) => {
    if (!Array.isArray(t3) || t3.length && "string" != typeof t3[0]) throw new Error("alphabet.decode input should be array of strings");
    return t3.map((t4) => {
      if ("string" != typeof t4) throw new Error(`alphabet.decode: not string element=${t4}`);
      const n2 = e8.indexOf(t4);
      if (-1 === n2) throw new Error(`Unknown letter: "${t4}". Allowed: ${e8}`);
      return n2;
    });
  }, encode: (t3) => {
    if (!Array.isArray(t3) || t3.length && "number" != typeof t3[0]) throw new Error("alphabet.encode input should be an array of numbers");
    return t3.map((t4) => {
      if (function(e9) {
        if (!Number.isSafeInteger(e9)) throw new Error(`Wrong integer: ${e9}`);
      }(t4), t4 < 0 || t4 >= e8.length) throw new Error(`Digit index outside alphabet: ${t4} (alphabet: ${e8.length})`);
      return e8[t4];
    });
  } };
}
var Qp = class _Qp {
  static size(e8, t3) {
    if ("number" == typeof e8 && (e8 = { height: e8, width: e8 }), !Number.isSafeInteger(e8.height) && e8.height !== 1 / 0) throw new Error(`Bitmap: wrong height=${e8.height} (${typeof e8.height})`);
    if (!Number.isSafeInteger(e8.width) && e8.width !== 1 / 0) throw new Error(`Bitmap: wrong width=${e8.width} (${typeof e8.width})`);
    return void 0 !== t3 && (e8 = { width: Math.min(e8.width, t3.width), height: Math.min(e8.height, t3.height) }), e8;
  }
  static fromString(e8) {
    const t3 = (e8 = e8.replace(/^\n+/g, "").replace(/\n+$/g, "")).split("\n"), n2 = t3.length, r3 = new Array(n2);
    let i2;
    for (const e9 of t3) {
      const t4 = e9.split("").map((e10) => {
        if ("X" === e10) return true;
        if (" " === e10) return false;
        if ("?" !== e10) throw new Error(`Bitmap.fromString: unknown symbol=${e10}`);
      });
      if (i2 && t4.length !== i2) throw new Error(`Bitmap.fromString different row sizes: width=${i2} cur=${t4.length}`);
      i2 = t4.length, r3.push(t4);
    }
    return i2 || (i2 = 0), new _Qp({ height: n2, width: i2 }, r3);
  }
  constructor(e8, t3) {
    const { height: n2, width: r3 } = _Qp.size(e8);
    this.data = t3 || Array.from({ length: n2 }, () => Gp(r3, void 0)), this.height = n2, this.width = r3;
  }
  point(e8) {
    return this.data[e8.y][e8.x];
  }
  isInside(e8) {
    return 0 <= e8.x && e8.x < this.width && 0 <= e8.y && e8.y < this.height;
  }
  size(e8) {
    if (!e8) return { height: this.height, width: this.width };
    const { x: t3, y: n2 } = this.xy(e8);
    return { height: this.height - n2, width: this.width - t3 };
  }
  xy(e8) {
    if ("number" == typeof e8 && (e8 = { x: e8, y: e8 }), !Number.isSafeInteger(e8.x)) throw new Error(`Bitmap: wrong x=${e8.x}`);
    if (!Number.isSafeInteger(e8.y)) throw new Error(`Bitmap: wrong y=${e8.y}`);
    return e8.x = Vp(e8.x, this.width), e8.y = Vp(e8.y, this.height), e8;
  }
  rect(e8, t3, n2) {
    const { x: r3, y: i2 } = this.xy(e8), { height: o, width: s } = _Qp.size(t3, this.size({ x: r3, y: i2 }));
    for (let e9 = 0; e9 < o; e9++) for (let t4 = 0; t4 < s; t4++) this.data[i2 + e9][r3 + t4] = "function" == typeof n2 ? n2({ x: t4, y: e9 }, this.data[i2 + e9][r3 + t4]) : n2;
    return this;
  }
  rectRead(e8, t3, n2) {
    return this.rect(e8, t3, (e9, t4) => (n2(e9, t4), t4));
  }
  hLine(e8, t3, n2) {
    return this.rect(e8, { width: t3, height: 1 }, n2);
  }
  vLine(e8, t3, n2) {
    return this.rect(e8, { width: 1, height: t3 }, n2);
  }
  border(e8 = 2, t3) {
    const n2 = this.height + 2 * e8, r3 = this.width + 2 * e8, i2 = Gp(e8, t3), o = Array.from({ length: e8 }, () => Gp(r3, t3));
    return new _Qp({ height: n2, width: r3 }, [...o, ...this.data.map((e9) => [...i2, ...e9, ...i2]), ...o]);
  }
  embed(e8, t3) {
    return this.rect(e8, t3.size(), ({ x: e9, y: n2 }) => t3.data[n2][e9]);
  }
  rectSlice(e8, t3 = this.size()) {
    const n2 = new _Qp(_Qp.size(t3, this.size(this.xy(e8))));
    return this.rect(e8, t3, ({ x: e9, y: t4 }, r3) => n2.data[t4][e9] = r3), n2;
  }
  inverse() {
    const { height: e8, width: t3 } = this;
    return new _Qp({ height: t3, width: e8 }).rect({ x: 0, y: 0 }, 1 / 0, ({ x: e9, y: t4 }) => this.data[e9][t4]);
  }
  scale(e8) {
    if (!Number.isSafeInteger(e8) || e8 > 1024) throw new Error(`Wrong scale factor: ${e8}`);
    const { height: t3, width: n2 } = this;
    return new _Qp({ height: e8 * t3, width: e8 * n2 }).rect({ x: 0, y: 0 }, 1 / 0, ({ x: t4, y: n3 }) => this.data[Math.floor(n3 / e8)][Math.floor(t4 / e8)]);
  }
  clone() {
    return new _Qp(this.size()).rect({ x: 0, y: 0 }, this.size(), ({ x: e8, y: t3 }) => this.data[t3][e8]);
  }
  assertDrawn() {
    this.rectRead(0, 1 / 0, (e8, t3) => {
      if ("boolean" != typeof t3) throw new Error("Invalid color type=" + typeof t3);
    });
  }
  toString() {
    return this.data.map((e8) => e8.map((e9) => void 0 === e9 ? "?" : e9 ? "X" : " ").join("")).join("\n");
  }
  toASCII() {
    const { height: e8, width: t3, data: n2 } = this;
    let r3 = "";
    for (let i2 = 0; i2 < e8; i2 += 2) {
      for (let o = 0; o < t3; o++) {
        const t4 = n2[i2][o], s = i2 + 1 >= e8 || n2[i2 + 1][o];
        t4 || s ? !t4 && s ? r3 += "▀" : t4 && !s ? r3 += "▄" : t4 && s && (r3 += " ") : r3 += "█";
      }
      r3 += "\n";
    }
    return r3;
  }
  toTerm() {
    const e8 = "\x1B[0m", t3 = `\x1B[1;47m  ${e8}`, n2 = `\x1B[40m  ${e8}`;
    return this.data.map((e9) => e9.map((e10) => e10 ? n2 : t3).join("")).join("\n");
  }
  toSVG() {
    let e8 = `<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 ${this.width} ${this.height}" version="1.1" xmlns="http://www.w3.org/2000/svg">`;
    return this.rectRead(0, 1 / 0, ({ x: t3, y: n2 }, r3) => {
      r3 && (e8 += `<rect x="${t3}" y="${n2}" width="1" height="1" />`);
    }), e8 += "</svg>", e8;
  }
  toGIF() {
    const e8 = (e9) => [255 & e9, e9 >>> 8 & 255], t3 = [...e8(this.width), ...e8(this.height)], n2 = [];
    this.rectRead(0, 1 / 0, (e9, t4) => n2.push(+(true === t4)));
    const r3 = 126, i2 = [71, 73, 70, 56, 55, 97, ...t3, 246, 0, 0, 255, 255, 255, ...Gp(381, 0), 44, 0, 0, 0, 0, ...t3, 0, 7], o = Math.floor(n2.length / r3);
    for (let e9 = 0; e9 < o; e9++) i2.push(127, 128, ...n2.slice(r3 * e9, r3 * (e9 + 1)).map((e10) => +e10));
    return i2.push(n2.length % r3 + 1, 128, ...n2.slice(o * r3).map((e9) => +e9)), i2.push(1, 129, 0, 59), new Uint8Array(i2);
  }
  toImage(e8 = false) {
    const { height: t3, width: n2 } = this.size(), r3 = new Uint8Array(t3 * n2 * (e8 ? 3 : 4));
    let i2 = 0;
    for (let o = 0; o < t3; o++) for (let t4 = 0; t4 < n2; t4++) {
      const n3 = this.data[o][t4] ? 0 : 255;
      r3[i2++] = n3, r3[i2++] = n3, r3[i2++] = n3, e8 || (r3[i2++] = 255);
    }
    return { height: t3, width: n2, data: r3 };
  }
};
var Xp = ["low", "medium", "quartile", "high"];
var eg = ["numeric", "alphanumeric", "byte", "kanji", "eci"];
var tg = [26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
var ng = { low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30] };
var rg = { low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81] };
var ig = { size: { encode: (e8) => 21 + 4 * (e8 - 1), decode: (e8) => (e8 - 17) / 4 }, sizeType: (e8) => Math.floor((e8 + 7) / 17), alignmentPatterns(e8) {
  if (1 === e8) return [];
  const t3 = ig.size.encode(e8) - 6 - 1, n2 = t3 - 6, r3 = Math.ceil(n2 / 28);
  let i2 = Math.floor(n2 / r3);
  i2 % 2 ? i2 += 1 : n2 % r3 * 2 >= r3 && (i2 += 2);
  const o = [6];
  for (let e9 = 1; e9 < r3; e9++) o.push(t3 - (r3 - e9) * i2);
  return o.push(t3), o;
}, ECCode: { low: 1, medium: 0, quartile: 3, high: 2 }, formatMask: 21522, formatBits(e8, t3) {
  const n2 = ig.ECCode[e8] << 3 | t3;
  let r3 = n2;
  for (let e9 = 0; e9 < 10; e9++) r3 = r3 << 1 ^ 1335 * (r3 >> 9);
  return (n2 << 10 | r3) ^ ig.formatMask;
}, versionBits(e8) {
  let t3 = e8;
  for (let e9 = 0; e9 < 12; e9++) t3 = t3 << 1 ^ 7973 * (t3 >> 11);
  return e8 << 12 | t3;
}, alphabet: { numeric: Jp("0123456789"), alphanumerc: Jp("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:") }, lengthBits: (e8, t3) => ({ numeric: [10, 12, 14], alphanumeric: [9, 11, 13], byte: [8, 16, 16], kanji: [8, 10, 12], eci: [0, 0, 0] })[t3][ig.sizeType(e8)], modeBits: { numeric: "0001", alphanumeric: "0010", byte: "0100", kanji: "1000", eci: "0111" }, capacity(e8, t3) {
  const n2 = tg[e8 - 1], r3 = ng[t3][e8 - 1], i2 = rg[t3][e8 - 1], o = Math.floor(n2 / i2) - r3, s = i2 - n2 % i2;
  return { words: r3, numBlocks: i2, shortBlocks: s, blockLen: o, capacity: 8 * (n2 - r3 * i2), total: (r3 + o) * i2 + i2 - s };
} };
var og = [(e8, t3) => (e8 + t3) % 2 == 0, (e8, t3) => t3 % 2 == 0, (e8, t3) => e8 % 3 == 0, (e8, t3) => (e8 + t3) % 3 == 0, (e8, t3) => (Math.floor(t3 / 2) + Math.floor(e8 / 3)) % 2 == 0, (e8, t3) => e8 * t3 % 2 + e8 * t3 % 3 == 0, (e8, t3) => (e8 * t3 % 2 + e8 * t3 % 3) % 2 == 0, (e8, t3) => ((e8 + t3) % 2 + e8 * t3 % 3) % 2 == 0];
var sg = { tables: ((e8) => {
  const t3 = Gp(256, 0), n2 = Gp(256, 0);
  for (let e9 = 0, r3 = 1; e9 < 256; e9++) t3[e9] = r3, n2[r3] = e9, r3 <<= 1, 256 & r3 && (r3 ^= 285);
  return { exp: t3, log: n2 };
})(), exp: (e8) => sg.tables.exp[e8], log(e8) {
  if (0 === e8) throw new Error(`GF.log: wrong arg=${e8}`);
  return sg.tables.log[e8] % 255;
}, mul: (e8, t3) => 0 === e8 || 0 === t3 ? 0 : sg.tables.exp[(sg.tables.log[e8] + sg.tables.log[t3]) % 255], add: (e8, t3) => e8 ^ t3, pow: (e8, t3) => sg.tables.exp[sg.tables.log[e8] * t3 % 255], inv(e8) {
  if (0 === e8) throw new Error(`GF.inverse: wrong arg=${e8}`);
  return sg.tables.exp[255 - sg.tables.log[e8]];
}, polynomial(e8) {
  if (0 == e8.length) throw new Error("GF.polymomial: wrong length");
  if (0 !== e8[0]) return e8;
  let t3 = 0;
  for (; t3 < e8.length - 1 && 0 == e8[t3]; t3++) ;
  return e8.slice(t3);
}, monomial(e8, t3) {
  if (e8 < 0) throw new Error(`GF.monomial: wrong degree=${e8}`);
  if (0 == t3) return [0];
  let n2 = Gp(e8 + 1, 0);
  return n2[0] = t3, sg.polynomial(n2);
}, degree: (e8) => e8.length - 1, coefficient: (e8, t3) => e8[sg.degree(e8) - t3], mulPoly(e8, t3) {
  if (0 === e8[0] || 0 === t3[0]) return [0];
  const n2 = Gp(e8.length + t3.length - 1, 0);
  for (let r3 = 0; r3 < e8.length; r3++) for (let i2 = 0; i2 < t3.length; i2++) n2[r3 + i2] = sg.add(n2[r3 + i2], sg.mul(e8[r3], t3[i2]));
  return sg.polynomial(n2);
}, mulPolyScalar(e8, t3) {
  if (0 == t3) return [0];
  if (1 == t3) return e8;
  const n2 = Gp(e8.length, 0);
  for (let r3 = 0; r3 < e8.length; r3++) n2[r3] = sg.mul(e8[r3], t3);
  return sg.polynomial(n2);
}, mulPolyMonomial(e8, t3, n2) {
  if (t3 < 0) throw new Error("GF.mulPolyMonomial: wrong degree");
  if (0 == n2) return [0];
  const r3 = Gp(e8.length + t3, 0);
  for (let t4 = 0; t4 < e8.length; t4++) r3[t4] = sg.mul(e8[t4], n2);
  return sg.polynomial(r3);
}, addPoly(e8, t3) {
  if (0 === e8[0]) return t3;
  if (0 === t3[0]) return e8;
  let n2 = e8, r3 = t3;
  n2.length > r3.length && ([n2, r3] = [r3, n2]);
  let i2 = Gp(r3.length, 0), o = r3.length - n2.length, s = r3.slice(0, o);
  for (let e9 = 0; e9 < s.length; e9++) i2[e9] = s[e9];
  for (let e9 = o; e9 < r3.length; e9++) i2[e9] = sg.add(n2[e9 - o], r3[e9]);
  return sg.polynomial(i2);
}, remainderPoly(e8, t3) {
  const n2 = Array.from(e8);
  for (let r3 = 0; r3 < e8.length - t3.length + 1; r3++) {
    const e9 = n2[r3];
    if (0 !== e9) for (let i2 = 1; i2 < t3.length; i2++) 0 !== t3[i2] && (n2[r3 + i2] = sg.add(n2[r3 + i2], sg.mul(t3[i2], e9)));
  }
  return n2.slice(e8.length - t3.length + 1, n2.length);
}, divisorPoly(e8) {
  let t3 = [1];
  for (let n2 = 0; n2 < e8; n2++) t3 = sg.mulPoly(t3, [1, sg.pow(2, n2)]);
  return t3;
}, evalPoly(e8, t3) {
  if (0 == t3) return sg.coefficient(e8, 0);
  let n2 = e8[0];
  for (let r3 = 1; r3 < e8.length; r3++) n2 = sg.add(sg.mul(t3, n2), e8[r3]);
  return n2;
}, euclidian(e8, t3, n2) {
  sg.degree(e8) < sg.degree(t3) && ([e8, t3] = [t3, e8]);
  let r3 = e8, i2 = t3, o = [0], s = [1];
  for (; 2 * sg.degree(i2) >= n2; ) {
    let e9 = r3, t4 = o;
    if (r3 = i2, o = s, 0 === r3[0]) throw new Error("rLast[0] === 0");
    i2 = e9;
    let n3 = [0];
    const a2 = sg.inv(r3[0]);
    for (; sg.degree(i2) >= sg.degree(r3) && 0 !== i2[0]; ) {
      const e10 = sg.degree(i2) - sg.degree(r3), t5 = sg.mul(i2[0], a2);
      n3 = sg.addPoly(n3, sg.monomial(e10, t5)), i2 = sg.addPoly(i2, sg.mulPolyMonomial(r3, e10, t5));
    }
    if (n3 = sg.mulPoly(n3, o), s = sg.addPoly(n3, t4), sg.degree(i2) >= sg.degree(r3)) throw new Error(`Division failed r: ${i2}, rLast: ${r3}`);
  }
  const a = sg.coefficient(s, 0);
  if (0 == a) throw new Error("sigmaTilde(0) was zero");
  const c2 = sg.inv(a);
  return [sg.mulPolyScalar(s, c2), sg.mulPolyScalar(i2, c2)];
} };
function ag(e8, t3) {
  const { words: n2, shortBlocks: r3, numBlocks: i2, blockLen: o, total: s } = ig.capacity(e8, t3), a = (c2 = n2, { encode(e9) {
    const t4 = sg.divisorPoly(c2), n3 = Array.from(e9);
    return n3.push(...t4.slice(0, -1).fill(0)), Uint8Array.from(sg.remainderPoly(n3, t4));
  }, decode(e9) {
    const t4 = e9.slice(), n3 = sg.polynomial(Array.from(e9));
    let r4 = Gp(c2, 0), i3 = false;
    for (let e10 = 0; e10 < c2; e10++) {
      const t5 = sg.evalPoly(n3, sg.exp(e10));
      r4[r4.length - 1 - e10] = t5, 0 !== t5 && (i3 = true);
    }
    if (!i3) return t4;
    r4 = sg.polynomial(r4);
    const o2 = sg.monomial(c2, 1), [s2, a2] = sg.euclidian(o2, r4, c2), l3 = Gp(sg.degree(s2), 0);
    let d3 = 0;
    for (let e10 = 1; e10 < 256 && d3 < l3.length; e10++) 0 === sg.evalPoly(s2, e10) && (l3[d3++] = sg.inv(e10));
    if (d3 !== l3.length) throw new Error("RS.decode: wrong errors number");
    for (let e10 = 0; e10 < l3.length; e10++) {
      const n4 = t4.length - 1 - sg.log(l3[e10]);
      if (n4 < 0) throw new Error("RS.decode: wrong error location");
      const r5 = sg.inv(l3[e10]);
      let i4 = 1;
      for (let t5 = 0; t5 < l3.length; t5++) e10 !== t5 && (i4 = sg.mul(i4, sg.add(1, sg.mul(l3[t5], r5))));
      t4[n4] = sg.add(t4[n4], sg.mul(sg.evalPoly(a2, r5), sg.inv(i4)));
    }
    return t4;
  } });
  var c2;
  return { encode(e9) {
    const t4 = [], n3 = [];
    for (let s3 = 0; s3 < i2; s3++) {
      const i3 = o + (s3 < r3 ? 0 : 1);
      t4.push(e9.subarray(0, i3)), n3.push(a.encode(e9.subarray(0, i3))), e9 = e9.subarray(i3);
    }
    const s2 = Yp(...t4), c3 = Yp(...n3), l3 = new Uint8Array(s2.length + c3.length);
    return l3.set(s2), l3.set(c3, s2.length), l3;
  }, decode(e9) {
    if (e9.length !== s) throw new Error(`interleave.decode: len(data)=${e9.length}, total=${s}`);
    const t4 = [];
    for (let e10 = 0; e10 < i2; e10++) {
      const i3 = e10 < r3;
      t4.push(new Uint8Array(n2 + o + (i3 ? 0 : 1)));
    }
    let c3 = 0;
    for (let n3 = 0; n3 < o; n3++) for (let r4 = 0; r4 < i2; r4++) t4[r4][n3] = e9[c3++];
    for (let n3 = r3; n3 < i2; n3++) t4[n3][o] = e9[c3++];
    for (let s2 = o; s2 < o + n2; s2++) for (let n3 = 0; n3 < i2; n3++) {
      const i3 = n3 < r3;
      t4[n3][s2 + (i3 ? 0 : 1)] = e9[c3++];
    }
    const l3 = [];
    for (const e10 of t4) l3.push(...Array.from(a.decode(e10)).slice(0, -n2));
    return Uint8Array.from(l3);
  } };
}
function cg(e8, t3, n2, r3) {
  let i2 = "", o = n2.length;
  if ("numeric" === r3) {
    const e9 = ig.alphabet.numeric.decode(n2.split("")), t4 = e9.length;
    for (let n3 = 0; n3 < t4 - 2; n3 += 3) i2 += Wp(100 * e9[n3] + 10 * e9[n3 + 1] + e9[n3 + 2], 10);
    t4 % 3 == 1 ? i2 += Wp(e9[t4 - 1], 4) : t4 % 3 == 2 && (i2 += Wp(10 * e9[t4 - 2] + e9[t4 - 1], 7));
  } else if ("alphanumeric" === r3) {
    const e9 = ig.alphabet.alphanumerc.decode(n2.split("")), t4 = e9.length;
    for (let n3 = 0; n3 < t4 - 1; n3 += 2) i2 += Wp(45 * e9[n3] + e9[n3 + 1], 11);
    t4 % 2 == 1 && (i2 += Wp(e9[t4 - 1], 6));
  } else {
    if ("byte" !== r3) throw new Error("encode: unsupported type");
    {
      const e9 = function(e10) {
        if ("string" != typeof e10) throw new Error("utf8ToBytes expected string, got " + typeof e10);
        return new Uint8Array(new TextEncoder().encode(e10));
      }(n2);
      o = e9.length, i2 = Array.from(e9).map((e10) => Wp(e10, 8)).join("");
    }
  }
  const { capacity: s } = ig.capacity(e8, t3), a = Wp(o, ig.lengthBits(e8, r3));
  let c2 = ig.modeBits[r3] + a + i2;
  if (c2.length > s) throw new Error("Capacity overflow");
  c2 += "0".repeat(Math.min(4, Math.max(0, s - c2.length))), c2.length % 8 && (c2 += "0".repeat(8 - c2.length % 8));
  const l3 = "1110110000010001";
  for (let e9 = 0; c2.length !== s; e9++) c2 += l3[e9 % 16];
  const d3 = Uint8Array.from(c2.match(/(.{8})/g).map((e9) => Number(`0b${e9}`)));
  return ag(e8, t3).encode(d3);
}
function lg(e8, t3, n2, r3, i2 = false) {
  const o = function(e9, t4, n3, r4 = false) {
    const i3 = ig.size.encode(e9);
    let o2 = new Qp(i3 + 2);
    const s2 = new Qp(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);
    o2 = o2.embed(0, s2).embed({ x: -s2.width, y: 0 }, s2).embed({ x: 0, y: -s2.height }, s2), o2 = o2.rectSlice(1, i3);
    const a2 = new Qp(1).rect(0, 1, true).border(1, false).border(1, true), c2 = ig.alignmentPatterns(e9);
    for (const e10 of c2) for (const t5 of c2) void 0 === o2.data[e10][t5] && o2.embed({ x: t5 - 2, y: e10 - 2 }, a2);
    o2 = o2.hLine({ x: 0, y: 6 }, 1 / 0, ({ x: e10 }, t5) => void 0 === t5 ? e10 % 2 == 0 : t5).vLine({ x: 6, y: 0 }, 1 / 0, ({ y: e10 }, t5) => void 0 === t5 ? e10 % 2 == 0 : t5);
    {
      const e10 = ig.formatBits(t4, n3), s3 = (t5) => !r4 && 1 == (e10 >> t5 & 1);
      for (let e11 = 0; e11 < 6; e11++) o2.data[e11][8] = s3(e11);
      for (let e11 = 6; e11 < 8; e11++) o2.data[e11 + 1][8] = s3(e11);
      for (let e11 = 8; e11 < 15; e11++) o2.data[i3 - 15 + e11][8] = s3(e11);
      for (let e11 = 0; e11 < 8; e11++) o2.data[8][i3 - e11 - 1] = s3(e11);
      for (let e11 = 8; e11 < 9; e11++) o2.data[8][15 - e11 - 1 + 1] = s3(e11);
      for (let e11 = 9; e11 < 15; e11++) o2.data[8][15 - e11 - 1] = s3(e11);
      o2.data[i3 - 8][8] = !r4;
    }
    if (e9 >= 7) {
      const t5 = ig.versionBits(e9);
      for (let e10 = 0; e10 < 18; e10 += 1) {
        const n4 = !r4 && 1 == (t5 >> e10 & 1), s3 = Math.floor(e10 / 3), a3 = e10 % 3 + i3 - 8 - 3;
        o2.data[s3][a3] = n4, o2.data[a3][s3] = n4;
      }
    }
    return o2;
  }(e8, t3, r3, i2);
  let s = 0;
  const a = 8 * n2.length;
  if (function(e9, t4, n3) {
    const r4 = e9.height, i3 = og[t4];
    let o2 = -1, s2 = r4 - 1;
    for (let t5 = r4 - 1; t5 > 0; t5 -= 2) {
      for (6 == t5 && (t5 = 5); ; s2 += o2) {
        for (let r5 = 0; r5 < 2; r5 += 1) {
          const o3 = t5 - r5;
          void 0 === e9.data[s2][o3] && n3(o3, s2, i3(o3, s2));
        }
        if (s2 + o2 < 0 || s2 + o2 >= r4) break;
      }
      o2 = -o2;
    }
  }(o, r3, (e9, t4, r4) => {
    let i3 = false;
    s < a && (i3 = 0 != (n2[s >>> 3] >> (7 - s & 7) & 1), s++), o.data[t4][e9] = i3 !== r4;
  }), s !== a) throw new Error("QR: bytes left after draw");
  return o;
}
function dg(e8) {
  const t3 = e8.inverse(), n2 = (e9) => {
    let t4 = 0;
    for (let n3, r4 = 0, i3 = 1; r4 < e9.length; r4++) n3 === e9[r4] && (i3++, r4 !== e9.length - 1) || (i3 >= 5 && (t4 += i3 - 5 + 3), n3 = e9[r4], i3 = 1);
    return t4;
  };
  let r3 = 0;
  e8.data.forEach((e9) => r3 += n2(e9)), t3.data.forEach((e9) => r3 += n2(e9));
  let i2 = 0, o = e8.data;
  const s = e8.width - 1, a = e8.height - 1;
  for (let e9 = 0; e9 < s; e9++) for (let t4 = 0; t4 < a; t4++) {
    const n3 = e9 + 1, r4 = t4 + 1;
    o[e9][t4] === o[n3][t4] && o[n3][t4] === o[e9][r4] && o[n3][t4] === o[n3][r4] && (i2 += 3);
  }
  const c2 = (e9) => {
    const t4 = [true, false, true, true, true, false, true], n3 = [false, false, false, false], r4 = [...t4, ...n3], i3 = [...n3, ...t4];
    let o2 = 0;
    for (let t5 = 0; t5 < e9.length; t5++) Zp(e9, r4, t5) && (o2 += 40), Zp(e9, i3, t5) && (o2 += 40);
    return o2;
  };
  let l3 = 0;
  for (const t4 of e8.data) l3 += c2(t4);
  for (const e9 of t3.data) l3 += c2(e9);
  let d3 = 0;
  e8.rectRead(0, 1 / 0, (e9, t4) => d3 += t4 ? 1 : 0);
  const u2 = d3 / (e8.height * e8.width) * 100, h3 = 10 * Math.floor(Math.abs(u2 - 50) / 5);
  return r3 + i2 + l3 + h3;
}
function ug(e8, t3 = "raw", n2 = {}) {
  const r3 = void 0 !== n2.ecc ? n2.ecc : "medium";
  !function(e9) {
    if (!Xp.includes(e9)) throw new Error(`Invalid error correction mode=${e9}. Expected: ${Xp}`);
  }(r3);
  const i2 = void 0 !== n2.encoding ? n2.encoding : function(e9) {
    let t4 = "numeric";
    for (let n3 of e9) if (!ig.alphabet.numeric.has(n3) && (t4 = "alphanumeric", !ig.alphabet.alphanumerc.has(n3))) return "byte";
    return t4;
  }(e8);
  !function(e9) {
    if (!eg.includes(e9)) throw new Error(`Encoding: invalid mode=${e9}. Expected: ${eg}`);
    if ("kanji" === e9 || "eci" === e9) throw new Error(`Encoding: ${e9} is not supported (yet?).`);
  }(i2), void 0 !== n2.mask && function(e9) {
    if (![0, 1, 2, 3, 4, 5, 6, 7].includes(e9) || !og[e9]) throw new Error(`Invalid mask=${e9}. Expected number [0..7]`);
  }(n2.mask);
  let o, s = n2.version, a = new Error("Unknown error");
  if (void 0 !== s) !function(e9) {
    if (!Number.isSafeInteger(e9) || e9 < 1 || e9 > 40) throw new Error(`Invalid version=${e9}. Expected number [1..40]`);
  }(s), o = cg(s, r3, e8, i2);
  else for (let t4 = 1; t4 <= 40; t4++) try {
    o = cg(t4, r3, e8, i2), s = t4;
    break;
  } catch (e9) {
    a = e9;
  }
  if (!s || !o) throw a;
  let c2 = function(e9, t4, n3, r4) {
    if (void 0 === r4) {
      const i3 = function() {
        let e10, t5 = 1 / 0;
        return { add(n4, r5) {
          n4 >= t5 || (e10 = r5, t5 = n4);
        }, get: () => e10, score: () => t5 };
      }();
      for (let r5 = 0; r5 < og.length; r5++) i3.add(dg(lg(e9, t4, n3, r5, true)), r5);
      r4 = i3.get();
    }
    if (void 0 === r4) throw new Error("Cannot find mask");
    return lg(e9, t4, n3, r4);
  }(s, r3, o, n2.mask);
  c2.assertDrawn();
  const l3 = void 0 === n2.border ? 2 : n2.border;
  if (!Number.isSafeInteger(l3)) throw new Error("Wrong border type=" + typeof l3);
  if (c2 = c2.border(l3, false), void 0 !== n2.scale && (c2 = c2.scale(n2.scale)), "raw" === t3) return c2.data;
  if ("ascii" === t3) return c2.toASCII();
  if ("svg" === t3) return c2.toSVG();
  if ("gif" === t3) return c2.toGIF();
  if ("term" === t3) return c2.toTerm();
  throw new Error(`Unknown output: ${t3}`);
}
var hg = { DESKTOP: "Desktop", MOBILE: "Mobile", META_MASK_MOBILE_APP: "MetaMask mobile app", SCAN_TO_CONNECT: "Scan to connect and sign with", CONNECT_WITH_EXTENSION: "Connect With MetaMask Extension", INSTALL_MODAL: { TRUSTED_BY_USERS: "Trusted by over 30 million users to buy, store, send and swap crypto securely", LEADING_CRYPTO_WALLET: "The leading crypto wallet & gateway to blockchain apps built on Ethereum Mainnet, Polygon, Optimism, and many other networks", CONTROL_DIGITAL_INTERACTIONS: "Puts you in control of your digital interactions by making power of cryptography more accessible", INSTALL_META_MASK_EXTENSION: "Install MetaMask Extension" }, PENDING_MODAL: { OPEN_META_MASK_SELECT_CODE: "Please open the MetaMask wallet app and select the code on the screen OR disconnect", OPEN_META_MASK_CONTINUE: "Open the MetaMask app to continue with your session.", NUMBER_AFTER_OPEN_NOTICE: "If a number doesn't appear after opening MetaMask, please click disconnect and re-scan the QRCode.", DISCONNECT: "Disconnect" }, SELECT_MODAL: { CRYPTO_TAKE_CONTROL_TEXT: "Take control of your crypto and explore the blockchain with the wallet trusted by over 30 million people worldwide" }, META_MASK_MODAL: { ADDRESS_COPIED: "Address copied to clipboard!", DISCONNECT: "Disconnect", ACTIVE_NETWORK: "Active Network" } };
var fg = class {
  constructor(e8) {
    var t3;
    this.translations = hg, this.supportedLocales = ["es", "fr", "he", "it", "pt", "tr"], this.baseUrl = null !== (t3 = null == e8 ? void 0 : e8.baseUrl) && void 0 !== t3 ? t3 : "https://raw.githubusercontent.com/MetaMask/metamask-sdk/refs/heads/gh-pages/locales";
  }
  getBrowserLanguage() {
    if ((navigator.languages || [navigator.language]).some((e9) => e9.toLowerCase().startsWith("en"))) return "en";
    const e8 = navigator.language.toLowerCase().split("-")[0];
    return this.supportedLocales.includes(e8) ? e8 : "en";
  }
  async init(e8) {
    const t3 = this.getBrowserLanguage() || e8.fallbackLng;
    await this.loadTranslations(t3);
  }
  async loadTranslations(e8) {
    const t3 = e8.split("-")[0];
    if ("en" !== t3 && this.supportedLocales.includes(t3)) try {
      const e9 = `${this.baseUrl}/${t3}.json`, n2 = await fetch(e9);
      if (!n2.ok) throw new Error(`HTTP error! status: ${n2.status}`);
      this.translations = await n2.json();
    } catch (e9) {
      console.warn(`❌ Failed to load ${t3} translations, falling back to English:`, e9), this.translations = hg;
    }
    else this.translations = hg;
  }
  t(e8) {
    return this.getNestedTranslation(e8, this.translations) || e8;
  }
  getNestedTranslation(e8, t3) {
    const n2 = e8.split(".");
    let r3 = t3;
    for (const e9 of n2) {
      if ("object" != typeof r3) return "";
      r3 = r3[e9];
    }
    return "string" == typeof r3 ? r3 : "";
  }
};
var pg;
!function(e8) {
  e8.SDK_MODAL_VIEWED = "sdk_modal_viewed", e8.SDK_MODAL_BUTTON_CLICKED = "sdk_modal_button_clicked", e8.SDK_MODAL_TOGGLE_CHANGED = "sdk_modal_toggle_changed";
}(pg || (pg = {}));
var gg = class {
  constructor(e8) {
    mf(this, e8), this.close = Jf(this, "close", 7), this.startDesktopOnboarding = Jf(this, "startDesktopOnboarding", 7), this.trackAnalytics = Jf(this, "trackAnalytics", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = true, this.translationsLoaded = false, this.onClose = this.onClose.bind(this), this.onStartDesktopOnboardingHandler = this.onStartDesktopOnboardingHandler.bind(this), this.setTab = this.setTab.bind(this), this.render = this.render.bind(this), this.setTab(this.preferDesktop ? 1 : 2), this.i18nInstance = new fg();
  }
  componentDidLoad() {
    this.trackAnalytics.emit({ event: pg.SDK_MODAL_VIEWED, params: { extensionInstalled: false, tab: 1 === this.tab ? "desktop" : "mobile" } });
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  updatePreferDesktop(e8) {
    e8 ? this.setTab(1) : this.setTab(2);
  }
  onClose(e8 = false) {
    this.close.emit({ shouldTerminate: e8 });
  }
  onStartDesktopOnboardingHandler() {
    this.trackAnalytics.emit({ event: pg.SDK_MODAL_BUTTON_CLICKED, params: { button_type: "install_extension", tab: "desktop" } }), this.startDesktopOnboarding.emit();
  }
  setTab(e8, t3 = false) {
    t3 && this.trackAnalytics.emit({ event: pg.SDK_MODAL_TOGGLE_CHANGED, params: { toggle: 1 === this.tab ? "desktop_to_mobile" : "mobile_to_desktop" } }), this.tab = e8, this.isDefaultTab = false;
  }
  render() {
    if (!this.translationsLoaded) return null;
    const e8 = (e9) => this.i18nInstance.t(e9), t3 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, n2 = ug(this.link, "svg", { ecc: "medium", scale: 2 });
    return zf($p, { className: "install-model" }, zf("div", { class: "backdrop", onClick: () => this.onClose(true) }), zf("div", { class: "modal" }, zf("div", { class: "closeButtonContainer" }, zf("div", { class: "right" }, zf("span", { class: "closeButton", onClick: () => this.onClose(true) }, zf(zp, null)))), zf("div", { class: "logoContainer" }, zf(qp, null)), zf("div", null, zf("div", { class: "tabcontainer" }, zf("div", { class: "flexContainer" }, zf("div", { onClick: () => this.setTab(1, true), class: "tab flexItem " + (1 === t3 ? "tabactive" : "") }, e8("DESKTOP")), zf("div", { onClick: () => this.setTab(2, true), class: "tab flexItem " + (2 === t3 ? "tabactive" : "") }, e8("MOBILE")))), zf("div", { style: { display: 1 === t3 ? "none" : "block" } }, zf("div", { class: "flexContainer" }, zf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, n2 && zf("div", { id: "sdk-mm-qrcode", class: "center", innerHTML: n2 }), zf("div", { class: "connectMobileText" }, e8("SCAN_TO_CONNECT"), " ", zf("br", null), zf("span", { class: "blue" }, zf("b", null, e8("META_MASK_MOBILE_APP"))))))), zf("div", { style: { display: 2 === t3 ? "none" : "block" } }, zf("div", { class: "item" }, zf(Bp, { Icon: jp, text: e8("INSTALL_MODAL.TRUSTED_BY_USERS") })), zf("div", { class: "item" }, zf(Bp, { Icon: Kp, text: e8("INSTALL_MODAL.LEADING_CRYPTO_WALLET") })), zf("div", { class: "item" }, zf(Bp, { Icon: Up, text: e8("INSTALL_MODAL.CONTROL_DIGITAL_INTERACTIONS") })), zf("button", { class: "button", onClick: () => this.onStartDesktopOnboardingHandler() }, zf(Hp, null), zf("span", { class: "installExtensionText" }, e8("INSTALL_MODAL.INSTALL_META_MASK_EXTENSION"))))), zf(Fp, { version: this.sdkVersion })));
  }
  get el() {
    return Zf(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
gg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var mg = class {
  constructor(e8) {
    mf(this, e8), this.close = Jf(this, "close", 7), this.disconnect = Jf(this, "disconnect", 7), this.updateOTPValue = Jf(this, "updateOTPValue", 7), this.displayOTP = void 0, this.sdkVersion = void 0, this.otpCode = void 0, this.translationsLoaded = false, this.i18nInstance = new fg();
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  onClose() {
    this.close.emit();
  }
  onDisconnect() {
    this.disconnect.emit();
  }
  onUpdateOTPValueHandler(e8) {
    this.updateOTPValue.emit({ otpValue: e8 });
  }
  disconnectedCallback() {
    this.onClose();
  }
  render() {
    var e8;
    if (!this.translationsLoaded) return null;
    const t3 = null === (e8 = this.displayOTP) || void 0 === e8 || e8, n2 = this.sdkVersion, r3 = (e9) => this.i18nInstance.t(e9);
    return zf($p, { className: "pending-modal" }, zf("div", { class: "backdrop", onClick: () => this.onClose() }), zf("div", { class: "modal" }, zf("div", { class: "closeButtonContainer" }, zf("div", { class: "right" }, zf("span", { class: "closeButton", onClick: () => this.onClose() }, zf(zp, null)))), zf("div", { class: "logoContainer" }, zf(qp, null)), zf("div", null, zf("div", { class: "flexContainer", style: { flexDirection: "column", color: "black" } }, zf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "30px", marginBottom: "30px", fontSize: "16px" } }, r3(t3 ? "PENDING_MODAL.OPEN_META_MASK_SELECT_CODE" : "PENDING_MODAL.OPEN_META_MASK_CONTINUE")), zf("div", { id: "sdk-mm-otp-value", style: { padding: "10px", fontSize: "32px", display: this.otpCode ? "block" : "none" } }, this.otpCode), t3 && zf("div", { class: "notice" }, "* ", r3("PENDING_MODAL.NUMBER_AFTER_OPEN_NOTICE"))), zf("div", { style: { marginTop: "20px" } }, zf("button", { class: "button blue", style: { marginTop: "5px", color: "#0376C9", borderColor: "#0376C9", borderWidth: "1px", borderStyle: "solid", backgroundColor: "white" }, onClick: () => this.onDisconnect() }, r3("PENDING_MODAL.DISCONNECT")))), zf(Fp, { version: n2 })));
  }
  get el() {
    return Zf(this);
  }
};
mg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var yg = () => zf("svg", { width: "21", height: "15", viewBox: "0 0 21 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("path", { d: "M14.1364 14.9851C13.5909 14.9851 13.2273 14.5851 13.2273 13.9851C13.2273 13.3851 13.5909 12.9851 14.1364 12.9851C16.6818 12.9851 18.6818 10.7851 18.6818 7.98508C18.6818 5.18508 16.6818 2.98508 14.1364 2.98508C11.5909 2.98508 9.59091 5.18508 9.59091 7.98508C9.59091 8.58508 9.22727 8.98508 8.68182 8.98508C8.13636 8.98508 7.77273 8.58508 7.77273 7.98508C7.77273 4.08508 10.5909 0.985077 14.1364 0.985077C17.6818 0.985077 20.5 4.08508 20.5 7.98508C20.5 11.8851 17.6818 14.9851 14.1364 14.9851ZM6.68182 14.7851C3.22727 14.7851 0.5 11.6851 0.5 7.98508C0.5 4.28508 3.22727 1.18508 6.68182 1.18508C7.22727 1.18508 7.59091 1.58508 7.59091 2.18508C7.59091 2.78508 7.22727 3.18508 6.68182 3.18508C4.22727 3.18508 2.31818 5.38508 2.31818 7.98508C2.31818 10.5851 4.22727 12.7851 6.68182 12.7851C9.13636 12.7851 11.0455 10.6851 11.0455 7.98508C11.0455 7.38508 11.4091 6.98508 11.9545 6.98508C12.5 6.98508 12.8636 7.38508 12.8636 7.98508C12.7727 11.6851 10.0455 14.7851 6.68182 14.7851Z", fill: "white" }));
var vg = () => zf("svg", { width: "400", height: "300", viewBox: "0 0 400 300", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf("rect", { width: "400", height: "300", fill: "white" }), zf("path", { d: "M300.116 242.46L250.485 227.681L213.057 250.055L186.944 250.045L149.493 227.681L99.8843 242.46L84.7939 191.518L99.8843 134.979L84.7939 87.1777L99.8843 27.9336L177.402 74.2466H222.598L300.116 27.9336L315.206 87.1777L300.116 134.979L315.206 191.518L300.116 242.46Z", fill: "#FF5C16" }), zf("path", { d: "M99.8955 27.9336L177.414 74.2792L174.331 106.085L99.8955 27.9336Z", fill: "#FF5C16" }), zf("path", { d: "M149.505 191.539L183.612 217.521L149.505 227.681V191.539Z", fill: "#FF5C16" }), zf("path", { d: "M180.886 148.585L174.33 106.107L132.369 134.991L132.348 134.98V135.001L132.477 164.732L149.493 148.585H149.504H180.886Z", fill: "#FF5C16" }), zf("path", { d: "M300.116 27.9336L222.598 74.2792L225.67 106.085L300.116 27.9336Z", fill: "#FF5C16" }), zf("path", { d: "M250.508 191.539L216.4 217.521L250.508 227.681V191.539Z", fill: "#FF5C16" }), zf("path", { d: "M267.652 135.001H267.663H267.652V134.98L267.641 134.991L225.68 106.107L219.125 148.585H250.507L267.533 164.732L267.652 135.001Z", fill: "#FF5C16" }), zf("path", { d: "M149.493 227.681L99.8843 242.46L84.7939 191.54H149.493V227.681Z", fill: "#E34807" }), zf("path", { d: "M180.875 148.574L190.351 209.98L177.219 175.838L132.456 164.732L149.483 148.574H180.864H180.875Z", fill: "#E34807" }), zf("path", { d: "M250.507 227.681L300.116 242.46L315.206 191.54H250.507V227.681Z", fill: "#E34807" }), zf("path", { d: "M219.126 148.574L209.649 209.98L222.782 175.838L267.545 164.732L250.507 148.574H219.126Z", fill: "#E34807" }), zf("path", { d: "M84.7939 191.517L99.8843 134.979H132.337L132.456 164.721L177.219 175.826L190.351 209.969L183.601 217.488L149.493 191.506H84.7939V191.517Z", fill: "#FF8D5D" }), zf("path", { d: "M315.206 191.517L300.116 134.979H267.664L267.545 164.721L222.782 175.826L209.649 209.969L216.4 217.488L250.507 191.506H315.206V191.517Z", fill: "#FF8D5D" }), zf("path", { d: "M222.598 74.2466H200H177.402L174.33 106.053L190.351 209.936H209.649L225.681 106.053L222.598 74.2466Z", fill: "#FF8D5D" }), zf("path", { d: "M99.8843 27.9336L84.7939 87.1777L99.8843 134.979H132.337L174.319 106.085L99.8843 27.9336Z", fill: "#661800" }), zf("path", { d: "M171.496 160.906H156.795L148.79 168.752L177.229 175.804L171.496 160.896V160.906Z", fill: "#661800" }), zf("path", { d: "M300.116 27.9336L315.206 87.1777L300.116 134.979H267.663L225.681 106.085L300.116 27.9336Z", fill: "#661800" }), zf("path", { d: "M228.525 160.906H243.248L251.253 168.763L222.781 175.826L228.525 160.896V160.906Z", fill: "#661800" }), zf("path", { d: "M213.046 229.789L216.399 217.51L209.649 209.991H190.34L183.59 217.51L186.943 229.789", fill: "#661800" }), zf("path", { d: "M213.047 229.789V250.066H186.944V229.789H213.047Z", fill: "#C0C4CD" }), zf("path", { d: "M149.504 227.66L186.965 250.056V229.779L183.611 217.5L149.504 227.66Z", fill: "#E7EBF6" }), zf("path", { d: "M250.506 227.66L213.045 250.056V229.779L216.398 217.5L250.506 227.66Z", fill: "#E7EBF6" }));
var bg = class {
  constructor(e8) {
    mf(this, e8), this.close = Jf(this, "close", 7), this.connectWithExtension = Jf(this, "connectWithExtension", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = true, this.translationsLoaded = false, this.i18nInstance = new fg(), this.setTab(this.preferDesktop ? 1 : 2);
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  onClose(e8 = false) {
    this.close.emit({ shouldTerminate: e8 });
  }
  connectWithExtensionHandler() {
    this.connectWithExtension.emit();
  }
  setTab(e8) {
    this.tab = e8, this.isDefaultTab = false;
  }
  disconnectedCallback() {
    this.onClose();
  }
  updatePreferDesktop(e8) {
    e8 ? this.setTab(1) : this.setTab(2);
  }
  render() {
    if (!this.translationsLoaded) return null;
    const e8 = (e9) => this.i18nInstance.t(e9), t3 = this.sdkVersion, n2 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, r3 = ug(this.link, "svg", { ecc: "medium", scale: 2 });
    return zf($p, { className: "select-modal" }, zf("div", { class: "backdrop", onClick: () => this.onClose(true) }), zf("div", { class: "modal" }, zf("div", { class: "closeButtonContainer" }, zf("div", { class: "right" }, zf("span", { class: "closeButton", onClick: () => this.onClose(true) }, zf(zp, null)))), zf("div", { class: "logoContainer" }, zf(qp, null)), zf("div", null, zf("div", { class: "tabcontainer" }, zf("div", { class: "flexContainer" }, zf("div", { onClick: () => this.setTab(1), class: "tab flexItem " + (1 === n2 ? "tabactive" : "") }, e8("DESKTOP")), zf("div", { onClick: () => this.setTab(2), class: "tab flexItem " + (2 === n2 ? "tabactive" : "") }, e8("MOBILE")))), zf("div", { style: { display: 1 === n2 ? "none" : "block" } }, zf("div", { class: "flexContainer" }, zf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, zf("div", { class: "center", id: "sdk-mm-qrcode", innerHTML: r3 }), zf("div", { class: "connectMobileText" }, e8("SCAN_TO_CONNECT"), zf("br", null), zf("span", { class: "blue" }, zf("b", null, e8("META_MASK_MOBILE_APP"))))))), zf("div", { style: { display: 2 === n2 ? "none" : "block" } }, zf("div", { style: { display: "flex", justifyContent: "center", height: "300", marginTop: "-20" } }, zf(vg, null)), zf("div", { class: "extensionLabel" }, e8("SELECT_MODAL.CRYPTO_TAKE_CONTROL_TEXT")), zf("button", { class: "button", onClick: () => this.connectWithExtensionHandler() }, zf(yg, null), zf("span", { class: "installExtensionText" }, e8("CONNECT_WITH_EXTENSION"))))), zf(Fp, { version: t3 })));
  }
  get el() {
    return Zf(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
bg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var wg = Object.freeze({ __proto__: null, mm_install_modal: gg, mm_pending_modal: mg, mm_select_modal: bg });

// node_modules/@web3auth/no-modal/dist/lib.esm/connectors/metamask-connector/metamaskConnector.js
var import_deepmerge2 = __toESM(require_cjs());
var MetaMaskConnector = class extends BaseEvmConnector {
  constructor(connectorOptions) {
    super(connectorOptions);
    _defineProperty(this, "connectorNamespace", CONNECTOR_NAMESPACES.EIP155);
    _defineProperty(this, "currentChainNamespace", CHAIN_NAMESPACES.EIP155);
    _defineProperty(this, "type", CONNECTOR_CATEGORY.EXTERNAL);
    _defineProperty(this, "name", WALLET_CONNECTORS.METAMASK);
    _defineProperty(this, "status", CONNECTOR_STATUS.NOT_READY);
    _defineProperty(this, "metamaskProvider", null);
    _defineProperty(this, "metamaskSDK", null);
    _defineProperty(this, "metamaskOptions", void 0);
    _defineProperty(this, "analytics", void 0);
    this.metamaskOptions = connectorOptions.connectorSettings;
    this.analytics = connectorOptions.analytics;
  }
  get provider() {
    if (this.status !== CONNECTOR_STATUS.NOT_READY && this.metamaskProvider) {
      return this.metamaskProvider;
    }
    return null;
  }
  set provider(_3) {
    throw new Error("Not implemented");
  }
  async init(options2) {
    var _metamaskOptions$useD;
    await super.init(options2);
    const chainConfig = this.coreOptions.chains.find((x3) => x3.chainId === options2.chainId);
    super.checkInitializationRequirements({
      chainConfig
    });
    const iconUrl = await getSiteIcon(window);
    const appMetadata = {
      name: getSiteName(window) || "web3auth",
      url: window.location.origin || "https://web3auth.io",
      iconUrl
    };
    const metamaskOptions = (0, import_deepmerge2.default)(this.metamaskOptions || {}, {
      dappMetadata: appMetadata
    });
    this.metamaskSDK = new af(_objectSpread2(_objectSpread2({}, metamaskOptions), {}, {
      _source: "web3auth",
      useDeeplink: (_metamaskOptions$useD = metamaskOptions.useDeeplink) !== null && _metamaskOptions$useD !== void 0 ? _metamaskOptions$useD : true
    }));
    const initResult = await this.metamaskSDK.init();
    if (initResult) {
      this.metamaskSDK = initResult;
    }
    this.isInjected = this.metamaskSDK.isExtensionActive();
    this.status = CONNECTOR_STATUS.READY;
    this.emit(CONNECTOR_EVENTS.READY, WALLET_CONNECTORS.METAMASK);
    try {
      if (options2.autoConnect) {
        this.rehydrated = true;
        const provider = await this.connect({
          chainId: options2.chainId
        });
        if (!provider) {
          this.rehydrated = false;
          throw WalletLoginError.connectionError("Failed to rehydrate.");
        }
      }
    } catch (error) {
      this.emit(CONNECTOR_EVENTS.REHYDRATION_ERROR, error);
    }
  }
  async connect({
    chainId
  }) {
    super.checkConnectionRequirements();
    if (!this.metamaskSDK) throw WalletLoginError.notConnectedError("Connector is not initialized");
    const chainConfig = this.coreOptions.chains.find((x3) => x3.chainId === chainId);
    if (!chainConfig) throw WalletLoginError.connectionError("Chain config is not available");
    const shouldTrack = !this.isInjected && !this.rehydrated;
    const startTime = Date.now();
    const eventData = {
      connector: this.name,
      connector_type: this.type,
      is_injected: this.isInjected,
      chain_id: getCaipChainId(chainConfig),
      chain_name: chainConfig === null || chainConfig === void 0 ? void 0 : chainConfig.displayName,
      chain_namespace: chainConfig === null || chainConfig === void 0 ? void 0 : chainConfig.chainNamespace
    };
    try {
      if (this.status !== CONNECTOR_STATUS.CONNECTING) {
        var _this$metamaskOptions;
        this.status = CONNECTOR_STATUS.CONNECTING;
        this.emit(CONNECTOR_EVENTS.CONNECTING, {
          connector: WALLET_CONNECTORS.METAMASK
        });
        if (!this.metamaskSDK.isExtensionActive() && (_this$metamaskOptions = this.metamaskOptions) !== null && _this$metamaskOptions !== void 0 && _this$metamaskOptions.headless) {
          this.metamaskSDK.getProvider().on("display_uri", (uri) => {
            this.updateConnectorData({
              uri
            });
          });
        }
        await this.metamaskSDK.connect();
      }
      this.metamaskProvider = this.metamaskSDK.getProvider();
      if (!this.metamaskProvider) throw WalletLoginError.notConnectedError("Failed to connect with provider");
      const currentChainId = await this.metamaskProvider.request({
        method: "eth_chainId"
      });
      if (currentChainId !== chainConfig.chainId) {
        await this.switchChain(chainConfig, true);
      }
      const accountDisconnectHandler = (accounts) => {
        if (accounts.length === 0) this.disconnect();
      };
      this.metamaskProvider.on("accountsChanged", accountDisconnectHandler);
      this.metamaskProvider.once("disconnect", () => {
        this.disconnect();
      });
      this.status = CONNECTOR_STATUS.CONNECTED;
      if (shouldTrack) {
        var _this$analytics, _this$analytics2;
        (_this$analytics = this.analytics) === null || _this$analytics === void 0 || _this$analytics.track(ANALYTICS_EVENTS.CONNECTION_STARTED, eventData);
        (_this$analytics2 = this.analytics) === null || _this$analytics2 === void 0 || _this$analytics2.track(ANALYTICS_EVENTS.CONNECTION_COMPLETED, _objectSpread2(_objectSpread2({}, eventData), {}, {
          duration: Date.now() - startTime
        }));
      }
      this.emit(CONNECTOR_EVENTS.CONNECTED, {
        connector: WALLET_CONNECTORS.METAMASK,
        reconnected: this.rehydrated,
        provider: this.metamaskProvider
      });
      return this.metamaskProvider;
    } catch (error) {
      this.status = CONNECTOR_STATUS.READY;
      if (!this.rehydrated) this.emit(CONNECTOR_EVENTS.ERRORED, error);
      this.rehydrated = false;
      if (shouldTrack) {
        var _this$analytics3, _this$analytics4;
        (_this$analytics3 = this.analytics) === null || _this$analytics3 === void 0 || _this$analytics3.track(ANALYTICS_EVENTS.CONNECTION_STARTED, eventData);
        (_this$analytics4 = this.analytics) === null || _this$analytics4 === void 0 || _this$analytics4.track(ANALYTICS_EVENTS.CONNECTION_FAILED, _objectSpread2(_objectSpread2(_objectSpread2({}, eventData), getErrorAnalyticsProperties(error)), {}, {
          duration: Date.now() - startTime
        }));
      }
      if (error instanceof Web3AuthError) throw error;
      throw WalletLoginError.connectionError("Failed to login with MetaMask wallet", error);
    }
  }
  async disconnect(options2 = {
    cleanup: false
  }) {
    if (!this.metamaskProvider) throw WalletLoginError.connectionError("MetaMask provider is not available");
    await super.disconnectSession();
    if (typeof this.metamaskProvider.removeAllListeners !== "undefined") this.metamaskProvider.removeAllListeners();
    await this.metamaskSDK.terminate();
    if (options2.cleanup) {
      this.status = CONNECTOR_STATUS.NOT_READY;
      this.metamaskProvider = null;
    } else {
      this.status = CONNECTOR_STATUS.READY;
    }
    await super.disconnect();
  }
  async getUserInfo() {
    if (this.status !== CONNECTOR_STATUS.CONNECTED) throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
    return {};
  }
  async switchChain(params, init2 = false) {
    super.checkSwitchChainRequirements(params, init2);
    const requestSwitchChain = () => this.metamaskProvider.request({
      method: "wallet_switchEthereumChain",
      params: [{
        chainId: params.chainId
      }]
    });
    try {
      await requestSwitchChain();
    } catch (error) {
      if ((error === null || error === void 0 ? void 0 : error.code) === 4902) {
        const chainConfig = this.coreOptions.chains.find((x3) => x3.chainId === params.chainId && [CHAIN_NAMESPACES.EIP155, CHAIN_NAMESPACES.SOLANA].includes(x3.chainNamespace));
        await this.addChain(chainConfig);
        await requestSwitchChain();
      } else {
        throw error;
      }
    }
  }
  async enableMFA() {
    throw new Error("Method Not implemented");
  }
  async manageMFA() {
    throw new Error("Method Not implemented");
  }
  async addChain(chainConfig) {
    if (!this.metamaskProvider) throw WalletLoginError.connectionError("Injected provider is not available");
    await this.metamaskProvider.request({
      method: "wallet_addEthereumChain",
      params: [{
        chainId: chainConfig.chainId,
        chainName: chainConfig.displayName,
        rpcUrls: [chainConfig.rpcTarget],
        blockExplorerUrls: [chainConfig.blockExplorerUrl],
        nativeCurrency: {
          name: chainConfig.tickerName,
          symbol: chainConfig.ticker,
          decimals: chainConfig.decimals || 18
        },
        iconUrls: [chainConfig.logo]
      }]
    });
  }
};
var metaMaskConnector = (params) => {
  return ({
    coreOptions,
    analytics
  }) => {
    return new MetaMaskConnector({
      connectorSettings: params,
      coreOptions,
      analytics
    });
  };
};

// node_modules/@web3auth/no-modal/dist/lib.esm/base/plugin/IPlugin.js
var PLUGIN_NAMESPACES = _objectSpread2(_objectSpread2({}, CHAIN_NAMESPACES), {}, {
  MULTICHAIN: "multichain"
});
var PLUGIN_STATUS = {
  READY: "ready",
  CONNECTING: "connecting",
  CONNECTED: "connected",
  DISCONNECTED: "disconnected",
  ERRORED: "errored"
};
var PLUGIN_EVENTS = _objectSpread2({}, PLUGIN_STATUS);
var EVM_PLUGINS = {
  WALLET_SERVICES: "wallet-services",
  NFT_CHECKOUT: "nft-checkout"
};
var SOLANA_PLUGINS = {
  SOLANA: "solana"
};
var WALLET_PLUGINS = _objectSpread2(_objectSpread2({}, EVM_PLUGINS), SOLANA_PLUGINS);

// node_modules/@web3auth/no-modal/dist/lib.esm/base/plugin/errors.js
var WalletServicesPluginError = class _WalletServicesPluginError extends Web3AuthError {
  constructor(code, message, cause) {
    super(code, message, cause);
    Object.defineProperty(this, "name", {
      value: "WalletServicesPluginError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new _WalletServicesPluginError(code, `${_WalletServicesPluginError.messages[code]}${extraMessage}`, cause);
  }
  static notInitialized(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5210, extraMessage, cause);
  }
  static unsupportedConnector(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5211, extraMessage, cause);
  }
  static providerRequired(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5212, extraMessage, cause);
  }
  static web3authRequired(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5213, extraMessage, cause);
  }
  static web3AuthNotConnected(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5214, extraMessage, cause);
  }
  static alreadyInitialized(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5216, extraMessage, cause);
  }
  static unsupportedChainNamespace(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5218, extraMessage, cause);
  }
  static differentWeb3AuthNetwork(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5219, extraMessage, cause);
  }
  static invalidParams(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5220, extraMessage, cause);
  }
  static web3authNotInitialized(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5221, extraMessage, cause);
  }
  static invalidSession(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5222, extraMessage, cause);
  }
  static walletPluginNotConnected(extraMessage = "", cause) {
    return _WalletServicesPluginError.fromCode(5223, extraMessage, cause);
  }
};
_defineProperty(WalletServicesPluginError, "messages", {
  5210: "Wallet Services Plugin is not initialized",
  5211: "Web3Auth is connected to unsupported connector. Wallet services connector plugin requires web3auth connected to auth connector.",
  5212: "Provider is required..",
  5213: "Web3Auth instance is required while initialization.",
  5214: "Web3Auth is not connected.",
  5216: "Plugin is already initialized",
  5218: "Unsupported chain namespace.",
  5219: "Plugin network different than web3auth instance network.",
  5221: "Web3Auth is not initialized",
  5222: "Invalid session inside wallet services. Please report this issue.",
  5223: "Wallet plugin is not connected Yet. Please wait for plugin to connect and listen via `connected` event on the plugin"
});
var NFTCheckoutPluginError = class _NFTCheckoutPluginError extends Web3AuthError {
  constructor(code, message, cause) {
    super(code, message, cause);
    Object.defineProperty(this, "name", {
      value: "NFTCheckoutPluginError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new _NFTCheckoutPluginError(code, `${_NFTCheckoutPluginError.messages[code]}${extraMessage}`, cause);
  }
  static notInitialized(extraMessage = "", cause) {
    return _NFTCheckoutPluginError.fromCode(6210, extraMessage, cause);
  }
  static providerRequired(extraMessage = "", cause) {
    return _NFTCheckoutPluginError.fromCode(6212, extraMessage, cause);
  }
  static web3authRequired(extraMessage = "", cause) {
    return _NFTCheckoutPluginError.fromCode(6213, extraMessage, cause);
  }
  static web3AuthNotConnected(extraMessage = "", cause) {
    return _NFTCheckoutPluginError.fromCode(6214, extraMessage, cause);
  }
  static pluginNotConnected(extraMessage = "", cause) {
    return _NFTCheckoutPluginError.fromCode(6223, extraMessage, cause);
  }
};
_defineProperty(NFTCheckoutPluginError, "messages", {
  6210: "NFT Checkout Plugin is not initialized",
  6212: "Provider is required..",
  6213: "Web3Auth instance is required while initialization.",
  6214: "Web3Auth is not connected.",
  6223: "NFT Checkout plugin is not connected Yet. Please wait for plugin to connect and listen via `connected` event on the plugin"
});

// node_modules/@web3auth/no-modal/dist/lib.esm/plugins/wallet-services-plugin/plugin.js
var WalletServicesPlugin = class extends SafeEventEmitter {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "name", EVM_PLUGINS.WALLET_SERVICES);
    _defineProperty(this, "status", PLUGIN_STATUS.DISCONNECTED);
    _defineProperty(this, "SUPPORTED_CONNECTORS", [WALLET_CONNECTORS.AUTH]);
    _defineProperty(this, "pluginNamespace", PLUGIN_NAMESPACES.MULTICHAIN);
    _defineProperty(this, "wsEmbedInstance", void 0);
    _defineProperty(this, "provider", null);
    _defineProperty(this, "web3auth", null);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "analytics", void 0);
  }
  get proxyProvider() {
    var _this$wsEmbedInstance;
    return (_this$wsEmbedInstance = this.wsEmbedInstance) !== null && _this$wsEmbedInstance !== void 0 && _this$wsEmbedInstance.provider ? this.wsEmbedInstance.provider : null;
  }
  async initWithWeb3Auth(web3auth, _whiteLabel, analytics) {
    if (this.isInitialized) return;
    if (!web3auth) throw WalletServicesPluginError.web3authRequired();
    if (web3auth.provider && !this.SUPPORTED_CONNECTORS.includes(web3auth.connectedConnectorName)) throw WalletServicesPluginError.notInitialized();
    const currentChainConfig = web3auth.currentChain;
    if (![CHAIN_NAMESPACES.EIP155, CHAIN_NAMESPACES.SOLANA].includes(currentChainConfig === null || currentChainConfig === void 0 ? void 0 : currentChainConfig.chainNamespace)) throw WalletServicesPluginError.unsupportedChainNamespace();
    if (web3auth.provider) {
      this.provider = web3auth.provider;
    }
    this.web3auth = web3auth;
    this.analytics = analytics;
    const authInstance = web3auth.getConnector(WALLET_CONNECTORS.AUTH);
    if (!authInstance || !authInstance.wsEmbed) throw WalletServicesPluginError.web3AuthNotConnected();
    this.wsEmbedInstance = authInstance.wsEmbed;
    this.isInitialized = true;
    this.status = PLUGIN_STATUS.READY;
    this.emit(PLUGIN_EVENTS.READY);
  }
  initWithProvider() {
    throw new Error("Method not implemented.");
  }
  async connect() {
    if (!this.isInitialized) throw WalletServicesPluginError.notInitialized();
    this.emit(PLUGIN_EVENTS.CONNECTING);
    this.status = PLUGIN_STATUS.CONNECTING;
    if (!this.provider) {
      var _this$web3auth;
      if ((_this$web3auth = this.web3auth) !== null && _this$web3auth !== void 0 && _this$web3auth.provider) {
        this.provider = this.web3auth.provider;
      }
    }
    if (this.web3auth.status !== CONNECTOR_STATUS.CONNECTED) {
      throw WalletServicesPluginError.web3AuthNotConnected();
    } else if (!this.web3auth.provider) {
      throw WalletServicesPluginError.providerRequired();
    }
    try {
      this.emit(PLUGIN_EVENTS.CONNECTED);
      this.status = PLUGIN_STATUS.CONNECTED;
    } catch (error) {
      log.error(error);
      this.status = PLUGIN_STATUS.ERRORED;
      this.emit(PLUGIN_EVENTS.ERRORED, {
        error: error.message || "Something went wrong"
      });
    }
  }
  async showWalletConnectScanner(showWalletConnectParams) {
    var _this$wsEmbedInstance2, _this$analytics;
    if (!((_this$wsEmbedInstance2 = this.wsEmbedInstance) !== null && _this$wsEmbedInstance2 !== void 0 && _this$wsEmbedInstance2.isLoggedIn)) throw WalletServicesPluginError.walletPluginNotConnected();
    (_this$analytics = this.analytics) === null || _this$analytics === void 0 || _this$analytics.track(ANALYTICS_EVENTS.WALLET_CONNECT_SCANNER_CLICKED, {
      is_visible: showWalletConnectParams === null || showWalletConnectParams === void 0 ? void 0 : showWalletConnectParams.show
    });
    return this.wsEmbedInstance.showWalletConnectScanner(showWalletConnectParams);
  }
  async showCheckout(showCheckoutParams) {
    var _this$wsEmbedInstance3, _this$analytics2;
    if (!((_this$wsEmbedInstance3 = this.wsEmbedInstance) !== null && _this$wsEmbedInstance3 !== void 0 && _this$wsEmbedInstance3.isLoggedIn)) throw WalletServicesPluginError.walletPluginNotConnected();
    (_this$analytics2 = this.analytics) === null || _this$analytics2 === void 0 || _this$analytics2.track(ANALYTICS_EVENTS.WALLET_CHECKOUT_CLICKED, {
      is_visible: showCheckoutParams === null || showCheckoutParams === void 0 ? void 0 : showCheckoutParams.show,
      receive_wallet_address_enabled: !!(showCheckoutParams !== null && showCheckoutParams !== void 0 && showCheckoutParams.receiveWalletAddress),
      token_list: showCheckoutParams === null || showCheckoutParams === void 0 ? void 0 : showCheckoutParams.tokenList,
      fiat_list: showCheckoutParams === null || showCheckoutParams === void 0 ? void 0 : showCheckoutParams.fiatList
    });
    return this.wsEmbedInstance.showCheckout(showCheckoutParams);
  }
  async showWalletUi(showWalletUiParams) {
    var _this$wsEmbedInstance4, _this$analytics3;
    if (!((_this$wsEmbedInstance4 = this.wsEmbedInstance) !== null && _this$wsEmbedInstance4 !== void 0 && _this$wsEmbedInstance4.isLoggedIn)) throw WalletServicesPluginError.walletPluginNotConnected();
    (_this$analytics3 = this.analytics) === null || _this$analytics3 === void 0 || _this$analytics3.track(ANALYTICS_EVENTS.WALLET_UI_CLICKED, {
      is_visible: showWalletUiParams === null || showWalletUiParams === void 0 ? void 0 : showWalletUiParams.show,
      path: showWalletUiParams === null || showWalletUiParams === void 0 ? void 0 : showWalletUiParams.path
    });
    return this.wsEmbedInstance.showWalletUi(showWalletUiParams);
  }
  async showSwap(showSwapParams) {
    var _this$wsEmbedInstance5, _this$analytics4;
    if (!((_this$wsEmbedInstance5 = this.wsEmbedInstance) !== null && _this$wsEmbedInstance5 !== void 0 && _this$wsEmbedInstance5.isLoggedIn)) throw WalletServicesPluginError.walletPluginNotConnected();
    (_this$analytics4 = this.analytics) === null || _this$analytics4 === void 0 || _this$analytics4.track(ANALYTICS_EVENTS.WALLET_SWAP_CLICKED, {
      is_visible: showSwapParams === null || showSwapParams === void 0 ? void 0 : showSwapParams.show,
      from_token: showSwapParams === null || showSwapParams === void 0 ? void 0 : showSwapParams.fromToken,
      to_token: showSwapParams === null || showSwapParams === void 0 ? void 0 : showSwapParams.toToken,
      from_value_enabled: !!(showSwapParams !== null && showSwapParams !== void 0 && showSwapParams.fromValue),
      to_address_enabled: !!(showSwapParams !== null && showSwapParams !== void 0 && showSwapParams.toAddress)
    });
    return this.wsEmbedInstance.showSwap(showSwapParams);
  }
  async cleanup() {
    var _this$wsEmbedInstance6;
    return (_this$wsEmbedInstance6 = this.wsEmbedInstance) === null || _this$wsEmbedInstance6 === void 0 ? void 0 : _this$wsEmbedInstance6.cleanUp();
  }
  async disconnect() {
    var _this$wsEmbedInstance7;
    if (this.status !== PLUGIN_STATUS.CONNECTED) throw WalletServicesPluginError.invalidSession("Wallet Services plugin is not connected");
    if ((_this$wsEmbedInstance7 = this.wsEmbedInstance) !== null && _this$wsEmbedInstance7 !== void 0 && _this$wsEmbedInstance7.isLoggedIn) {
      await this.wsEmbedInstance.logout();
    }
    this.emit(PLUGIN_EVENTS.DISCONNECTED);
    this.status = PLUGIN_STATUS.DISCONNECTED;
  }
};
var walletServicesPlugin = () => {
  return () => {
    return new WalletServicesPlugin();
  };
};

// node_modules/@web3auth/no-modal/dist/lib.esm/noModal.js
var import_deepmerge3 = __toESM(require_cjs());
var _excluded = ["walletScope"];
var Web3AuthNoModal = class extends SafeEventEmitter {
  constructor(options2, initialState) {
    super();
    _defineProperty(this, "coreOptions", void 0);
    _defineProperty(this, "status", CONNECTOR_STATUS.NOT_READY);
    _defineProperty(this, "aaProvider", null);
    _defineProperty(this, "connectors", []);
    _defineProperty(this, "commonJRPCProvider", null);
    _defineProperty(this, "analytics", void 0);
    _defineProperty(this, "plugins", {});
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "state", {
      connectedConnectorName: null,
      cachedConnector: null,
      currentChainId: null,
      idToken: null
    });
    _defineProperty(this, "loginMode", LOGIN_MODE.NO_MODAL);
    if (!options2.clientId) throw WalletInitializationError.invalidParams("Please provide a valid clientId in constructor");
    if (options2.enableLogging) log.enableAll();
    else log.setLevel("error");
    if (!options2.storageType) options2.storageType = "local";
    this.coreOptions = options2;
    this.storage = this.getStorageMethod();
    this.analytics = new Analytics();
    this.analytics.setGlobalProperties({
      integration_type: ANALYTICS_INTEGRATION_TYPE.NATIVE_SDK
    });
    this.loadState(initialState);
    if (this.state.idToken && this.coreOptions.ssr) {
      this.status = CONNECTOR_STATUS.CONNECTED;
    }
  }
  get currentChain() {
    var _this$coreOptions$cha;
    if (!this.currentChainId) return void 0;
    return (_this$coreOptions$cha = this.coreOptions.chains) === null || _this$coreOptions$cha === void 0 ? void 0 : _this$coreOptions$cha.find((chain) => chain.chainId === this.currentChainId);
  }
  get connected() {
    return Boolean(this.connectedConnector);
  }
  get provider() {
    if (this.status !== CONNECTOR_STATUS.NOT_READY && this.commonJRPCProvider) {
      return this.commonJRPCProvider;
    }
    return null;
  }
  get connectedConnectorName() {
    return this.state.connectedConnectorName;
  }
  get cachedConnector() {
    return this.state.cachedConnector;
  }
  get currentChainId() {
    var _this$coreOptions$cha2;
    return this.state.currentChainId || this.coreOptions.defaultChainId || ((_this$coreOptions$cha2 = this.coreOptions.chains) === null || _this$coreOptions$cha2 === void 0 || (_this$coreOptions$cha2 = _this$coreOptions$cha2[0]) === null || _this$coreOptions$cha2 === void 0 ? void 0 : _this$coreOptions$cha2.chainId) || null;
  }
  get connectedConnector() {
    var _this$currentChain;
    return this.getConnector(this.connectedConnectorName, (_this$currentChain = this.currentChain) === null || _this$currentChain === void 0 ? void 0 : _this$currentChain.chainNamespace);
  }
  get accountAbstractionProvider() {
    return this.aaProvider;
  }
  set provider(_3) {
    throw new Error("Not implemented");
  }
  async init(options2) {
    const startTime = Date.now();
    this.analytics.init();
    this.analytics.identify(this.coreOptions.clientId, {
      web3auth_client_id: this.coreOptions.clientId,
      web3auth_network: this.coreOptions.web3AuthNetwork
    });
    this.analytics.setGlobalProperties({
      dapp_url: window.location.origin,
      sdk_name: ANALYTICS_SDK_TYPE.WEB_NO_MODAL,
      sdk_version: sdkVersion,
      // Required for organization analytics
      web3auth_client_id: this.coreOptions.clientId,
      web3auth_network: this.coreOptions.web3AuthNetwork
    });
    let trackData = {};
    try {
      var _authConnector$authIn, _this$coreOptions$uiC;
      const {
        signal
      } = options2 || {};
      let projectConfig;
      try {
        var _this$coreOptions$acc;
        projectConfig = await fetchProjectConfig({
          clientId: this.coreOptions.clientId,
          web3AuthNetwork: this.coreOptions.web3AuthNetwork,
          aaProvider: (_this$coreOptions$acc = this.coreOptions.accountAbstractionConfig) === null || _this$coreOptions$acc === void 0 ? void 0 : _this$coreOptions$acc.smartAccountType,
          authBuildEnv: this.coreOptions.authBuildEnv
        });
      } catch (e8) {
        const error = await serializeError(e8);
        log.error("Failed to fetch project configurations", error);
        throw WalletInitializationError.notReady("failed to fetch project configurations", error);
      }
      this.initAccountAbstractionConfig(projectConfig);
      this.initChainsConfig(projectConfig);
      this.initCachedConnectorAndChainId();
      this.initUIConfig(projectConfig);
      this.initWalletServicesConfig(projectConfig);
      this.analytics.setGlobalProperties({
        team_id: projectConfig.teamId
      });
      trackData = this.getInitializationTrackData();
      await withAbort(() => this.setupCommonJRPCProvider(), signal);
      this.on(CONNECTOR_EVENTS.CONNECTORS_UPDATED, async ({
        connectors: newConnectors
      }) => {
        const onAbortHandler = () => {
          var _this$connectors;
          if (((_this$connectors = this.connectors) === null || _this$connectors === void 0 ? void 0 : _this$connectors.length) > 0) {
            this.cleanup();
          }
        };
        await withAbort(() => Promise.all(newConnectors.map(this.setupConnector.bind(this))), signal, onAbortHandler);
        if (this.status === CONNECTOR_STATUS.NOT_READY) {
          this.status = CONNECTOR_STATUS.READY;
          this.emit(CONNECTOR_EVENTS.READY);
        }
      });
      await withAbort(() => this.loadConnectors({
        projectConfig
      }), signal);
      await withAbort(() => this.initPlugins(), signal);
      const authConnector2 = this.getConnector(WALLET_CONNECTORS.AUTH);
      trackData = _objectSpread2(_objectSpread2({}, trackData), {}, {
        connectors: this.connectors.map((connector) => connector.name),
        plugins: Object.keys(this.plugins),
        auth_ux_mode: (authConnector2 === null || authConnector2 === void 0 || (_authConnector$authIn = authConnector2.authInstance) === null || _authConnector$authIn === void 0 || (_authConnector$authIn = _authConnector$authIn.options) === null || _authConnector$authIn === void 0 ? void 0 : _authConnector$authIn.uxMode) || ((_this$coreOptions$uiC = this.coreOptions.uiConfig) === null || _this$coreOptions$uiC === void 0 ? void 0 : _this$coreOptions$uiC.uxMode)
      });
      this.analytics.track(ANALYTICS_EVENTS.SDK_INITIALIZATION_COMPLETED, _objectSpread2(_objectSpread2({}, trackData), {}, {
        duration: Date.now() - startTime
      }));
    } catch (error) {
      if (error instanceof DOMException && error.name === "AbortError") return;
      this.analytics.track(ANALYTICS_EVENTS.SDK_INITIALIZATION_FAILED, _objectSpread2(_objectSpread2(_objectSpread2({}, trackData), getErrorAnalyticsProperties2(error)), {}, {
        duration: Date.now() - startTime
      }));
      log.error("Failed to initialize modal", error);
      throw error;
    }
  }
  // we need to take into account the chainNamespace as for external connectors, same connector name can be used for multiple chain namespaces
  getConnector(connectorName, chainNamespace) {
    return this.connectors.find((connector) => {
      if (connector.name !== connectorName) return false;
      if (chainNamespace) {
        if (connector.connectorNamespace === CONNECTOR_NAMESPACES.MULTICHAIN) return true;
        return connector.connectorNamespace === chainNamespace;
      }
      return true;
    }) || null;
  }
  clearCache() {
    this.setState({
      connectedConnectorName: null,
      cachedConnector: null,
      currentChainId: null,
      idToken: null
    });
  }
  async cleanup() {
    for (const connector of this.connectors) {
      if (connector.cleanup) await connector.cleanup();
    }
  }
  async switchChain(params) {
    var _this$currentChain2;
    if (params.chainId === ((_this$currentChain2 = this.currentChain) === null || _this$currentChain2 === void 0 ? void 0 : _this$currentChain2.chainId)) return;
    const newChainConfig = this.coreOptions.chains.find((x3) => x3.chainId === params.chainId);
    if (!newChainConfig) throw WalletInitializationError.invalidParams("Invalid chainId");
    if (this.status === CONNECTOR_STATUS.CONNECTED && this.connectedConnector) {
      await this.connectedConnector.switchChain(params);
      return;
    }
    if (this.commonJRPCProvider) {
      await this.commonJRPCProvider.switchChain(params);
      return;
    }
    throw WalletInitializationError.notReady(`No wallet is ready`);
  }
  /**
   * Connect to a specific wallet connector
   * @param connectorName - Key of the wallet connector to use.
   */
  async connectTo(connectorName, loginParams, loginMode) {
    this.loginMode = loginMode || "no-modal";
    const connector = this.getConnector(connectorName, loginParams === null || loginParams === void 0 ? void 0 : loginParams.chainNamespace);
    if (!connector || !this.commonJRPCProvider) throw WalletInitializationError.notFound(`Please add wallet connector for ${connectorName} wallet, before connecting`);
    const initialChain = this.getInitialChainIdForConnector(connector);
    const finalLoginParams = _objectSpread2(_objectSpread2({}, loginParams), {}, {
      chainId: initialChain.chainId
    });
    const startTime = Date.now();
    let eventData;
    if (connectorName === WALLET_CONNECTORS.AUTH) {
      var _authInstance;
      const authLoginParams = loginParams;
      const authConnectionConfig = connector.getOAuthProviderConfig({
        authConnection: authLoginParams.authConnection,
        authConnectionId: authLoginParams.authConnectionId,
        groupedAuthConnectionId: authLoginParams.groupedAuthConnectionId
      });
      eventData = {
        connector: connectorName,
        connector_type: connector.type,
        chain_id: getCaipChainId(initialChain),
        chain_name: initialChain.displayName,
        chain_namespace: initialChain.chainNamespace,
        auth_connection: authLoginParams.authConnection,
        auth_connection_id: authLoginParams.authConnectionId,
        group_auth_connection_id: authLoginParams.groupedAuthConnectionId,
        mfa_level: authLoginParams.mfaLevel,
        wallet_key_enabled: authLoginParams.getWalletKey,
        extra_login_options_enabled: Boolean(authLoginParams.extraLoginOptions),
        dapp_share_enabled: Boolean(authLoginParams.dappShare),
        curve: authLoginParams.curve,
        auth_dapp_url: authLoginParams.dappUrl,
        is_sfa: Boolean(authLoginParams.idToken),
        is_default_auth_connection: authConnectionConfig === null || authConnectionConfig === void 0 ? void 0 : authConnectionConfig.isDefault,
        auth_ux_mode: (_authInstance = connector.authInstance) === null || _authInstance === void 0 || (_authInstance = _authInstance.options) === null || _authInstance === void 0 ? void 0 : _authInstance.uxMode
      };
    } else {
      eventData = {
        connector: connectorName,
        connector_type: connector.type,
        is_injected: connector.isInjected,
        chain_id: getCaipChainId(initialChain),
        chain_name: initialChain.displayName,
        chain_namespace: initialChain.chainNamespace
      };
    }
    this.analytics.track(ANALYTICS_EVENTS.CONNECTION_STARTED, eventData);
    return new Promise((resolve, reject) => {
      const cleanup = () => {
        this.off(CONNECTOR_EVENTS.CONNECTED, onConnected);
        this.off(CONNECTOR_EVENTS.ERRORED, onErrored);
      };
      const onConnected = async () => {
        const userInfo = await connector.getUserInfo();
        this.analytics.track(ANALYTICS_EVENTS.CONNECTION_COMPLETED, _objectSpread2(_objectSpread2({}, eventData), {}, {
          is_mfa_enabled: userInfo === null || userInfo === void 0 ? void 0 : userInfo.isMfaEnabled,
          duration: Date.now() - startTime
        }));
        cleanup();
        resolve(this.provider);
      };
      const onErrored = async (err) => {
        this.analytics.track(ANALYTICS_EVENTS.CONNECTION_FAILED, _objectSpread2(_objectSpread2(_objectSpread2({}, eventData), getErrorAnalyticsProperties2(err)), {}, {
          duration: Date.now() - startTime
        }));
        cleanup();
        reject(err);
      };
      this.once(CONNECTOR_EVENTS.CONNECTED, onConnected);
      this.once(CONNECTOR_EVENTS.ERRORED, onErrored);
      connector.connect(finalLoginParams);
      this.setCurrentChain(initialChain.chainId);
    });
  }
  async logout(options2 = {
    cleanup: false
  }) {
    if (this.status !== CONNECTOR_STATUS.CONNECTED || !this.connectedConnector) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    await this.connectedConnector.disconnect(options2);
  }
  async getUserInfo() {
    var _this$connectedConnec;
    log.debug("Getting user info", this.status, (_this$connectedConnec = this.connectedConnector) === null || _this$connectedConnec === void 0 ? void 0 : _this$connectedConnec.name);
    if (this.status !== CONNECTOR_STATUS.CONNECTED || !this.connectedConnector) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    return this.connectedConnector.getUserInfo();
  }
  async enableMFA(loginParams) {
    var _authConnector$authIn2;
    if (this.status !== CONNECTOR_STATUS.CONNECTED || !this.connectedConnector) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    if (this.connectedConnector.name !== WALLET_CONNECTORS.AUTH) throw WalletLoginError.unsupportedOperation(`EnableMFA is not supported for this connector.`);
    const authConnector2 = this.connectedConnector;
    const trackData = {
      connector: this.connectedConnector.name,
      auth_ux_mode: (_authConnector$authIn2 = authConnector2.authInstance) === null || _authConnector$authIn2 === void 0 || (_authConnector$authIn2 = _authConnector$authIn2.options) === null || _authConnector$authIn2 === void 0 ? void 0 : _authConnector$authIn2.uxMode
    };
    try {
      this.analytics.track(ANALYTICS_EVENTS.MFA_ENABLEMENT_STARTED, trackData);
      await this.connectedConnector.enableMFA(loginParams);
    } catch (error) {
      this.analytics.track(ANALYTICS_EVENTS.MFA_ENABLEMENT_FAILED, _objectSpread2(_objectSpread2({}, trackData), getErrorAnalyticsProperties2(error)));
      throw error;
    }
  }
  async manageMFA(loginParams) {
    var _authConnector$authIn3;
    if (this.status !== CONNECTOR_STATUS.CONNECTED || !this.connectedConnector) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    if (this.connectedConnector.name !== WALLET_CONNECTORS.AUTH) throw WalletLoginError.unsupportedOperation(`ManageMFA is not supported for this connector.`);
    const authConnector2 = this.connectedConnector;
    const trackData = {
      connector: this.connectedConnector.name,
      auth_ux_mode: (_authConnector$authIn3 = authConnector2.authInstance) === null || _authConnector$authIn3 === void 0 || (_authConnector$authIn3 = _authConnector$authIn3.options) === null || _authConnector$authIn3 === void 0 ? void 0 : _authConnector$authIn3.uxMode
    };
    try {
      this.analytics.track(ANALYTICS_EVENTS.MFA_MANAGEMENT_SELECTED, trackData);
      await this.connectedConnector.manageMFA(loginParams);
    } catch (error) {
      this.analytics.track(ANALYTICS_EVENTS.MFA_MANAGEMENT_FAILED, _objectSpread2(_objectSpread2({}, trackData), getErrorAnalyticsProperties2(error)));
      throw error;
    }
  }
  async getIdentityToken() {
    if (this.status !== CONNECTOR_STATUS.CONNECTED || !this.connectedConnector) throw WalletLoginError.notConnectedError(`No wallet is connected`);
    const trackData = {
      connector: this.connectedConnector.name
    };
    try {
      this.analytics.track(ANALYTICS_EVENTS.IDENTITY_TOKEN_STARTED, trackData);
      const identityToken = await this.connectedConnector.getIdentityToken();
      this.analytics.track(ANALYTICS_EVENTS.IDENTITY_TOKEN_COMPLETED, trackData);
      return identityToken;
    } catch (error) {
      this.analytics.track(ANALYTICS_EVENTS.IDENTITY_TOKEN_FAILED, _objectSpread2(_objectSpread2({}, trackData), getErrorAnalyticsProperties2(error)));
      throw error;
    }
  }
  getPlugin(name) {
    return this.plugins[name] || null;
  }
  setAnalyticsProperties(properties) {
    this.analytics.setGlobalProperties(properties);
  }
  initChainsConfig(projectConfig) {
    const chainMap = /* @__PURE__ */ new Map();
    const allChains = [...projectConfig.chains || [], ...this.coreOptions.chains || []];
    for (const chain of allChains) {
      const existingChain = chainMap.get(chain.chainId);
      if (!existingChain) chainMap.set(chain.chainId, chain);
      else chainMap.set(chain.chainId, _objectSpread2(_objectSpread2({}, existingChain), chain));
    }
    this.coreOptions.chains = Array.from(chainMap.values());
    if (this.coreOptions.chains.length === 0) {
      log.error("chain info not found. Please configure chains on dashboard at https://dashboard.web3auth.io");
      throw WalletInitializationError.invalidParams("Please configure chains on dashboard at https://dashboard.web3auth.io");
    }
    const validChainNamespaces = new Set(Object.values(CHAIN_NAMESPACES));
    for (const chain of this.coreOptions.chains) {
      if (!chain.chainNamespace || !validChainNamespaces.has(chain.chainNamespace)) {
        log.error(`Please provide a valid chainNamespace in chains for chain ${chain.chainId}`);
        throw WalletInitializationError.invalidParams(`Please provide a valid chainNamespace in chains for chain ${chain.chainId}`);
      }
      if (chain.chainNamespace !== CHAIN_NAMESPACES.OTHER && !isHexStrict(chain.chainId)) {
        log.error(`Please provide a valid chainId in chains for chain ${chain.chainId}`);
        throw WalletInitializationError.invalidParams(`Please provide a valid chainId as hex string in chains for chain ${chain.chainId}`);
      }
      if (chain.chainNamespace !== CHAIN_NAMESPACES.OTHER) {
        try {
          new URL(chain.rpcTarget);
        } catch (error) {
          log.error(`Please provide a valid rpcTarget in chains for chain ${chain.chainId}`, error);
          throw WalletInitializationError.invalidParams(`Please provide a valid rpcTarget in chains for chain ${chain.chainId}`);
        }
      }
    }
    if (this.coreOptions.accountAbstractionConfig) {
      if (this.coreOptions.accountAbstractionConfig.chains.length === 0) {
        log.error("Please configure chains for smart accounts on dashboard at https://dashboard.web3auth.io");
        throw WalletInitializationError.invalidParams("Please configure chains for smart accounts on dashboard at https://dashboard.web3auth.io");
      }
      for (const chain of this.coreOptions.accountAbstractionConfig.chains) {
        if (!isHexStrict(chain.chainId)) {
          log.error(`Please provide a valid chainId in accountAbstractionConfig.chains for chain ${chain.chainId}`);
          throw WalletInitializationError.invalidParams(`Please provide a valid chainId in accountAbstractionConfig.chains for chain ${chain.chainId}`);
        }
        try {
          var _chain$bundlerConfig;
          new URL((_chain$bundlerConfig = chain.bundlerConfig) === null || _chain$bundlerConfig === void 0 ? void 0 : _chain$bundlerConfig.url);
        } catch (error) {
          log.error(`Please provide a valid bundlerConfig.url in accountAbstractionConfig.chains for chain ${chain.chainId}`, error);
          throw WalletInitializationError.invalidParams(`Please provide a valid bundlerConfig.url in accountAbstractionConfig.chains for chain ${chain.chainId}`);
        }
        if (!chainMap.has(chain.chainId)) {
          log.error(`Please provide chain config for AA chain in accountAbstractionConfig.chains for chain ${chain.chainId}`);
          throw WalletInitializationError.invalidParams(`Please provide chain config for AA chain in accountAbstractionConfig.chains for chain ${chain.chainId}`);
        }
      }
    }
  }
  initAccountAbstractionConfig(projectConfig) {
    var _this$coreOptions$acc2;
    const isAAEnabled = Boolean(this.coreOptions.accountAbstractionConfig || (projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.smartAccounts));
    if (!isAAEnabled) return;
    const _ref = (projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.smartAccounts) || {}, {
      walletScope
    } = _ref, configWithoutWalletScope = _objectWithoutProperties(_ref, _excluded);
    const aaChainMap = /* @__PURE__ */ new Map();
    const allAaChains = [...(configWithoutWalletScope === null || configWithoutWalletScope === void 0 ? void 0 : configWithoutWalletScope.chains) || [], ...((_this$coreOptions$acc2 = this.coreOptions.accountAbstractionConfig) === null || _this$coreOptions$acc2 === void 0 ? void 0 : _this$coreOptions$acc2.chains) || []];
    for (const chain of allAaChains) {
      const existingChain = aaChainMap.get(chain.chainId);
      if (!existingChain) aaChainMap.set(chain.chainId, chain);
      else aaChainMap.set(chain.chainId, _objectSpread2(_objectSpread2({}, existingChain), chain));
    }
    this.coreOptions.accountAbstractionConfig = _objectSpread2(_objectSpread2({}, (0, import_deepmerge3.default)(configWithoutWalletScope || {}, this.coreOptions.accountAbstractionConfig || {})), {}, {
      chains: Array.from(aaChainMap.values())
    });
    if (this.coreOptions.useAAWithExternalWallet === void 0) {
      this.coreOptions.useAAWithExternalWallet = walletScope === SMART_ACCOUNT_WALLET_SCOPE.ALL;
    }
  }
  initUIConfig(projectConfig) {
    this.coreOptions.uiConfig = import_deepmerge3.default.all([{
      mode: "light",
      uxMode: UX_MODE.POPUP
    }, cloneDeep(projectConfig.whitelabel || {}), this.coreOptions.uiConfig || {}]);
  }
  initCachedConnectorAndChainId() {
    const cachedChainId = this.state.currentChainId;
    const isCachedChainIdValid = cachedChainId && this.coreOptions.chains.some((chain) => chain.chainId === cachedChainId);
    if (this.coreOptions.defaultChainId && !isHexStrict(this.coreOptions.defaultChainId)) throw WalletInitializationError.invalidParams("Please provide a valid defaultChainId in constructor");
    const currentChainId = isCachedChainIdValid ? cachedChainId : this.coreOptions.defaultChainId || this.coreOptions.chains[0].chainId;
    this.setState({
      currentChainId
    });
  }
  initWalletServicesConfig(projectConfig) {
    var _this$coreOptions$wal, _this$coreOptions$wal2, _this$coreOptions$wal3, _ref2, _this$coreOptions$wal4, _this$coreOptions$wal5;
    const {
      enableKeyExport,
      walletUi
    } = projectConfig;
    const {
      enablePortfolioWidget = false,
      enableTokenDisplay = true,
      enableNftDisplay = true,
      enableWalletConnect = true,
      enableBuyButton = true,
      enableSendButton = true,
      enableSwapButton = true,
      enableReceiveButton = true,
      enableShowAllTokensButton = true,
      enableConfirmationModal = false,
      portfolioWidgetPosition = BUTTON_POSITION.BOTTOM_LEFT,
      defaultPortfolio = "token"
    } = walletUi || {};
    const projectConfigWhiteLabel = {
      showWidgetButton: enablePortfolioWidget,
      hideNftDisplay: !enableNftDisplay,
      hideTokenDisplay: !enableTokenDisplay,
      hideTransfers: !enableSendButton,
      hideTopup: !enableBuyButton,
      hideReceive: !enableReceiveButton,
      hideSwap: !enableSwapButton,
      hideShowAllTokens: !enableShowAllTokensButton,
      hideWalletConnect: !enableWalletConnect,
      buttonPosition: portfolioWidgetPosition,
      defaultPortfolio
    };
    const whiteLabel = import_deepmerge3.default.all([projectConfigWhiteLabel, ((_this$coreOptions$wal = this.coreOptions.walletServicesConfig) === null || _this$coreOptions$wal === void 0 ? void 0 : _this$coreOptions$wal.whiteLabel) || {}]);
    const confirmationStrategy = (_this$coreOptions$wal2 = (_this$coreOptions$wal3 = this.coreOptions.walletServicesConfig) === null || _this$coreOptions$wal3 === void 0 ? void 0 : _this$coreOptions$wal3.confirmationStrategy) !== null && _this$coreOptions$wal2 !== void 0 ? _this$coreOptions$wal2 : enableConfirmationModal ? CONFIRMATION_STRATEGY.MODAL : CONFIRMATION_STRATEGY.AUTO_APPROVE;
    const isKeyExportEnabled = (_ref2 = (_this$coreOptions$wal4 = (_this$coreOptions$wal5 = this.coreOptions.walletServicesConfig) === null || _this$coreOptions$wal5 === void 0 ? void 0 : _this$coreOptions$wal5.enableKeyExport) !== null && _this$coreOptions$wal4 !== void 0 ? _this$coreOptions$wal4 : enableKeyExport) !== null && _ref2 !== void 0 ? _ref2 : true;
    this.coreOptions.walletServicesConfig = _objectSpread2(_objectSpread2({}, this.coreOptions.walletServicesConfig), {}, {
      confirmationStrategy,
      whiteLabel,
      enableKeyExport: isKeyExportEnabled
    });
  }
  getInitializationTrackData() {
    try {
      var _this$coreOptions$cha3, _this$coreOptions$cha4, _this$coreOptions$cha5, _this$coreOptions$cha6, _this$coreOptions$uiC2;
      const defaultChain = (_this$coreOptions$cha3 = this.coreOptions.chains) === null || _this$coreOptions$cha3 === void 0 ? void 0 : _this$coreOptions$cha3.find((chain) => chain.chainId === this.coreOptions.defaultChainId);
      const rpcHostnames = Array.from(new Set((_this$coreOptions$cha4 = this.coreOptions.chains) === null || _this$coreOptions$cha4 === void 0 ? void 0 : _this$coreOptions$cha4.map((chain) => getHostname(chain.rpcTarget)))).filter(Boolean);
      return _objectSpread2(_objectSpread2(_objectSpread2({
        chain_ids: (_this$coreOptions$cha5 = this.coreOptions.chains) === null || _this$coreOptions$cha5 === void 0 ? void 0 : _this$coreOptions$cha5.map((chain) => getCaipChainId(chain)),
        chain_names: (_this$coreOptions$cha6 = this.coreOptions.chains) === null || _this$coreOptions$cha6 === void 0 ? void 0 : _this$coreOptions$cha6.map((chain) => chain.displayName),
        chain_rpc_targets: rpcHostnames,
        default_chain_id: defaultChain ? getCaipChainId(defaultChain) : void 0,
        default_chain_name: defaultChain === null || defaultChain === void 0 ? void 0 : defaultChain.displayName,
        logging_enabled: this.coreOptions.enableLogging,
        storage_type: this.coreOptions.storageType,
        session_time: this.coreOptions.sessionTime,
        sfa_key_enabled: this.coreOptions.useSFAKey,
        mipd_enabled: this.coreOptions.multiInjectedProviderDiscovery,
        private_key_provider_enabled: Boolean(this.coreOptions.privateKeyProvider),
        ssr_enabled: this.coreOptions.ssr,
        auth_build_env: this.coreOptions.authBuildEnv,
        auth_ux_mode: (_this$coreOptions$uiC2 = this.coreOptions.uiConfig) === null || _this$coreOptions$uiC2 === void 0 ? void 0 : _this$coreOptions$uiC2.uxMode,
        auth_mfa_level: this.coreOptions.mfaLevel,
        auth_mfa_settings: Object.keys(this.coreOptions.mfaSettings || {}),
        aa_enabled_for_external_wallets: this.coreOptions.accountAbstractionConfig ? this.coreOptions.useAAWithExternalWallet : void 0
      }, getWhitelabelAnalyticsProperties(this.coreOptions.uiConfig)), getAaAnalyticsProperties(this.coreOptions.accountAbstractionConfig)), getWalletServicesAnalyticsProperties(this.coreOptions.walletServicesConfig));
    } catch (error) {
      log.error("Failed to get initialization track data", error);
      return {};
    }
  }
  async setupCommonJRPCProvider() {
    this.commonJRPCProvider = await CommonJRPCProvider.getProviderInstance({
      chain: this.currentChain,
      chains: this.coreOptions.chains
    });
    this.commonJRPCProvider.on("chainChanged", (chainId) => this.setCurrentChain(chainId));
  }
  async setupConnector(connector) {
    this.subscribeToConnectorEvents(connector);
    try {
      const initialChain = this.getInitialChainIdForConnector(connector);
      const autoConnect = this.checkIfAutoConnect(connector);
      await connector.init({
        autoConnect,
        chainId: initialChain.chainId
      });
    } catch (e8) {
      log.error(e8, connector.name);
    }
  }
  async loadConnectors({
    projectConfig,
    modalMode
  }) {
    var _this$coreOptions$mul;
    const connectorFns = [...this.coreOptions.connectors || [], authConnector()];
    const config = {
      projectConfig,
      coreOptions: this.coreOptions,
      analytics: this.analytics
    };
    const isExternalWalletEnabled = Boolean(projectConfig.externalWalletAuth);
    const isMipdEnabled = isExternalWalletEnabled && ((_this$coreOptions$mul = this.coreOptions.multiInjectedProviderDiscovery) !== null && _this$coreOptions$mul !== void 0 ? _this$coreOptions$mul : true);
    const chainNamespaces = new Set(this.coreOptions.chains.map((chain) => chain.chainNamespace));
    if (isMipdEnabled && isBrowser()) {
      if (chainNamespaces.has(CHAIN_NAMESPACES.SOLANA)) {
        const {
          createSolanaMipd,
          hasSolanaWalletStandardFeatures: hasSolanaWalletStandardFeatures2,
          walletStandardConnector: walletStandardConnector2
        } = await import("./injected-solana-connector-O5GKLYU4.js");
        const solanaMipd = createSolanaMipd();
        solanaMipd.on("register", async (...wallets) => {
          const newConnectors = wallets.filter(hasSolanaWalletStandardFeatures2).map((wallet) => walletStandardConnector2(wallet)(config));
          this.setConnectors(newConnectors);
        });
        connectorFns.push(...solanaMipd.get().filter((wallet) => hasSolanaWalletStandardFeatures2(wallet)).map(walletStandardConnector2));
      }
      if (chainNamespaces.has(CHAIN_NAMESPACES.EIP155)) {
        const {
          createMipd,
          injectedEvmConnector: injectedEvmConnector2
        } = await import("./injected-evm-connector-HLMNELVA.js");
        const evmMipd = createMipd();
        evmMipd.subscribe((providerDetails) => {
          const newConnectors = providerDetails.map((providerDetail) => injectedEvmConnector2(providerDetail)(config));
          this.setConnectors(newConnectors);
        });
        connectorFns.push(...evmMipd.getProviders().map(injectedEvmConnector2));
      }
    }
    if (isBrowser() && (chainNamespaces.has(CHAIN_NAMESPACES.EIP155) || chainNamespaces.has(CHAIN_NAMESPACES.SOLANA))) {
      connectorFns.push(metaMaskConnector(modalMode ? {
        headless: true
      } : void 0));
    }
    if (isBrowser() && isExternalWalletEnabled && (chainNamespaces.has(CHAIN_NAMESPACES.SOLANA) || chainNamespaces.has(CHAIN_NAMESPACES.EIP155))) {
      const {
        walletConnectV2Connector: walletConnectV2Connector2
      } = await import("./wallet-connect-v2-connector-JRCASGDW.js");
      connectorFns.push(walletConnectV2Connector2());
    }
    const connectors = connectorFns.map((connectorFn) => connectorFn(config));
    this.setConnectors(connectors);
  }
  async initPlugins() {
    const {
      chains,
      plugins
    } = this.coreOptions;
    const pluginFns = plugins || [];
    const isWsSupportedChain = chains.some((x3) => x3.chainNamespace === CHAIN_NAMESPACES.EIP155 || x3.chainNamespace === CHAIN_NAMESPACES.SOLANA);
    if (isWsSupportedChain) {
      pluginFns.push(walletServicesPlugin());
    }
    for (const pluginFn of pluginFns) {
      const plugin = pluginFn();
      if (!this.plugins[plugin.name]) this.plugins[plugin.name] = plugin;
    }
  }
  setConnectors(connectors) {
    const getConnectorKey = (connector) => `${connector.connectorNamespace}-${connector.name}`;
    const connectorSet = new Set(this.connectors.map(getConnectorKey));
    const newConnectors = connectors.map((connector) => {
      const key = getConnectorKey(connector);
      if (connectorSet.has(key)) return null;
      connectorSet.add(key);
      return connector;
    }).filter((connector) => connector !== null);
    if (newConnectors.length > 0) {
      this.connectors = [...this.connectors, ...newConnectors];
      this.emit(CONNECTOR_EVENTS.CONNECTORS_UPDATED, {
        connectors: newConnectors
      });
    }
  }
  subscribeToConnectorEvents(connector) {
    connector.on(CONNECTOR_EVENTS.CONNECTED, async (data) => {
      var _this$currentChain3, _accountAbstractionCo;
      if (!this.commonJRPCProvider) throw WalletInitializationError.notFound(`CommonJrpcProvider not found`);
      const {
        provider
      } = data;
      if (this.coreOptions.ssr) {
        try {
          const data2 = await connector.getIdentityToken();
          if (!data2.idToken) throw WalletLoginError.connectionError("No idToken found");
          this.setState({
            idToken: data2.idToken
          });
        } catch (error) {
          log.error(error);
          this.status = CONNECTOR_STATUS.ERRORED;
          this.emit(CONNECTOR_EVENTS.ERRORED, error, this.loginMode);
          return;
        }
      }
      let finalProvider = provider.provider || provider;
      const {
        accountAbstractionConfig
      } = this.coreOptions;
      const isAaSupportedForCurrentChain = ((_this$currentChain3 = this.currentChain) === null || _this$currentChain3 === void 0 ? void 0 : _this$currentChain3.chainNamespace) === CHAIN_NAMESPACES.EIP155 && (accountAbstractionConfig === null || accountAbstractionConfig === void 0 || (_accountAbstractionCo = accountAbstractionConfig.chains) === null || _accountAbstractionCo === void 0 ? void 0 : _accountAbstractionCo.some((chain) => {
        var _this$currentChain4;
        return chain.chainId === ((_this$currentChain4 = this.currentChain) === null || _this$currentChain4 === void 0 ? void 0 : _this$currentChain4.chainId);
      }));
      if (isAaSupportedForCurrentChain && (data.connector === WALLET_CONNECTORS.AUTH || this.coreOptions.useAAWithExternalWallet)) {
        var _accountAbstractionCo2;
        const {
          accountAbstractionProvider: accountAbstractionProvider2,
          toEoaProvider: toEoaProvider2
        } = await import("./account-abstraction-provider-3MRBTXRF.js");
        const eoaProvider = data.connector === WALLET_CONNECTORS.AUTH ? await toEoaProvider2(provider) : provider;
        const aaChainIds = new Set((accountAbstractionConfig === null || accountAbstractionConfig === void 0 || (_accountAbstractionCo2 = accountAbstractionConfig.chains) === null || _accountAbstractionCo2 === void 0 ? void 0 : _accountAbstractionCo2.map((chain) => chain.chainId)) || []);
        const aaProvider = await accountAbstractionProvider2({
          accountAbstractionConfig,
          provider: eoaProvider,
          chain: this.currentChain,
          chains: this.coreOptions.chains.filter((chain) => aaChainIds.has(chain.chainId)),
          useProviderAsTransport: data.connector === WALLET_CONNECTORS.AUTH
        });
        this.aaProvider = aaProvider;
        if (data.connector !== WALLET_CONNECTORS.AUTH && this.coreOptions.useAAWithExternalWallet) {
          finalProvider = this.aaProvider;
        }
      }
      this.commonJRPCProvider.updateProviderEngineProxy(finalProvider);
      this.setState({
        connectedConnectorName: data.connector
      });
      this.cacheWallet(data.connector);
      this.status = CONNECTOR_STATUS.CONNECTED;
      log.debug("connected", this.status, this.connectedConnectorName);
      this.connectToPlugins(data);
      this.emit(CONNECTOR_EVENTS.CONNECTED, _objectSpread2(_objectSpread2({}, data), {}, {
        loginMode: this.loginMode
      }));
    });
    connector.on(CONNECTOR_EVENTS.DISCONNECTED, async () => {
      this.commonJRPCProvider.removeAllListeners();
      this.setupCommonJRPCProvider();
      this.status = CONNECTOR_STATUS.READY;
      const cachedConnector = this.state.cachedConnector;
      if (this.connectedConnectorName === cachedConnector) {
        this.clearCache();
      }
      log.debug("disconnected", this.status, this.connectedConnectorName);
      await Promise.all(Object.values(this.plugins).map(async (plugin) => {
        if (!plugin.SUPPORTED_CONNECTORS.includes(connector.name)) return;
        if (plugin.status !== PLUGIN_STATUS.CONNECTED) return;
        return plugin.disconnect().catch((error) => {
          if (error.code === 5211) {
            return;
          }
          log.error(error);
        });
      }));
      this.setState({
        connectedConnectorName: null
      });
      this.emit(CONNECTOR_EVENTS.DISCONNECTED);
    });
    connector.on(CONNECTOR_EVENTS.CONNECTING, (data) => {
      this.status = CONNECTOR_STATUS.CONNECTING;
      this.emit(CONNECTOR_EVENTS.CONNECTING, data);
      log.debug("connecting", this.status, this.connectedConnectorName);
    });
    connector.on(CONNECTOR_EVENTS.ERRORED, (data) => {
      this.status = CONNECTOR_STATUS.ERRORED;
      this.clearCache();
      this.emit(CONNECTOR_EVENTS.ERRORED, data, this.loginMode);
      log.debug("errored", this.status, this.connectedConnectorName);
    });
    connector.on(CONNECTOR_EVENTS.REHYDRATION_ERROR, (error) => {
      this.status = CONNECTOR_STATUS.READY;
      this.clearCache();
      this.emit(CONNECTOR_EVENTS.REHYDRATION_ERROR, error);
    });
    connector.on(CONNECTOR_EVENTS.CONNECTOR_DATA_UPDATED, (data) => {
      log.debug("connector data updated", data);
      this.emit(CONNECTOR_EVENTS.CONNECTOR_DATA_UPDATED, data);
    });
    connector.on(CONNECTOR_EVENTS.CACHE_CLEAR, (data) => {
      log.debug("connector cache clear", data);
      this.clearCache();
    });
    connector.on(CONNECTOR_EVENTS.MFA_ENABLED, (isMFAEnabled) => {
      var _authConnector$authIn4;
      log.debug("mfa enabled", isMFAEnabled);
      const authConnector2 = this.connectedConnector;
      this.analytics.track(ANALYTICS_EVENTS.MFA_ENABLEMENT_COMPLETED, {
        connector: this.connectedConnector.name,
        auth_ux_mode: (_authConnector$authIn4 = authConnector2.authInstance) === null || _authConnector$authIn4 === void 0 || (_authConnector$authIn4 = _authConnector$authIn4.options) === null || _authConnector$authIn4 === void 0 ? void 0 : _authConnector$authIn4.uxMode,
        is_mfa_enabled: isMFAEnabled
      });
      this.emit(CONNECTOR_EVENTS.MFA_ENABLED, isMFAEnabled);
    });
  }
  checkInitRequirements() {
    if (this.status === CONNECTOR_STATUS.READY) throw WalletInitializationError.notReady("Connector is already initialized");
  }
  checkIfAutoConnect(connector) {
    var _this$currentChain5;
    let autoConnect = this.cachedConnector === connector.name;
    if (autoConnect && (_this$currentChain5 = this.currentChain) !== null && _this$currentChain5 !== void 0 && _this$currentChain5.chainNamespace) {
      if (connector.connectorNamespace === CONNECTOR_NAMESPACES.MULTICHAIN) autoConnect = true;
      else autoConnect = connector.connectorNamespace === this.currentChain.chainNamespace;
    }
    return autoConnect;
  }
  /**
   * Gets the initial chain configuration for a connector
   * @throws WalletInitializationError If no chain is found for the connector's namespace
   */
  getInitialChainIdForConnector(connector) {
    var _initialChain;
    let initialChain = this.currentChain;
    if (((_initialChain = initialChain) === null || _initialChain === void 0 ? void 0 : _initialChain.chainNamespace) !== connector.connectorNamespace && connector.connectorNamespace !== CONNECTOR_NAMESPACES.MULTICHAIN) {
      initialChain = this.coreOptions.chains.find((x3) => x3.chainNamespace === connector.connectorNamespace);
      if (!initialChain) throw WalletInitializationError.invalidParams(`No chain found for ${connector.connectorNamespace}`);
    }
    return initialChain;
  }
  cacheWallet(walletName) {
    this.setState({
      cachedConnector: walletName
    });
  }
  setCurrentChain(chainId) {
    if (chainId === this.currentChainId) return;
    const newChain = this.coreOptions.chains.find((chain) => chain.chainId === chainId);
    if (!newChain) throw WalletInitializationError.invalidParams(`Invalid chainId: ${chainId}`);
    this.setState({
      currentChainId: chainId
    });
  }
  connectToPlugins(data) {
    Object.values(this.plugins).map(async (plugin) => {
      try {
        var _this$currentChain6;
        if (!plugin.SUPPORTED_CONNECTORS.includes(data.connector)) return;
        if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== ((_this$currentChain6 = this.currentChain) === null || _this$currentChain6 === void 0 ? void 0 : _this$currentChain6.chainNamespace)) return;
        if (plugin.status === PLUGIN_STATUS.CONNECTED) return;
        await plugin.initWithWeb3Auth(this, this.coreOptions.uiConfig, this.analytics);
        await plugin.connect();
      } catch (error) {
        if (error.code === 5211) {
          return;
        }
        log.error(error);
      }
    });
  }
  setState(newState) {
    this.state = _objectSpread2(_objectSpread2({}, this.state), newState);
    this.storage.setItem(WEB3AUTH_STATE_STORAGE_KEY, JSON.stringify(this.state));
  }
  loadState(initialState) {
    if (initialState) {
      this.state = initialState;
      return;
    }
    const state = this.storage.getItem(WEB3AUTH_STATE_STORAGE_KEY);
    if (!state) return;
    this.state = deserialize(state);
  }
  getStorageMethod() {
    if (this.coreOptions.ssr || this.coreOptions.storageType === "cookies") return cookieStorage({
      expiry: this.coreOptions.sessionTime
    });
    if (this.coreOptions.storageType === "session" && storageAvailable2("sessionStorage")) return window.sessionStorage;
    if (this.coreOptions.storageType === "local" && storageAvailable2("localStorage")) return window.localStorage;
    return new MemoryStore();
  }
};

// node_modules/@web3auth/no-modal/dist/lib.esm/base/composables/index.js
var Web3AuthContextKey = "web3auth_context";

// node_modules/@web3auth/no-modal/dist/lib.esm/base/provider/IProvider.js
var PROVIDER_EVENTS = {
  INITIALIZED: "initialized",
  ERRORED: "errored"
};

// node_modules/@web3auth/no-modal/dist/lib.esm/plugins/nft-checkout-plugin/embed.js
var import_loglevel4 = __toESM(require_loglevel());

// node_modules/@web3auth/no-modal/dist/lib.esm/plugins/nft-checkout-plugin/enums.js
var NFT_CHECKOUT_BUILD_ENV = {
  PRODUCTION: "production",
  STAGING: "staging",
  DEVELOPMENT: "development",
  TESTING: "testing"
};
var NFT_CHECKOUT_URLS = {
  [NFT_CHECKOUT_BUILD_ENV.DEVELOPMENT]: "http://localhost:4050",
  [NFT_CHECKOUT_BUILD_ENV.TESTING]: "https://develop-nft-checkout.web3auth.io",
  [NFT_CHECKOUT_BUILD_ENV.STAGING]: "https://staging-nft-checkout.web3auth.io",
  [NFT_CHECKOUT_BUILD_ENV.PRODUCTION]: "https://nft-checkout.web3auth.io"
};
var NFT_CHECKOUT_EMBED_MESSAGE_TYPES = {
  INIT: "init",
  SETUP_COMPLETE: "setup_complete",
  SHOW_NFT_CHECKOUT: "show_nft_checkout",
  HIDE_NFT_CHECKOUT: "hide_nft_checkout"
};

// node_modules/@web3auth/no-modal/dist/lib.esm/plugins/nft-checkout-plugin/utils.js
var htmlToElement = (html) => {
  const template = window.document.createElement("template");
  const trimmedHtml = html.trim();
  template.innerHTML = trimmedHtml;
  return template.content.firstChild;
};
var getTheme = (theme) => {
  if (theme === THEME_MODES.light) return "light";
  if (theme === THEME_MODES.dark) return "dark";
  return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
};

// node_modules/@web3auth/no-modal/dist/lib.esm/plugins/nft-checkout-plugin/embed.js
(async function preLoadIframe() {
  try {
    if (typeof document === "undefined") return;
    const nftCheckoutIframeHtml = document.createElement("link");
    const nftCheckoutUrl = NFT_CHECKOUT_URLS.testing;
    nftCheckoutIframeHtml.href = `${nftCheckoutUrl}`;
    nftCheckoutIframeHtml.crossOrigin = "anonymous";
    nftCheckoutIframeHtml.type = "text/html";
    nftCheckoutIframeHtml.rel = "prefetch";
    if (nftCheckoutIframeHtml.relList && nftCheckoutIframeHtml.relList.supports) {
      if (nftCheckoutIframeHtml.relList.supports("prefetch")) {
        document.head.appendChild(nftCheckoutIframeHtml);
      }
    }
  } catch (error) {
    import_loglevel4.default.warn(error);
  }
})();
var NFTCheckoutEmbed = class {
  constructor({
    modalZIndex = 99999,
    clientId
  }) {
    _defineProperty(this, "clientId", void 0);
    _defineProperty(this, "isInitialized", void 0);
    _defineProperty(this, "modalZIndex", void 0);
    _defineProperty(this, "buildEnv", void 0);
    _defineProperty(this, "embedNonce", randomId2());
    this.isInitialized = false;
    this.modalZIndex = modalZIndex;
    this.clientId = clientId;
  }
  async init(params) {
    if (this.isInitialized) throw new Error("Already initialized");
    if (this.getIframe()) throw new Error("Already initialized NFT Checkout iframe");
    const {
      buildEnv = NFT_CHECKOUT_BUILD_ENV.TESTING,
      // TODO: use production by default once we have it
      whiteLabel
    } = params || {};
    this.buildEnv = buildEnv;
    const nftCheckoutIframeUrl = new URL(NFT_CHECKOUT_URLS[this.buildEnv]);
    const hashParams = new URLSearchParams();
    hashParams.append("origin", window.location.origin);
    nftCheckoutIframeUrl.hash = hashParams.toString();
    const colorScheme = getTheme((whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.mode) || THEME_MODES.light);
    const nftCheckoutIframe = htmlToElement(`<iframe
        id="nftCheckoutIframe-${this.embedNonce}"
        class="nftCheckoutIframe-${this.embedNonce}"
        sandbox="allow-popups allow-scripts allow-same-origin allow-forms allow-modals allow-downloads allow-popups-to-escape-sandbox"
        src="${nftCheckoutIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()};
        color-scheme: ${colorScheme}"
        allow="clipboard-write"
      ></iframe>`);
    return new Promise((resolve, reject) => {
      try {
        window.document.body.appendChild(nftCheckoutIframe);
        const handleMessage = async (ev) => {
          if (ev.origin !== nftCheckoutIframeUrl.origin) return;
          if (ev.data.type === NFT_CHECKOUT_EMBED_MESSAGE_TYPES.SETUP_COMPLETE) {
            nftCheckoutIframe.contentWindow.postMessage({
              type: NFT_CHECKOUT_EMBED_MESSAGE_TYPES.INIT,
              clientId: this.clientId,
              whiteLabel
            }, nftCheckoutIframeUrl.origin);
            this.isInitialized = true;
            resolve();
          } else if (ev.data.type === NFT_CHECKOUT_EMBED_MESSAGE_TYPES.HIDE_NFT_CHECKOUT) {
            this.hide();
          }
        };
        window.addEventListener("message", handleMessage);
      } catch (error) {
        reject(error);
      }
    });
  }
  show({
    receiverAddress,
    contractId
  }) {
    if (!this.isInitialized) throw new Error("Call init() first");
    const nftCheckoutIframe = this.getIframe();
    if (!nftCheckoutIframe) throw new Error("Iframe is not initialized");
    const nftCheckoutOrigin = new URL(NFT_CHECKOUT_URLS[this.buildEnv]).origin;
    nftCheckoutIframe.contentWindow.postMessage({
      type: NFT_CHECKOUT_EMBED_MESSAGE_TYPES.SHOW_NFT_CHECKOUT,
      contractId,
      receiverAddress
    }, nftCheckoutOrigin);
    nftCheckoutIframe.style.display = "block";
  }
  hide() {
    if (!this.isInitialized) throw new Error("Call init() first");
    const nftCheckoutIframe = this.getIframe();
    if (!nftCheckoutIframe) throw new Error("Iframe is not initialized");
    nftCheckoutIframe.style.display = "none";
  }
  cleanup() {
    const nftCheckoutIframe = this.getIframe();
    if (nftCheckoutIframe) nftCheckoutIframe.remove();
  }
  getIframe() {
    function isElement(element) {
      return element instanceof Element || element instanceof Document;
    }
    const nftCheckoutIframe = window.document.getElementById(`nftCheckoutIframe-${this.embedNonce}`);
    if (!isElement(nftCheckoutIframe)) return null;
    return nftCheckoutIframe;
  }
};

// node_modules/@web3auth/no-modal/dist/lib.esm/plugins/nft-checkout-plugin/plugin.js
var NFTCheckoutPlugin = class extends SafeEventEmitter {
  constructor(params) {
    super();
    _defineProperty(this, "name", EVM_PLUGINS.NFT_CHECKOUT);
    _defineProperty(this, "status", PLUGIN_STATUS.DISCONNECTED);
    _defineProperty(this, "SUPPORTED_CONNECTORS", Object.values(WALLET_CONNECTORS));
    _defineProperty(this, "pluginNamespace", PLUGIN_NAMESPACES.EIP155);
    _defineProperty(this, "web3auth", null);
    _defineProperty(this, "nftCheckoutEmbedInstance", null);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "receiverAddress", null);
    this.nftCheckoutEmbedInstance = new NFTCheckoutEmbed(params);
  }
  async initWithWeb3Auth(web3auth, whiteLabel) {
    if (this.isInitialized) return;
    if (!web3auth) throw NFTCheckoutPluginError.web3authRequired();
    this.web3auth = web3auth;
    await this.nftCheckoutEmbedInstance.init({
      whiteLabel
    });
    this.isInitialized = true;
    this.status = PLUGIN_STATUS.READY;
    this.emit(PLUGIN_EVENTS.READY);
  }
  async connect() {
    if (!this.isInitialized) throw NFTCheckoutPluginError.notInitialized();
    this.emit(PLUGIN_EVENTS.CONNECTING);
    this.status = PLUGIN_STATUS.CONNECTING;
    if (this.web3auth.status !== CONNECTOR_STATUS.CONNECTED) throw NFTCheckoutPluginError.web3AuthNotConnected();
    if (!this.web3auth.provider) throw NFTCheckoutPluginError.providerRequired();
    const accounts = await this.web3auth.provider.request({
      method: "eth_accounts"
    });
    if (accounts.length === 0) throw NFTCheckoutPluginError.web3AuthNotConnected();
    this.receiverAddress = accounts[0];
    this.emit(PLUGIN_EVENTS.CONNECTED);
    this.status = PLUGIN_STATUS.CONNECTED;
  }
  async show({
    contractId
  }) {
    if (this.status !== PLUGIN_STATUS.CONNECTED) NFTCheckoutPluginError.pluginNotConnected();
    return this.nftCheckoutEmbedInstance.show({
      receiverAddress: this.receiverAddress,
      contractId
    });
  }
  disconnect() {
    if (this.status !== PLUGIN_STATUS.CONNECTED) NFTCheckoutPluginError.pluginNotConnected();
    this.emit(PLUGIN_EVENTS.DISCONNECTED);
    this.status = PLUGIN_STATUS.DISCONNECTED;
    return Promise.resolve();
  }
  cleanup() {
    this.nftCheckoutEmbedInstance.cleanup();
    this.receiverAddress = null;
    this.isInitialized = false;
    return Promise.resolve();
  }
};
var nftCheckoutPlugin = (params) => {
  return () => {
    return new NFTCheckoutPlugin(params);
  };
};

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/ethereum-provider/providers/privateKeyProviders/TransactionFormatter/constants.js
var LegacyGasAPIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices";
var EIP1559APIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees";
var TRANSACTION_ENVELOPE_TYPES = {
  LEGACY: "0x0",
  ACCESS_LIST: "0x1",
  FEE_MARKET: "0x2"
};
var TRANSACTION_TYPES = {
  SENT_ETHER: "sentEther",
  CONTRACT_INTERACTION: "contractInteraction",
  DEPLOY_CONTRACT: "contractDeployment",
  STANDARD_TRANSACTION: "transaction"
};
var GAS_ESTIMATE_TYPES = {
  FEE_MARKET: "fee-market",
  LEGACY: "legacy",
  ETH_GASPRICE: "eth_gasPrice",
  NONE: "none"
};

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/ethereum-provider/providers/converter.js
var BIG_NUMBER_WEI_MULTIPLIER = new BigNumber("1e18");
var BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber("1e9");
var BIG_NUMBER_ETH_MULTIPLIER = new BigNumber("1");
var toBigNumber = {
  hex: (n2) => typeof n2 === "string" ? new BigNumber(stripHexPrefix(n2), 16) : new BigNumber(n2, 16),
  dec: (n2) => new BigNumber(n2, 10)
};
var toNormalizedDenomination = {
  WEI: (bigNumber) => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: (bigNumber) => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: (bigNumber) => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
var toSpecifiedDenomination = {
  WEI: (bigNumber) => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),
  GWEI: (bigNumber) => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),
  ETH: (bigNumber) => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)
};
var baseChange = {
  hex: (n2) => n2.toString(16),
  dec: (n2) => new BigNumber(n2).toString(10)
};
var converter = (params) => {
  const {
    value,
    fromNumericBase,
    fromDenomination,
    toNumericBase,
    toDenomination,
    numberOfDecimals
  } = params;
  let convertedValue = toBigNumber[fromNumericBase](value);
  if (fromDenomination) {
    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
  }
  if (toDenomination) {
    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
  }
  if (numberOfDecimals) {
    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);
  }
  if (toNumericBase) {
    convertedValue = baseChange[toNumericBase](convertedValue);
  }
  return convertedValue;
};
var conversionUtil = (value, {
  fromNumericBase = "hex",
  toNumericBase,
  fromDenomination,
  toDenomination,
  numberOfDecimals
}) => {
  return converter({
    fromNumericBase,
    toNumericBase,
    fromDenomination,
    toDenomination,
    numberOfDecimals,
    value: value || "0"
  });
};
function decGWEIToHexWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
}
function hexWEIToDecGWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
}

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/ethereum-provider/providers/privateKeyProviders/TransactionFormatter/utils.js
function normalizeGWEIDecimalNumbers(n2) {
  const numberAsWEIHex = decGWEIToHexWEI(n2);
  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex).toString();
  return numberAsGWEI;
}
async function fetchEip1159GasEstimates(url) {
  const estimates = await get(url);
  const normalizedEstimates = _objectSpread2(_objectSpread2({}, estimates), {}, {
    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),
    low: _objectSpread2(_objectSpread2({}, estimates.low), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)
    }),
    medium: _objectSpread2(_objectSpread2({}, estimates.medium), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)
    }),
    high: _objectSpread2(_objectSpread2({}, estimates.high), {}, {
      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),
      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)
    })
  });
  return normalizedEstimates;
}
async function fetchLegacyGasPriceEstimates(url) {
  const result = await get(url, {
    referrer: url,
    referrerPolicy: "no-referrer-when-downgrade",
    method: "GET",
    mode: "cors"
  });
  return {
    low: result.SafeGasPrice,
    medium: result.ProposeGasPrice,
    high: result.FastGasPrice
  };
}
function validateAddress(address, propertyName) {
  if (!address || typeof address !== "string" || !isValidAddress(address)) {
    throw new Error(`Invalid "${propertyName}" address: ${address} must be a valid string.`);
  }
}
async function validateTypedSignMessageDataV4(messageData, currentChainId) {
  validateAddress(messageData.from, "from");
  if (!messageData.data || Array.isArray(messageData.data) || typeof messageData.data !== "object" && typeof messageData.data !== "string") {
    throw new Error(`Invalid message "data": Must be a valid string or object.`);
  }
  let data;
  if (typeof messageData.data === "object") {
    data = messageData.data;
  } else {
    try {
      data = JSON.parse(messageData.data);
    } catch {
      throw new Error("Data must be passed as a valid JSON string.");
    }
  }
  if (!currentChainId) {
    throw new Error("Current chainId cannot be null or undefined.");
  }
  let {
    chainId
  } = data.domain;
  if (chainId) {
    if (typeof chainId === "string") {
      chainId = parseInt(chainId, chainId.startsWith("0x") ? 16 : 10);
    }
    const activeChainId = parseInt(currentChainId, 16);
    if (Number.isNaN(activeChainId)) {
      throw new Error(`Cannot sign messages for chainId "${chainId}", because Web3Auth is switching networks.`);
    }
    if (chainId !== activeChainId) {
      throw new Error(`Provided chainId "${chainId}" must match the active chainId "${activeChainId}"`);
    }
  }
}

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/ethereum-provider/providers/utils.js
var import_bn = __toESM(require_bn());
function bnLessThan(a, b3) {
  if (a === null || a === void 0 || b3 === null || b3 === void 0) {
    return null;
  }
  return new BigNumber(a, 10).lt(b3, 10);
}
function bnToHex(inputBn) {
  return addHexPrefix(inputBn.toString(16));
}
function hexToBn(inputHex) {
  if (import_bn.default.isBN(inputHex)) return inputHex;
  return new import_bn.default(stripHexPrefix(inputHex), 16);
}
function BnMultiplyByFraction(targetBN, numerator, denominator) {
  const numberBN = new import_bn.default(numerator);
  const denomBN = new import_bn.default(denominator);
  return targetBN.mul(numberBN).div(denomBN);
}

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/ethereum-provider/providers/privateKeyProviders/TransactionFormatter/formatter.js
var TransactionFormatter = class {
  constructor({
    getProviderEngineProxy
  }) {
    _defineProperty(this, "API_SUPPORTED_CHAINIDS", /* @__PURE__ */ new Set(["0x1", "0x5", "0x13881", "0xa4b1", "0xa86a", "0x2105", "0x38", "0xfa", "0xa", "0x89"]));
    _defineProperty(this, "chainConfig", null);
    _defineProperty(this, "getProviderEngineProxy", void 0);
    _defineProperty(this, "isEIP1559Compatible", false);
    this.getProviderEngineProxy = getProviderEngineProxy;
  }
  get providerProxy() {
    return this.getProviderEngineProxy();
  }
  async init() {
    this.chainConfig = await this.providerProxy.request({
      method: "eth_provider_config"
    });
    this.isEIP1559Compatible = await this.getEIP1559Compatibility();
  }
  async formatTransaction(txParams) {
    if (!this.chainConfig) throw new Error("Chain config not initialized");
    const clonedTxParams = _objectSpread2({}, txParams);
    if (clonedTxParams.nonce === void 0) clonedTxParams.nonce = await this.providerProxy.request({
      method: "eth_getTransactionCount",
      params: [txParams.from, "latest"]
    });
    if (!this.isEIP1559Compatible && clonedTxParams.gasPrice) {
      if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;
      if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas;
      if (!clonedTxParams.gasLimit) {
        if (!clonedTxParams.gas) {
          const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);
          if (defaultGasLimit) {
            clonedTxParams.gasLimit = defaultGasLimit;
          }
        } else {
          clonedTxParams.gasLimit = addHexPrefix(clonedTxParams.gas);
        }
      }
      return clonedTxParams;
    }
    if (!clonedTxParams.gasLimit) {
      if (!clonedTxParams.gas) {
        const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);
        if (defaultGasLimit) {
          clonedTxParams.gasLimit = defaultGasLimit;
        }
      } else {
        clonedTxParams.gasLimit = addHexPrefix(clonedTxParams.gas);
      }
    }
    const {
      gasPrice: defaultGasPrice,
      maxFeePerGas: defaultMaxFeePerGas,
      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas
    } = await this.getDefaultGasFees(clonedTxParams);
    if (this.isEIP1559Compatible) {
      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;
        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === "string" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === "string" ? stripHexPrefix(clonedTxParams.gasPrice) : clonedTxParams.gasPrice.toString()) ? addHexPrefix(defaultMaxPriorityFeePerGas) : addHexPrefix(clonedTxParams.gasPrice.toString());
      } else {
        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {
          clonedTxParams.maxFeePerGas = addHexPrefix(defaultMaxFeePerGas);
        }
        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
          clonedTxParams.maxPriorityFeePerGas = addHexPrefix(defaultMaxPriorityFeePerGas);
        }
        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {
          clonedTxParams.maxFeePerGas = addHexPrefix(defaultGasPrice);
        }
        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;
        }
      }
      delete clonedTxParams.gasPrice;
    } else {
      delete clonedTxParams.maxPriorityFeePerGas;
      delete clonedTxParams.maxFeePerGas;
    }
    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {
      clonedTxParams.gasPrice = defaultGasPrice;
    }
    clonedTxParams.type = Number.parseInt(this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY, 16);
    clonedTxParams.chainId = this.chainConfig.chainId;
    return clonedTxParams;
  }
  async fetchEthGasPriceEstimate() {
    const gasPrice = await this.providerProxy.request({
      method: "eth_gasPrice",
      params: []
    });
    return {
      gasPrice: hexWEIToDecGWEI(gasPrice).toString()
    };
  }
  async fetchGasEstimatesViaEthFeeHistory() {
    const noOfBlocks = 10;
    const newestBlock = "latest";
    const percentileValues = [10, 50, 95];
    const feeHistory = await this.providerProxy.request({
      method: "eth_feeHistory",
      params: [noOfBlocks, newestBlock, percentileValues]
    });
    const finalBaseFeePerGas = feeHistory.baseFeePerGas[feeHistory.baseFeePerGas.length - 1];
    const priorityFeeCalcs = feeHistory.reward.reduce((acc, curr) => {
      return {
        slow: acc.slow.plus(new BigNumber(curr[0], 16)),
        average: acc.average.plus(new BigNumber(curr[1], 16)),
        fast: acc.fast.plus(new BigNumber(curr[2], 16))
      };
    }, {
      slow: new BigNumber(0),
      average: new BigNumber(0),
      fast: new BigNumber(0)
    });
    return {
      estimatedBaseFee: hexWEIToDecGWEI(finalBaseFeePerGas).toString(),
      high: {
        maxWaitTimeEstimate: 3e4,
        minWaitTimeEstimate: 15e3,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.plus(finalBaseFeePerGas).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.fast.toString(16)).toString()
      },
      medium: {
        maxWaitTimeEstimate: 45e3,
        minWaitTimeEstimate: 15e3,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.plus(finalBaseFeePerGas).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.average.toString(16)).toString()
      },
      low: {
        maxWaitTimeEstimate: 6e4,
        minWaitTimeEstimate: 15e3,
        suggestedMaxFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.plus(finalBaseFeePerGas).toString(16)).toString(),
        suggestedMaxPriorityFeePerGas: hexWEIToDecGWEI(priorityFeeCalcs.slow.toString(16)).toString()
      }
    };
  }
  async getEIP1559Compatibility() {
    const latestBlock = await this.providerProxy.request({
      method: "eth_getBlockByNumber",
      params: ["latest", false]
    });
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== void 0;
    return !!supportsEIP1559;
  }
  async fetchGasFeeEstimateData() {
    if (!this.chainConfig) throw new Error("Chain config not initialized");
    const isLegacyGasAPICompatible = this.chainConfig.chainId === "0x1";
    const chainId = Number.parseInt(this.chainConfig.chainId, 16);
    let gasData;
    try {
      if (this.isEIP1559Compatible) {
        let estimates;
        try {
          if (this.API_SUPPORTED_CHAINIDS.has(this.chainConfig.chainId)) {
            estimates = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace("<chain_id>", `${chainId}`));
          } else {
            throw new Error("Chain id not supported by api");
          }
        } catch {
          estimates = await this.fetchGasEstimatesViaEthFeeHistory();
        }
        gasData = {
          gasFeeEstimates: estimates,
          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET
        };
      } else if (isLegacyGasAPICompatible) {
        const estimates = await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace("<chain_id>", `${chainId}`));
        gasData = {
          gasFeeEstimates: estimates,
          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY
        };
      } else {
        throw new Error("Main gas fee/price estimation failed. Use fallback");
      }
    } catch {
      try {
        const estimates = await this.fetchEthGasPriceEstimate();
        gasData = {
          gasFeeEstimates: estimates,
          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE
        };
      } catch (error) {
        throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);
      }
    }
    return gasData;
  }
  async getDefaultGasFees(txParams) {
    if (!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas) {
      return {};
    }
    try {
      const {
        gasFeeEstimates,
        gasEstimateType
      } = await this.fetchGasFeeEstimateData();
      if (this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {
        const {
          medium: {
            suggestedMaxPriorityFeePerGas,
            suggestedMaxFeePerGas
          } = {}
        } = gasFeeEstimates;
        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
          return {
            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxFeePerGas)),
            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))
          };
        }
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {
        return {
          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.medium))
        };
      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
        return {
          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.gasPrice))
        };
      }
    } catch (error) {
      log.error(error);
    }
    const {
      gasPrice
    } = await this.fetchEthGasPriceEstimate();
    return {
      gasPrice: addHexPrefix(decGWEIToHexWEI(gasPrice))
    };
  }
  async estimateTxGas(txMeta) {
    const txParams = _objectSpread2({}, txMeta);
    delete txParams.gasPrice;
    delete txParams.maxFeePerGas;
    delete txParams.maxPriorityFeePerGas;
    const gas = await this.providerProxy.request({
      method: "eth_estimateGas",
      params: [txParams]
    });
    return gas;
  }
  async analyzeGasUsage(txMeta) {
    const block = await this.providerProxy.request({
      method: "eth_getBlockByNumber",
      params: ["latest", false]
    });
    const blockGasLimitBN = hexToBn(block.gasLimit);
    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);
    let estimatedGasHex = bnToHex(saferGasLimitBN);
    try {
      estimatedGasHex = await this.estimateTxGas(txMeta);
    } catch (error) {
      log.warn(error);
    }
    return {
      blockGasLimit: block.gasLimit,
      estimatedGasHex
    };
  }
  addGasBuffer(initialGasLimitHex, blockGasLimitHex, multiplier = 1.5) {
    const initialGasLimitBn = hexToBn(initialGasLimitHex);
    const blockGasLimitBn = hexToBn(blockGasLimitHex);
    const upperGasLimitBn = blockGasLimitBn.muln(0.9);
    const bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);
    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn);
    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn);
    return bnToHex(upperGasLimitBn);
  }
  async determineTransactionCategory(txParameters) {
    const {
      data,
      to: to2
    } = txParameters;
    let code = "";
    let txCategory;
    if (data && !to2) {
      txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;
    } else {
      try {
        code = await this.providerProxy.request({
          method: "eth_getCode",
          params: [to2, "latest"]
        });
      } catch (error) {
        log.warn(error);
      }
      const codeIsEmpty = !code || code === "0x" || code === "0x0";
      txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;
    }
    return {
      transactionCategory: txCategory,
      code
    };
  }
  async getDefaultGasLimit(txParams) {
    const {
      transactionCategory
    } = await this.determineTransactionCategory(_objectSpread2({}, txParams));
    if (txParams.gas) {
      return addHexPrefix(txParams.gas);
    }
    if (txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER) {
      if (txParams.data) {
        throw Error("TxGasUtil - Trying to call a function on a non-contract address");
      }
      const TWENTY_ONE_THOUSAND = 21e3;
      return addHexPrefix(TWENTY_ONE_THOUSAND.toString(16));
    }
    const {
      blockGasLimit,
      estimatedGasHex
    } = await this.analyzeGasUsage(txParams);
    const gasLimit = this.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit);
    return gasLimit;
  }
};

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/ethereum-provider/providers/privateKeyProviders/TransactionFormatter/interfaces.js
var SignTypedDataVersion = function(SignTypedDataVersion2) {
  SignTypedDataVersion2["V1"] = "V1";
  SignTypedDataVersion2["V3"] = "V3";
  SignTypedDataVersion2["V4"] = "V4";
  return SignTypedDataVersion2;
}({});

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/solana-provider/solanaWallet.js
var SolanaWallet = class {
  constructor(provider) {
    _defineProperty(this, "provider", void 0);
    this.provider = provider;
  }
  async requestAccounts() {
    const accounts = await this.provider.request({
      method: SOLANA_METHOD_TYPES.SOLANA_REQUEST_ACCOUNTS
    });
    return accounts;
  }
  async getAccounts() {
    const accounts = await this.provider.request({
      method: SOLANA_METHOD_TYPES.GET_ACCOUNTS
    });
    return accounts;
  }
  async signAndSendTransaction(transaction) {
    const signature = await this.provider.request({
      method: SOLANA_METHOD_TYPES.SEND_TRANSACTION,
      params: {
        message: this.serializeTransaction(transaction)
      }
    });
    return signature;
  }
  /**
   * Signs a transaction and returns the signature
   * @param transaction - The transaction to sign
   * @returns The signature of the transaction encoded in base58
   */
  async signTransaction(transaction) {
    const signature = await this.provider.request({
      method: SOLANA_METHOD_TYPES.SIGN_TRANSACTION,
      params: {
        message: this.serializeTransaction(transaction)
      }
    });
    return signature;
  }
  /**
   * Signs multiple transactions and returns the serialized transactions
   * @param transactions - The transactions to sign
   * @returns The serialized transactions encoded in base64
   */
  async signAllTransactions(transactions) {
    const serializedTransactions = transactions.map((tx) => this.serializeTransaction(tx));
    const signedTransactions = await this.provider.request({
      method: SOLANA_METHOD_TYPES.SIGN_ALL_TRANSACTIONS,
      params: {
        message: serializedTransactions
      }
    });
    return signedTransactions;
  }
  /**
   * Signs a message and returns the signature
   * @param message - The message to sign
   * @returns The signature of the message encoded in base58
   */
  async signMessage(message, pubKey) {
    const response = await this.provider.request({
      method: SOLANA_METHOD_TYPES.SIGN_MESSAGE,
      params: {
        data: message,
        from: pubKey
      }
    });
    return response;
  }
  async request(args) {
    const result = await this.provider.request(args);
    return result;
  }
  serializeTransaction(transaction) {
    if (transaction instanceof VersionedTransaction) {
      return Buffer.from(transaction.serialize()).toString("base64");
    }
    return Buffer.from(transaction.serialize({
      requireAllSignatures: false
    })).toString("base64");
  }
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/config.js
var version2 = "10.1.0";
var defaultConnectorsModalConfig = {
  hideWalletDiscovery: false,
  connectors: {
    [EVM_CONNECTORS.AUTH]: {
      label: "Auth",
      showOnModal: true
    }
  }
};
var walletRegistryUrl = "https://assets.web3auth.io/v1/wallet-registry.json";

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/modalManager.js
var import_deepmerge5 = __toESM(require_cjs());

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/config.js
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var restrictedLoginMethods = /* @__PURE__ */ new Set([AUTH_CONNECTION.CUSTOM, AUTH_CONNECTION.PASSKEYS, AUTH_CONNECTION.TELEGRAM, AUTH_CONNECTION.AUTHENTICATOR]);
var AUTH_PROVIDERS = Object.values(AUTH_CONNECTION).filter((x3) => !restrictedLoginMethods.has(x3));
var AUTH_PROVIDERS_NAMES = AUTH_PROVIDERS.reduce((acc, x3) => {
  if (x3 === "email_passwordless") acc[x3] = "Email";
  else if (x3 === "sms_passwordless") acc[x3] = "Mobile";
  else acc[x3] = capitalizeFirstLetter(x3);
  return acc;
}, {});
var PASSWORDLESS_BUILD_ENV_MAP = {
  // [BUILD_ENV.DEVELOPMENT]: "http://localhost:3041/passwordless-service",
  [BUILD_ENV.DEVELOPMENT]: "https://api-develop.web3auth.io/passwordless-service",
  [BUILD_ENV.STAGING]: "https://api.web3auth.io/passwordless-service",
  [BUILD_ENV.PRODUCTION]: "https://api.web3auth.io/passwordless-service",
  [BUILD_ENV.TESTING]: "https://api-develop.web3auth.io/passwordless-service"
};
var CAPTCHA_SITE_KEY = "d5f0c15c-eeda-4f9c-934a-d8e0348e83b2";

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/interfaces.js
var LOGIN_MODAL_EVENTS = {
  MODAL_VISIBILITY: "MODAL_VISIBILITY"
};
var MODAL_STATUS = {
  INITIALIZED: "initialized",
  CONNECTED: "connected",
  CONNECTING: "connecting",
  ERRORED: "errored"
};
var TOAST_TYPE = function(TOAST_TYPE2) {
  TOAST_TYPE2["SUCCESS"] = "success";
  TOAST_TYPE2["ERROR"] = "error";
  TOAST_TYPE2["WARNING"] = "warning";
  TOAST_TYPE2["INFO"] = "info";
  return TOAST_TYPE2;
}({});

// node_modules/@web3auth/modal/dist/lib.esm/node_modules/style-inject/dist/style-inject.es.js
function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/css/index.css.js
var css_248z = '@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap");.w3a-parent-container *,.w3a-parent-container :after,.w3a-parent-container :before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:#3b82f680;--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.w3a-parent-container ::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:#3b82f680;--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }\n/*! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com*/.w3a-parent-container *,.w3a-parent-container :after,.w3a-parent-container :before{border:0 solid;box-sizing:border-box}.w3a-parent-container :after,.w3a-parent-container :before{--tw-content:""}.w3a-parent-container :host,.w3a-parent-container html{-webkit-text-size-adjust:100%;font-feature-settings:normal;-webkit-tap-highlight-color:transparent;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-variation-settings:normal;line-height:1.5;-moz-tab-size:4;tab-size:4}.w3a-parent-container body{line-height:inherit;margin:0}.w3a-parent-container hr{border-top-width:1px;color:inherit;height:0}.w3a-parent-container abbr:where([title]){text-decoration:underline dotted}.w3a-parent-container h1,.w3a-parent-container h2,.w3a-parent-container h3,.w3a-parent-container h4,.w3a-parent-container h5,.w3a-parent-container h6{font-size:inherit;font-weight:inherit}.w3a-parent-container a{color:inherit;text-decoration:inherit}.w3a-parent-container b,.w3a-parent-container strong{font-weight:bolder}.w3a-parent-container code,.w3a-parent-container kbd,.w3a-parent-container pre,.w3a-parent-container samp{font-feature-settings:normal;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em;font-variation-settings:normal}.w3a-parent-container small{font-size:80%}.w3a-parent-container sub,.w3a-parent-container sup{font-size:75%;line-height:0;position:relative;vertical-align:initial}.w3a-parent-container sub{bottom:-.25em}.w3a-parent-container sup{top:-.5em}.w3a-parent-container table{border-collapse:collapse;border-color:inherit;text-indent:0}.w3a-parent-container button,.w3a-parent-container input,.w3a-parent-container optgroup,.w3a-parent-container select,.w3a-parent-container textarea{font-feature-settings:inherit;color:inherit;font-family:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0}.w3a-parent-container button,.w3a-parent-container select{text-transform:none}.w3a-parent-container button,.w3a-parent-container input:where([type=button]),.w3a-parent-container input:where([type=reset]),.w3a-parent-container input:where([type=submit]){-webkit-appearance:button;background-color:initial;background-image:none}.w3a-parent-container :-moz-focusring{outline:auto}.w3a-parent-container :-moz-ui-invalid{box-shadow:none}.w3a-parent-container progress{vertical-align:initial}.w3a-parent-container ::-webkit-inner-spin-button,.w3a-parent-container ::-webkit-outer-spin-button{height:auto}.w3a-parent-container [type=search]{-webkit-appearance:textfield;outline-offset:-2px}.w3a-parent-container ::-webkit-search-decoration{-webkit-appearance:none}.w3a-parent-container ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}.w3a-parent-container summary{display:list-item}.w3a-parent-container blockquote,.w3a-parent-container dd,.w3a-parent-container dl,.w3a-parent-container figure,.w3a-parent-container h1,.w3a-parent-container h2,.w3a-parent-container h3,.w3a-parent-container h4,.w3a-parent-container h5,.w3a-parent-container h6,.w3a-parent-container hr,.w3a-parent-container p,.w3a-parent-container pre{margin:0}.w3a-parent-container fieldset{margin:0;padding:0}.w3a-parent-container legend{padding:0}.w3a-parent-container menu,.w3a-parent-container ol,.w3a-parent-container ul{list-style:none;margin:0;padding:0}.w3a-parent-container dialog{padding:0}.w3a-parent-container textarea{resize:vertical}.w3a-parent-container input::placeholder,.w3a-parent-container textarea::placeholder{color:#9ca3af;opacity:1}.w3a-parent-container [role=button],.w3a-parent-container button{cursor:pointer}.w3a-parent-container :disabled{cursor:default}.w3a-parent-container audio,.w3a-parent-container canvas,.w3a-parent-container embed,.w3a-parent-container iframe,.w3a-parent-container img,.w3a-parent-container object,.w3a-parent-container svg,.w3a-parent-container video{display:block;vertical-align:middle}.w3a-parent-container img,.w3a-parent-container video{height:auto;max-width:100%}.w3a-parent-container [hidden]:where(:not([hidden=until-found])){display:none}.w3a-parent-container{--app-on-primary:#fff;--app-primary-50:#ebf5ff;--app-primary-100:#e1effe;--app-primary-200:#c3ddfd;--app-primary-300:#a4cafe;--app-primary-400:#76a9fa;--app-primary-500:#3f83f8;--app-primary-600:#0346ff;--app-primary-700:#1a56db;--app-primary-800:#1e429f;--app-primary-900:#233876;--app-gray-50:#f9fafb;--app-gray-100:#f3f4f6;--app-gray-200:#e5e7eb;--app-gray-300:#d1d5db;--app-gray-400:#9ca3af;--app-gray-500:#6b7280;--app-gray-600:#4b5563;--app-gray-700:#374151;--app-gray-800:#1f2a37;--app-gray-900:#111928;--app-blue-50:#ebf5ff;--app-blue-100:#e1effe;--app-blue-200:#c3ddfd;--app-blue-300:#a4cafe;--app-blue-400:#76a9fa;--app-blue-500:#3f83f8;--app-blue-600:#0346ff;--app-blue-700:#1a56db;--app-blue-800:#1e429f;--app-blue-900:#233876;--app-red-50:#fdf2f2;--app-red-100:#fde8e8;--app-red-200:#fbd5d5;--app-red-300:#f8b4b4;--app-red-400:#f98080;--app-red-500:#f05252;--app-red-600:#e02424;--app-red-700:#c81e1e;--app-red-800:#9b1c1c;--app-red-900:#771d1d;--app-green-50:#f3faf7;--app-green-100:#def7ec;--app-green-200:#bcf0da;--app-green-300:#84e1bc;--app-green-400:#31c48d;--app-green-500:#0e9f6e;--app-green-600:#057a55;--app-green-700:#046c4e;--app-green-800:#03543f;--app-green-900:#014737;--app-yellow-50:#fdfdea;--app-yellow-100:#fdf6b2;--app-yellow-200:#fce96a;--app-yellow-300:#faca15;--app-yellow-400:#e3a008;--app-yellow-500:#c27803;--app-yellow-600:#9f580a;--app-yellow-700:#8e4b10;--app-yellow-800:#723b13;--app-yellow-900:#633112;--app-success:#30cca4;--app-warning:#fbc94a;--app-error:#fb4a61;--app-info:#d4d4d4;--app-white:#fff;--app-black:#000}.w3a-parent-container body{box-sizing:border-box;margin:0!important;padding:0!important}.w3a-parent-container{font-family:Inter;position:relative}.w3a-parent-container .w3a-parent-container>*{scrollbar-color:#e5e7eb!important}.w3a-parent-container .w3a--social-container{scroll-padding-right:10px;scrollbar-color:#e5e7eb!important}.w3a-parent-container .w3a--modal-curtain{background-color:initial;left:0;opacity:0;position:absolute;right:0;top:0;transition:opacity 50ms ease-in;z-index:1}.w3a-parent-container .w3a--fixed{position:fixed}.w3a-parent-container .w3a--absolute{position:absolute}.w3a-parent-container .w3a--relative{position:relative}.w3a-parent-container .w3a--inset-x-4{left:1rem;right:1rem}.w3a-parent-container .w3a--bottom-2{bottom:.5rem}.w3a-parent-container .w3a--bottom-4{bottom:1rem}.w3a-parent-container .w3a--bottom-8{bottom:2rem}.w3a-parent-container .w3a--bottom-\\[100\\%\\]{bottom:100%}.w3a-parent-container .w3a--left-0{left:0}.w3a-parent-container .w3a--left-2{left:.5rem}.w3a-parent-container .w3a--left-\\[50\\%\\]{left:50%}.w3a-parent-container .w3a--right-4{right:1rem}.w3a-parent-container .w3a--right-6{right:1.5rem}.w3a-parent-container .w3a--top-0{top:0}.w3a-parent-container .w3a--top-1\\/2{top:50%}.w3a-parent-container .w3a--top-4{top:1rem}.w3a-parent-container .w3a--top-8{top:2rem}.w3a-parent-container .w3a--top-\\[16px\\]{top:16px}.w3a-parent-container .w3a--top-\\[30px\\]{top:30px}.w3a-parent-container .w3a--z-10{z-index:10}.w3a-parent-container .w3a--z-20{z-index:20}.w3a-parent-container .w3a--z-50{z-index:50}.w3a-parent-container .w3a--z-\\[-1\\]{z-index:-1}.w3a-parent-container .w3a--z-\\[45\\]{z-index:45}.w3a-parent-container .w3a--z-\\[60\\]{z-index:60}.w3a-parent-container .w3a--mx-auto{margin-left:auto;margin-right:auto}.w3a-parent-container .w3a--my-2{margin-bottom:.5rem;margin-top:.5rem}.w3a-parent-container .w3a--my-4{margin-bottom:1rem;margin-top:1rem}.w3a-parent-container .w3a--my-6{margin-bottom:1.5rem;margin-top:1.5rem}.w3a-parent-container .-w3a--mt-10{margin-top:-2.5rem}.w3a-parent-container .-w3a--mt-2{margin-top:-.5rem}.w3a-parent-container .-w3a--mt-6{margin-top:-1.5rem}.w3a-parent-container .w3a--mb-2{margin-bottom:.5rem}.w3a-parent-container .w3a--ml-0{margin-left:0}.w3a-parent-container .w3a--ml-2{margin-left:.5rem}.w3a-parent-container .w3a--ml-4{margin-left:1rem}.w3a-parent-container .w3a--mr-2\\.5{margin-right:.625rem}.w3a-parent-container .w3a--mr-auto{margin-right:auto}.w3a-parent-container .w3a--mt-2{margin-top:.5rem}.w3a-parent-container .w3a--mt-3{margin-top:.75rem}.w3a-parent-container .w3a--mt-auto{margin-top:auto}.w3a-parent-container .w3a--block{display:block}.w3a-parent-container .w3a--flex{display:flex}.w3a-parent-container .w3a--inline-flex{display:inline-flex}.w3a-parent-container .w3a--grid{display:grid}.w3a-parent-container .w3a--contents{display:contents}.w3a-parent-container .w3a--hidden{display:none}.w3a-parent-container .w3a--size-10{height:2.5rem;width:2.5rem}.w3a-parent-container .w3a--size-3{height:.75rem;width:.75rem}.w3a-parent-container .w3a--size-5{height:1.25rem;width:1.25rem}.w3a-parent-container .w3a--size-\\[300px\\]{height:300px;width:300px}.w3a-parent-container .w3a--size-auto{height:auto;width:auto}.w3a-parent-container .w3a--size-full{height:100%;width:100%}.w3a-parent-container .w3a--h-0{height:0}.w3a-parent-container .w3a--h-11{height:2.75rem}.w3a-parent-container .w3a--h-12{height:3rem}.w3a-parent-container .w3a--h-9{height:2.25rem}.w3a-parent-container .w3a--h-\\[280px\\]{height:280px}.w3a-parent-container .w3a--h-\\[300px\\]{height:300px}.w3a-parent-container .w3a--h-\\[328px\\]{height:328px}.w3a-parent-container .w3a--h-\\[42px\\]{height:42px}.w3a-parent-container .w3a--h-\\[50px\\]{height:50px}.w3a-parent-container .w3a--h-auto{height:auto}.w3a-parent-container .w3a--h-full{height:100%}.w3a-parent-container .w3a--h-px{height:1px}.w3a-parent-container .w3a--h-screen{height:100vh}.w3a-parent-container .w3a--w-0{width:0}.w3a-parent-container .w3a--w-12{width:3rem}.w3a-parent-container .w3a--w-4\\/5{width:80%}.w3a-parent-container .w3a--w-\\[100px\\]{width:100px}.w3a-parent-container .w3a--w-\\[104px\\]{width:104px}.w3a-parent-container .w3a--w-\\[200px\\]{width:200px}.w3a-parent-container .w3a--w-\\[356px\\]{width:356px}.w3a-parent-container .w3a--w-\\[90\\%\\]{width:90%}.w3a-parent-container .w3a--w-\\[96\\%\\]{width:96%}.w3a-parent-container .w3a--w-auto{width:auto}.w3a-parent-container .w3a--w-full{width:100%}.w3a-parent-container .w3a--w-max{width:max-content}.w3a-parent-container .w3a--w-screen{width:100vw}.w3a-parent-container .w3a--max-w-\\[180px\\]{max-width:180px}.w3a-parent-container .w3a--flex-1{flex:1 1 0%}.w3a-parent-container .-w3a--translate-x-10{--tw-translate-x:-2.5rem}.w3a-parent-container .-w3a--translate-x-10,.w3a-parent-container .-w3a--translate-x-6{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.w3a-parent-container .-w3a--translate-x-6{--tw-translate-x:-1.5rem}.w3a-parent-container .-w3a--translate-y-1\\/2{--tw-translate-y:-50%}.w3a-parent-container .-w3a--translate-y-1\\/2,.w3a-parent-container .w3a--translate-y-0{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.w3a-parent-container .w3a--translate-y-0{--tw-translate-y:0px}.w3a-parent-container .w3a--translate-y-\\[100vh\\]{--tw-translate-y:100vh}.w3a-parent-container .w3a--translate-y-\\[100vh\\],.w3a-parent-container .w3a--translate-y-full{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.w3a-parent-container .w3a--translate-y-full{--tw-translate-y:100%}@keyframes w3a--pulse{50%{opacity:.5}}.w3a-parent-container .w3a--animate-pulse{animation:w3a--pulse 2s cubic-bezier(.4,0,.6,1) infinite}.w3a-parent-container .w3a--cursor-not-allowed{cursor:not-allowed}.w3a-parent-container .w3a--cursor-pointer{cursor:pointer}.w3a-parent-container .w3a--appearance-none{appearance:none}.w3a-parent-container .w3a--auto-rows-min{grid-auto-rows:min-content}.w3a-parent-container .w3a--grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.w3a-parent-container .w3a--grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.w3a-parent-container .w3a--grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.w3a-parent-container .w3a--grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.w3a-parent-container .w3a--flex-col{flex-direction:column}.w3a-parent-container .w3a--items-start{align-items:flex-start}.w3a-parent-container .w3a--items-end{align-items:flex-end}.w3a-parent-container .w3a--items-center{align-items:center}.w3a-parent-container .\\!w3a--justify-start{justify-content:flex-start!important}.w3a-parent-container .w3a--justify-start{justify-content:flex-start}.w3a-parent-container .\\!w3a--justify-center{justify-content:center!important}.w3a-parent-container .w3a--justify-center{justify-content:center}.w3a-parent-container .\\!w3a--justify-between{justify-content:space-between!important}.w3a-parent-container .w3a--justify-between{justify-content:space-between}.w3a-parent-container .w3a--justify-items-start{justify-items:start}.w3a-parent-container .w3a--gap-2{gap:.5rem}.w3a-parent-container .w3a--gap-3{gap:.75rem}.w3a-parent-container .w3a--gap-x-1{column-gap:.25rem}.w3a-parent-container .w3a--gap-x-2{column-gap:.5rem}.w3a-parent-container .w3a--gap-x-4{column-gap:1rem}.w3a-parent-container .w3a--gap-x-6{column-gap:1.5rem}.w3a-parent-container .w3a--gap-y-1{row-gap:.25rem}.w3a-parent-container .w3a--gap-y-2{row-gap:.5rem}.w3a-parent-container .w3a--gap-y-4{row-gap:1rem}.w3a-parent-container .w3a--space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse:0;margin-left:calc(.5rem*(1 - var(--tw-space-x-reverse)));margin-right:calc(.5rem*var(--tw-space-x-reverse))}.w3a-parent-container .w3a--overflow-hidden{overflow:hidden}.w3a-parent-container .w3a--overflow-y-auto{overflow-y:auto}.w3a-parent-container .w3a--truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.w3a-parent-container .w3a--rounded{border-radius:.25rem}.w3a-parent-container .w3a--rounded-2xl{border-radius:1rem}.w3a-parent-container .w3a--rounded-3xl{border-radius:1.5rem}.w3a-parent-container .w3a--rounded-\\[30px\\]{border-radius:30px}.w3a-parent-container .w3a--rounded-full{border-radius:9999px}.w3a-parent-container .w3a--rounded-lg{border-radius:.5rem}.w3a-parent-container .w3a--rounded-md{border-radius:.375rem}.w3a-parent-container .w3a--rounded-none{border-radius:0}.w3a-parent-container .w3a--border{border-width:1px}.w3a-parent-container .\\!w3a--border-app-primary-600{border-color:var(--app-primary-600)!important}.w3a-parent-container .w3a--border-app-blue-200{border-color:var(--app-blue-200)}.w3a-parent-container .w3a--border-app-gray-100{border-color:var(--app-gray-100)}.w3a-parent-container .w3a--border-app-gray-200{border-color:var(--app-gray-200)}.w3a-parent-container .w3a--border-app-gray-300{border-color:var(--app-gray-300)}.w3a-parent-container .w3a--border-app-gray-800{border-color:var(--app-gray-800)}.w3a-parent-container .w3a--border-app-green-200{border-color:var(--app-green-200)}.w3a-parent-container .w3a--border-app-green-400{border-color:var(--app-green-400)}.w3a-parent-container .w3a--border-app-red-200{border-color:var(--app-red-200)}.w3a-parent-container .w3a--border-app-red-600{border-color:var(--app-red-600)}.w3a-parent-container .w3a--border-app-yellow-200{border-color:var(--app-yellow-200)}.w3a-parent-container .w3a--border-transparent{border-color:#0000}.w3a-parent-container .\\!w3a--bg-app-gray-800{background-color:var(--app-gray-800)!important}.w3a-parent-container .w3a--bg-app-blue-100{background-color:var(--app-blue-100)}.w3a-parent-container .w3a--bg-app-gray-100{background-color:var(--app-gray-100)}.w3a-parent-container .w3a--bg-app-gray-200{background-color:var(--app-gray-200)}.w3a-parent-container .w3a--bg-app-gray-400{background-color:var(--app-gray-400)}.w3a-parent-container .w3a--bg-app-gray-50{background-color:var(--app-gray-50)}.w3a-parent-container .w3a--bg-app-gray-500{background-color:var(--app-gray-500)}.w3a-parent-container .w3a--bg-app-gray-800{background-color:var(--app-gray-800)}.w3a-parent-container .w3a--bg-app-green-100{background-color:var(--app-green-100)}.w3a-parent-container .w3a--bg-app-light-surface1{background-color:var(--app-white)}.w3a-parent-container .w3a--bg-app-primary-100{background-color:var(--app-primary-100)}.w3a-parent-container .w3a--bg-app-red-100{background-color:var(--app-red-100)}.w3a-parent-container .w3a--bg-app-white{background-color:var(--app-white)}.w3a-parent-container .w3a--bg-app-yellow-100{background-color:var(--app-yellow-100)}.w3a-parent-container .w3a--bg-transparent{background-color:initial}.w3a-parent-container .w3a--object-contain{object-fit:contain}.w3a-parent-container .w3a--p-0{padding:0}.w3a-parent-container .w3a--p-2{padding:.5rem}.w3a-parent-container .w3a--p-3{padding:.75rem}.w3a-parent-container .w3a--p-4{padding:1rem}.w3a-parent-container .w3a--p-6{padding:1.5rem}.w3a-parent-container .w3a--px-2{padding-left:.5rem;padding-right:.5rem}.w3a-parent-container .w3a--px-2\\.5{padding-left:.625rem;padding-right:.625rem}.w3a-parent-container .w3a--px-4{padding-left:1rem;padding-right:1rem}.w3a-parent-container .w3a--px-5{padding-left:1.25rem;padding-right:1.25rem}.w3a-parent-container .w3a--px-\\[6px\\]{padding-left:6px;padding-right:6px}.w3a-parent-container .w3a--py-0\\.5{padding-bottom:.125rem;padding-top:.125rem}.w3a-parent-container .w3a--py-1{padding-bottom:.25rem;padding-top:.25rem}.w3a-parent-container .w3a--py-2{padding-bottom:.5rem;padding-top:.5rem}.w3a-parent-container .w3a--py-2\\.5{padding-bottom:.625rem;padding-top:.625rem}.w3a-parent-container .w3a--py-3{padding-bottom:.75rem;padding-top:.75rem}.w3a-parent-container .w3a--py-6{padding-bottom:1.5rem;padding-top:1.5rem}.w3a-parent-container .w3a--py-\\[3px\\]{padding-bottom:3px;padding-top:3px}.w3a-parent-container .w3a--pl-2{padding-left:.5rem}.w3a-parent-container .w3a--pl-6{padding-left:1.5rem}.w3a-parent-container .w3a--pr-1\\.5{padding-right:.375rem}.w3a-parent-container .w3a--pr-2\\.5{padding-right:.625rem}.w3a-parent-container .w3a--pr-3{padding-right:.75rem}.w3a-parent-container .w3a--pt-5{padding-top:1.25rem}.w3a-parent-container .w3a--pt-6{padding-top:1.5rem}.w3a-parent-container .w3a--text-left{text-align:left}.w3a-parent-container .w3a--text-center{text-align:center}.w3a-parent-container .w3a--text-start{text-align:start}.w3a-parent-container .w3a--text-3xl{font-size:1.875rem;line-height:2.25rem}.w3a-parent-container .w3a--text-base{font-size:1rem;line-height:1.5rem}.w3a-parent-container .w3a--text-lg{font-size:1.125rem;line-height:1.75rem}.w3a-parent-container .w3a--text-sm{font-size:.875rem;line-height:1.25rem}.w3a-parent-container .w3a--text-xl{font-size:1.25rem;line-height:1.75rem}.w3a-parent-container .w3a--text-xs{font-size:.75rem;line-height:1rem}.w3a-parent-container .w3a--font-bold{font-weight:700}.w3a-parent-container .w3a--font-medium{font-weight:500}.w3a-parent-container .w3a--font-normal{font-weight:400}.w3a-parent-container .w3a--font-semibold{font-weight:600}.w3a-parent-container .w3a--uppercase{text-transform:uppercase}.w3a-parent-container .w3a--text-app-blue-900{color:var(--app-blue-900)}.w3a-parent-container .w3a--text-app-gray-100{color:var(--app-gray-100)}.w3a-parent-container .w3a--text-app-gray-400{color:var(--app-gray-400)}.w3a-parent-container .w3a--text-app-gray-500{color:var(--app-gray-500)}.w3a-parent-container .w3a--text-app-gray-700{color:var(--app-gray-700)}.w3a-parent-container .w3a--text-app-gray-900{color:var(--app-gray-900)}.w3a-parent-container .w3a--text-app-green-400{color:var(--app-green-400)}.w3a-parent-container .w3a--text-app-green-500{color:var(--app-green-500)}.w3a-parent-container .w3a--text-app-green-900{color:var(--app-green-900)}.w3a-parent-container .w3a--text-app-primary-600{color:var(--app-primary-600)}.w3a-parent-container .w3a--text-app-primary-800{color:var(--app-primary-800)}.w3a-parent-container .w3a--text-app-red-400{color:var(--app-red-400)}.w3a-parent-container .w3a--text-app-red-500{color:var(--app-red-500)}.w3a-parent-container .w3a--text-app-red-900{color:var(--app-red-900)}.w3a-parent-container .w3a--text-app-yellow-900{color:var(--app-yellow-900)}.w3a-parent-container .w3a--opacity-0{opacity:0}.w3a-parent-container .w3a--shadow-2xl{--tw-shadow:0 25px 50px -12px #00000040;--tw-shadow-colored:0 25px 50px -12px var(--tw-shadow-color)}.w3a-parent-container .w3a--shadow-2xl,.w3a-parent-container .w3a--shadow-lg{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.w3a-parent-container .w3a--shadow-lg{--tw-shadow:0 10px 15px -3px #0000001a,0 4px 6px -4px #0000001a;--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color),0 4px 6px -4px var(--tw-shadow-color)}.w3a-parent-container .w3a--shadow-xl{--tw-shadow:0 20px 25px -5px #0000001a,0 8px 10px -6px #0000001a;--tw-shadow-colored:0 20px 25px -5px var(--tw-shadow-color),0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.w3a-parent-container .w3a--outline-none{outline:2px solid #0000;outline-offset:2px}.w3a-parent-container .w3a--transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.w3a-parent-container .w3a--transition-opacity{transition-duration:.15s;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1)}.w3a-parent-container .w3a--transition-transform{transition-duration:.15s;transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1)}.w3a-parent-container .w3a--delay-100{transition-delay:.1s}.w3a-parent-container .w3a--delay-300{transition-delay:.3s}.w3a-parent-container .w3a--delay-500{transition-delay:.5s}.w3a-parent-container .w3a--delay-700{transition-delay:.7s}.w3a-parent-container .w3a--duration-150{transition-duration:.15s}.w3a-parent-container .w3a--duration-300{transition-duration:.3s}.w3a-parent-container .w3a--duration-500{transition-duration:.5s}.w3a-parent-container .w3a--duration-\\[400ms\\]{transition-duration:.4s}.w3a-parent-container .w3a--ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.w3a-parent-container .w3a--ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.w3a-parent-container .w3a--bottom-sheet-bg{background-color:var(--app-gray-600);opacity:.5}.w3a-parent-container .w3a--connected-logo{color:var(--app-green-500);height:4rem;width:4rem}.w3a-parent-container .w3a--connected-logo:is(.w3a--dark *){color:var(--app-green-400)}.w3a-parent-container .w3a--error-logo{color:var(--app-red-500);height:4rem;width:4rem}.w3a-parent-container .w3a--error-logo:is(.w3a--dark *){color:var(--app-red-400)}.w3a-parent-container .w3a--btn{align-items:center;appearance:none;border-color:var(--app-gray-200);border-width:1px;color:var(--app-gray-700);column-gap:.5rem;display:flex;font-size:1rem;font-weight:400;justify-content:center;line-height:1.5rem;padding:.75rem 1.25rem;width:100%}.w3a-parent-container .w3a--btn:hover{--tw-translate-y:0.5px;--tw-shadow:0px 2px 8px 2px #e5e7eb;--tw-shadow-colored:0px 2px 8px 2px var(--tw-shadow-color);background-color:var(--app-gray-50);border-color:var(--app-gray-50);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow);transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.w3a-parent-container .w3a--btn:is(.w3a--dark *){border-color:var(--app-gray-500)}.w3a-parent-container .w3a--btn:hover:is(.w3a--dark *){--tw-shadow:0px 2px 8px 2px #111928;--tw-shadow-colored:0px 2px 8px 2px var(--tw-shadow-color);background-color:var(--app-gray-800);border-color:var(--app-gray-800);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.w3a-parent-container .w3a--input{align-items:center;border-color:var(--app-gray-200);border-width:1px;column-gap:.5rem;display:flex;justify-content:space-between;padding:.75rem 1.25rem;width:100%}.w3a-parent-container .w3a--input:is(.w3a--dark *){border-color:var(--app-gray-500)}.w3a-parent-container .first-letter\\:w3a--capitalize:first-letter{text-transform:capitalize}.w3a-parent-container .placeholder\\:w3a--text-xs::placeholder{font-size:.75rem;line-height:1rem}.w3a-parent-container .placeholder\\:w3a--text-app-gray-400::placeholder{color:var(--app-gray-400)}.w3a-parent-container .hover\\:w3a--translate-y-\\[0\\.5px\\]:hover{--tw-translate-y:0.5px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.w3a-parent-container .hover\\:w3a--border-app-gray-50:hover{border-color:var(--app-gray-50)}.w3a-parent-container .hover\\:w3a--border-transparent:hover{border-color:#0000}.w3a-parent-container .hover\\:\\!w3a--bg-app-gray-100:hover{background-color:var(--app-gray-100)!important}.w3a-parent-container .hover\\:w3a--bg-app-gray-200:hover{background-color:var(--app-gray-200)}.w3a-parent-container .hover\\:w3a--text-app-gray-900:hover{color:var(--app-gray-900)}.w3a-parent-container .hover\\:w3a--shadow-light:hover{--tw-shadow:0px 2px 8px 2px #e5e7eb;--tw-shadow-colored:0px 2px 8px 2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.w3a-parent-container .focus\\:w3a--outline-none:focus{outline:2px solid #0000;outline-offset:2px}.w3a-parent-container .active\\:w3a--scale-95:active{--tw-scale-x:.95;--tw-scale-y:.95;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.w3a-parent-container .active\\:w3a--outline-none:active{outline:2px solid #0000;outline-offset:2px}.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--block{display:block}.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--hidden{display:none}.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--translate-x-0{--tw-translate-x:0px}.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--translate-x-0,.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--translate-x-6{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--translate-x-6{--tw-translate-x:1.5rem}.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--opacity-0{opacity:0}.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--opacity-100{opacity:1}.w3a-parent-container .w3a--group:hover .group-hover\\:w3a--delay-0{transition-delay:0s}.w3a-parent-container .dark\\:w3a--block:is(.w3a--dark *){display:block}.w3a-parent-container .dark\\:w3a--hidden:is(.w3a--dark *){display:none}.w3a-parent-container .dark\\:w3a--border:is(.w3a--dark *){border-width:1px}.w3a-parent-container .dark\\:w3a--border-app-gray-500:is(.w3a--dark *){border-color:var(--app-gray-500)}.w3a-parent-container .dark\\:w3a--border-app-gray-600:is(.w3a--dark *){border-color:var(--app-gray-600)}.w3a-parent-container .dark\\:w3a--border-app-gray-700:is(.w3a--dark *){border-color:var(--app-gray-700)}.w3a-parent-container .dark\\:w3a--border-app-gray-800:is(.w3a--dark *){border-color:var(--app-gray-800)}.w3a-parent-container .dark\\:w3a--border-app-green-500:is(.w3a--dark *){border-color:var(--app-green-500)}.w3a-parent-container .dark\\:w3a--border-app-primary-400:is(.w3a--dark *){border-color:var(--app-primary-400)}.w3a-parent-container .dark\\:w3a--border-app-primary-500:is(.w3a--dark *){border-color:var(--app-primary-500)}.w3a-parent-container .dark\\:w3a--border-app-red-500:is(.w3a--dark *){border-color:var(--app-red-500)}.w3a-parent-container .dark\\:w3a--bg-app-dark-surface-main:is(.w3a--dark *){background-color:var(--app-gray-900)}.w3a-parent-container .dark\\:w3a--bg-app-gray-200:is(.w3a--dark *){background-color:var(--app-gray-200)}.w3a-parent-container .dark\\:w3a--bg-app-gray-400:is(.w3a--dark *){background-color:var(--app-gray-400)}.w3a-parent-container .dark\\:w3a--bg-app-gray-500:is(.w3a--dark *){background-color:var(--app-gray-500)}.w3a-parent-container .dark\\:w3a--bg-app-gray-600:is(.w3a--dark *){background-color:var(--app-gray-600)}.w3a-parent-container .dark\\:w3a--bg-app-gray-700:is(.w3a--dark *){background-color:var(--app-gray-700)}.w3a-parent-container .dark\\:w3a--bg-app-gray-800:is(.w3a--dark *){background-color:var(--app-gray-800)}.w3a-parent-container .dark\\:w3a--bg-transparent:is(.w3a--dark *){background-color:initial}.w3a-parent-container .dark\\:w3a--text-app-gray-200:is(.w3a--dark *){color:var(--app-gray-200)}.w3a-parent-container .dark\\:w3a--text-app-gray-300:is(.w3a--dark *){color:var(--app-gray-300)}.w3a-parent-container .dark\\:w3a--text-app-gray-400:is(.w3a--dark *){color:var(--app-gray-400)}.w3a-parent-container .dark\\:w3a--text-app-gray-500:is(.w3a--dark *){color:var(--app-gray-500)}.w3a-parent-container .dark\\:w3a--text-app-green-400:is(.w3a--dark *){color:var(--app-green-400)}.w3a-parent-container .dark\\:w3a--text-app-primary-400:is(.w3a--dark *){color:var(--app-primary-400)}.w3a-parent-container .dark\\:w3a--text-app-primary-500:is(.w3a--dark *){color:var(--app-primary-500)}.w3a-parent-container .dark\\:w3a--text-app-red-400:is(.w3a--dark *){color:var(--app-red-400)}.w3a-parent-container .dark\\:w3a--text-app-white:is(.w3a--dark *){color:var(--app-white)}.w3a-parent-container .dark\\:placeholder\\:w3a--text-app-gray-500:is(.w3a--dark *)::placeholder{color:var(--app-gray-500)}.w3a-parent-container .dark\\:hover\\:w3a--border-app-gray-800:hover:is(.w3a--dark *){border-color:var(--app-gray-800)}.w3a-parent-container .dark\\:hover\\:w3a--border-transparent:hover:is(.w3a--dark *){border-color:#0000}.w3a-parent-container .dark\\:hover\\:\\!w3a--bg-app-gray-800:hover:is(.w3a--dark *){background-color:var(--app-gray-800)!important}.w3a-parent-container .dark\\:hover\\:w3a--bg-app-gray-600:hover:is(.w3a--dark *){background-color:var(--app-gray-600)}.w3a-parent-container .dark\\:hover\\:w3a--bg-app-gray-700:hover:is(.w3a--dark *){background-color:var(--app-gray-700)}.w3a-parent-container .dark\\:hover\\:w3a--text-app-white:hover:is(.w3a--dark *){color:var(--app-white)}.w3a-parent-container .dark\\:hover\\:w3a--shadow-dark:hover:is(.w3a--dark *){--tw-shadow:0px 2px 8px 2px #111928;--tw-shadow-colored:0px 2px 8px 2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}@media (min-width:640px){.w3a-parent-container .sm\\:w3a--left-8{left:2rem}.w3a-parent-container .sm\\:w3a--right-8{right:2rem}.w3a-parent-container .sm\\:w3a--justify-start{justify-content:flex-start}.w3a-parent-container .sm\\:w3a--justify-end{justify-content:flex-end}.w3a-parent-container .sm\\:w3a--shadow-lg{--tw-shadow:0 10px 15px -3px #0000001a,0 4px 6px -4px #0000001a;--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color),0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}}@media(min-width:375px){.w3a-parent-container .\\[\\@media\\(min-width\\:375px\\)\\]\\:w3a--w-\\[393px\\]{width:393px}}';
styleInject(css_248z);

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/loginModal.js
var import_client = __toESM(require_client());

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/utils.js
var getLoginModalAnalyticsProperties = (uiConfig) => {
  return {
    ui_modal_login_methods_order: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.loginMethodsOrder,
    ui_modal_z_index: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.modalZIndex,
    ui_modal_display_errors_on_modal: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.displayErrorsOnModal,
    ui_modal_login_grid_col: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.loginGridCol,
    ui_modal_primary_button: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.primaryButton,
    ui_modal_widget_type: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.widgetType,
    ui_modal_target_id_used: Boolean(uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.targetId),
    ui_modal_logo_alignment: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.logoAlignment,
    ui_modal_border_radius_type: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.borderRadiusType,
    ui_modal_button_radius_type: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.buttonRadiusType,
    ui_modal_sign_in_methods: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.signInMethods,
    ui_modal_add_previous_login_hint: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.addPreviousLoginHint,
    ui_modal_display_installed_external_wallets: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.displayInstalledExternalWallets,
    ui_modal_display_external_wallets_count: uiConfig === null || uiConfig === void 0 ? void 0 : uiConfig.displayExternalWalletsCount
  };
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Widget/Widget.js
var import_deepmerge4 = __toESM(require_cjs());
var import_react29 = __toESM(require_react());

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/constants.js
var PAGES = {
  LOGIN: "login",
  CONNECT_WALLET: "connect_wallet"
};
var CONNECT_WALLET_PAGES = {
  CONNECT_WALLET: "Connect Your Wallet",
  SELECTED_WALLET: "Selected Wallet"
};
var DEFAULT_LOGO_LIGHT = "https://images.web3auth.io/web3auth-logo-w.svg";
var DEFAULT_LOGO_DARK = "https://images.web3auth.io/web3auth-logo-w-light.svg";
var WALLET_CONNECT_LOGO = "https://images.web3auth.io/login-wallet-connect.svg";
var DEFAULT_PRIMARY_COLOR = "#0364FF";
var DEFAULT_ON_PRIMARY_COLOR = "#FFFFFF";
var DEFAULT_METAMASK_WALLET_REGISTRY_ITEM = {
  app: {
    android: "io.metamask",
    chrome: "nkbihfbeogaeaoehlefnkodbefgpgknn",
    edge: "ejbalbakoplchlghecdalmeeeajnimhm",
    firefox: "ether-metamask",
    ios: "id1438144202"
  },
  chains: ["eip155:1"],
  imgExtension: "webp",
  injected: [{
    injected_id: "isMetaMask",
    namespace: "eip155"
  }],
  mobile: {
    inAppBrowser: "https://metamask.app.link/dapp",
    native: "metamask://wc",
    universal: "https://metamask.app.link/wc"
  },
  name: "MetaMask",
  primaryColor: "#E2761B",
  walletConnect: {
    sdks: ["sign_v1", "sign_v2"]
  }
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Embed/Embed.js
var import_react = __toESM(require_react());

// node_modules/@web3auth/modal/node_modules/clsx/dist/clsx.mjs
function r2(e8) {
  var t3, f2, n2 = "";
  if ("string" == typeof e8 || "number" == typeof e8) n2 += e8;
  else if ("object" == typeof e8) if (Array.isArray(e8)) {
    var o = e8.length;
    for (t3 = 0; t3 < o; t3++) e8[t3] && (f2 = r2(e8[t3])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e8) e8[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e8, t3, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e8 = arguments[f2]) && (t3 = r2(e8)) && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
var clsx_default = clsx;

// node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  var _a2;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a2 = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a2.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config) => {
  const {
    theme,
    classGroups
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const classGroupId in classGroups) {
    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
  }
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache2 = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache2.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache2;
      cache2 = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache2.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache2.has(key)) {
        cache2.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var MODIFIER_SEPARATOR = ":";
var MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
var createParseClassName = (config) => {
  const {
    prefix,
    experimentalParseClassName
  } = config;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className.length; index++) {
      let currentCharacter = className[index];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      } else if (currentCharacter === "(") {
        parenDepth++;
      } else if (currentCharacter === ")") {
        parenDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
    const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
      isExternal: true,
      modifiers: [],
      hasImportantModifier: false,
      baseClassName: className,
      maybePostfixModifierPosition: void 0
    };
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => experimentalParseClassName({
      className,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
var stripImportantModifier = (baseClassName) => {
  if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(0, baseClassName.length - 1);
  }
  if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(1);
  }
  return baseClassName;
};
var createSortModifiers = (config) => {
  const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, true]));
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isPositionSensitive = modifier[0] === "[" || orderSensitiveModifiers[modifier];
      if (isPositionSensitive) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  return sortModifiers;
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k3 = 0; k3 < mix.length; k3++) {
    if (mix[k3]) {
      if (resolvedValue = toValue(mix[k3])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
var arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
var fractionRegex = /^\d+\/\d+$/;
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isFraction = (value) => fractionRegex.test(value);
var isNumber = (value) => !!value && !Number.isNaN(Number(value));
var isInteger = (value) => !!value && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var isAny = () => true;
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
var isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
var isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
var isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
var isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
var isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
var isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
var isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
var isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
var isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
var isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
var getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
var isLabelPosition = (label) => label === "position" || label === "percentage";
var isLabelImage = (label) => label === "image" || label === "url";
var isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
var isLabelLength = (label) => label === "length";
var isLabelNumber = (label) => label === "number";
var isLabelFamilyName = (label) => label === "family-name";
var isLabelShadow = (label) => label === "shadow";
var validators = Object.defineProperty({
  __proto__: null,
  isAny,
  isAnyNonArbitrary,
  isArbitraryImage,
  isArbitraryLength,
  isArbitraryNumber,
  isArbitraryPosition,
  isArbitraryShadow,
  isArbitrarySize,
  isArbitraryValue,
  isArbitraryVariable,
  isArbitraryVariableFamilyName,
  isArbitraryVariableImage,
  isArbitraryVariableLength,
  isArbitraryVariablePosition,
  isArbitraryVariableShadow,
  isArbitraryVariableSize,
  isFraction,
  isInteger,
  isNumber,
  isPercent,
  isTshirtSize
}, Symbol.toStringTag, {
  value: "Module"
});
var getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeTextShadow = fromTheme("text-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ];
  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isInteger, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {
    position: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleBgRepeat = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }];
  const scaleBgSize = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
    size: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": scaleBreak()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": scaleBreak()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: scalePositionWithArbitrary()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: scaleOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: scaleInset()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: scaleInset()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: scaleInset()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: scaleInset()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: scaleInset()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: scaleInset()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: scaleInset()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: scaleMargin()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: scaleMargin()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: scaleMargin()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: scaleMargin()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: scaleMargin()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: scaleMargin()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: scaleMargin()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: scaleMargin()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: scaleMargin()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: scaleSizing()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...scaleSizing()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...scaleSizing()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...scaleSizing()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...scaleSizing()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: scaleColor()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: scaleBgPosition()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: scaleBgRepeat()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: scaleBgSize()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: scaleColor()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: scaleColor()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: scaleColor()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: scaleColor()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: scaleRadius()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: scaleBorderWidth()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: scaleColor()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: scaleColor()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: scaleColor()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: scaleColor()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: scaleColor()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": scaleColor()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [isNumber]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": scaleMaskImagePosition()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": scaleMaskImagePosition()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": scaleColor()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": scaleColor()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": scaleMaskImagePosition()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": scaleMaskImagePosition()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": scaleColor()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": scaleColor()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": scaleMaskImagePosition()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": scaleMaskImagePosition()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": scaleColor()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": scaleColor()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": scaleMaskImagePosition()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": scaleMaskImagePosition()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": scaleColor()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": scaleColor()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": scaleMaskImagePosition()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": scaleMaskImagePosition()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": scaleColor()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": scaleColor()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": scaleMaskImagePosition()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": scaleMaskImagePosition()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": scaleColor()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": scaleColor()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": scaleMaskImagePosition()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": scaleMaskImagePosition()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": scaleColor()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": scaleColor()
      }],
      "mask-image-radial": [{
        "mask-radial": [isArbitraryVariable, isArbitraryValue]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": scaleMaskImagePosition()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": scaleMaskImagePosition()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": scaleColor()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": scaleColor()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": scalePosition()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [isNumber]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": scaleMaskImagePosition()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": scaleMaskImagePosition()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": scaleColor()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": scaleColor()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: scaleBgPosition()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: scaleBgRepeat()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: scaleBgSize()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: scaleBlur()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeDropShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": scaleColor()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": scalePositionWithArbitrary()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: scaleRotate()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: scaleScale()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: scaleSkew()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: scalePositionWithArbitrary()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: scaleTranslate()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: scaleColor()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: scaleColor()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
};
var twMerge = createTailwindMerge(getDefaultConfig);

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/utils.js
var cache = /* @__PURE__ */ new Map();
function cn2(...inputs) {
  const cacheKey = JSON.stringify(inputs);
  if (cache.has(cacheKey)) {
    return cache.get(cacheKey);
  }
  const result = twMerge(clsx_default(inputs));
  cache.set(cacheKey, result);
  return result;
}
var getBrowserExtensionUrl = (browserType, walletId) => {
  if (walletId !== null && walletId !== void 0 && walletId.startsWith("https://")) return walletId;
  switch (browserType) {
    case "chrome":
      return `https://chrome.google.com/webstore/detail/${walletId}`;
    case "firefox":
      return `https://addons.mozilla.org/firefox/addon/${walletId}`;
    case "edge":
      return `https://microsoftedge.microsoft.com/addons/detail/${walletId}`;
    default:
      return null;
  }
};
var getMobileInstallLink = (os2, appId) => {
  if (appId !== null && appId !== void 0 && appId.includes("https://")) {
    return appId;
  }
  switch (os2) {
    case "android":
      return `https://play.google.com/store/apps/details?id=${appId}`;
    case "ios":
      return `https://apps.apple.com/app/safepal-wallet/${appId}`;
    default:
      return "";
  }
};
var getOsName = (os2) => {
  switch (os2) {
    case "ios":
      return "iOS";
    case "android":
      return "Android";
    default:
      return "";
  }
};
var getBrowserName = (browserType) => {
  return browserType.charAt(0).toUpperCase() + browserType.slice(1);
};
var getIcons = (icon) => {
  return `https://images.web3auth.io/login-modal/${icon}.svg`;
};
var passwordlessBackendUrl = "https://api.web3auth.io/passwordless-service";
var getUserCountry = async () => {
  try {
    const result = await get(`${passwordlessBackendUrl}/api/v3/user/location`);
    if (result && result.data.country) return {
      country: result.data.country,
      dialCode: result.data.dial_code
    };
    return null;
  } catch (error) {
    log.error("error getting user country", error);
    return null;
  }
};
var validatePhoneNumber = async (phoneNumber) => {
  try {
    const result = await post(`${passwordlessBackendUrl}/api/v3/phone_number/validate`, {
      phone_number: phoneNumber
    });
    if (result && result.success) return result;
    return {
      success: false,
      parsed_number: "",
      country_flag: ""
    };
  } catch (error) {
    log.error("error validating phone number", error);
    if (error.status === 400) {
      return {
        success: false,
        parsed_number: "",
        country_flag: ""
      };
    }
    return {
      success: false,
      parsed_number: "",
      country_flag: ""
    };
  }
};
var getUserLanguage = (defaultLanguage) => {
  let userLanguage = defaultLanguage;
  if (!userLanguage) {
    const browserLanguage = typeof window !== "undefined" ? window.navigator.userLanguage || window.navigator.language || "en-US" : "en-US";
    userLanguage = browserLanguage.split("-")[0];
  }
  return Object.prototype.hasOwnProperty.call(LANGUAGE_MAP, userLanguage) ? userLanguage : LANGUAGES.en;
};
function formatIOSMobile(params) {
  const encodedUri = encodeURIComponent(params.uri);
  if (params.link.startsWith("http")) return `${params.link}/wc?uri=${encodedUri}`;
  if (params.link) return `${params.link}wc?uri=${encodedUri}`;
  return "";
}
var getErrorMessages = (errorCode) => {
  if (!errorCode) return "passwordless.something-wrong-error";
  switch (errorCode) {
    case "E001":
      return "passwordless.error-invalid-params";
    case "E002":
      return "passwordless.error-invalid-origin";
    case "E201":
      return "passwordless.error-sending-sms-failed";
    case "E300":
      return "passwordless.error-no-mail-generated";
    case "E301":
      return "passwordless.error-invalid-link";
    case "E302":
      return "passwordless.error-new-link-generated-heading";
    case "E304":
    case "E403":
      return "passwordless.error-max-retry-limit-reached";
    case "E305":
    case "E401":
      return "passwordless.error-invalid-otp";
    case "E306":
      return "passwordless.error-otp-expired";
    case "E400":
      return "passwordless.error-no-sms-generated";
    case "E411":
      return "passwordless.error-plan-limit-reached";
    case "E412":
      return "passwordless.error-recaptcha-verification-failed";
    case "E502":
      return "passwordless.error-invalid-test-account";
    default:
      return "passwordless.something-wrong-error";
  }
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Embed/Embed.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
function Embed(props) {
  const {
    open = true,
    padding = true,
    shadow = true,
    border = false,
    showCloseIcon = false,
    onClose,
    children,
    borderRadius = "large"
  } = props;
  const [isOpen, setIsOpen] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    if (open) {
      setTimeout(() => {
        setIsOpen(true);
      }, 50);
    } else {
      setIsOpen(false);
    }
  }, [open]);
  const onCloseHandler = () => {
    if (onClose) onClose();
  };
  if (!isOpen) return null;
  return (0, import_jsx_runtime.jsxs)("div", {
    className: cn2("w3a--bg-app-light-surface1 dark:w3a--bg-app-dark-surface-main w3a--rounded-3xl w3a--w-[356px] [@media(min-width:375px)]:w3a--w-[393px] w3a--h-auto w3a--flex w3a--flex-col w3a--duration-500", {
      "w3a--translate-y-0 w3a--delay-100": isOpen,
      "w3a--translate-y-[100vh]": !isOpen,
      "w3a--p-4": padding,
      "w3a--shadow-xl sm:w3a--shadow-lg": shadow,
      "w3a--border w3a--border-app-gray-100 dark:w3a--border-app-gray-800": border,
      "w3a--rounded-[30px]": borderRadius === "large",
      "w3a--rounded-2xl": borderRadius === "medium",
      "w3a--rounded-none": borderRadius === "small"
    }),
    children: [showCloseIcon && (0, import_jsx_runtime.jsx)("div", {
      className: "w3a--absolute w3a--right-6 w3a--top-[30px] w3a--z-10 w3a--cursor-pointer",
      children: (0, import_jsx_runtime.jsx)("svg", {
        width: "13",
        height: "13",
        viewBox: "0 0 13 13",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        onClick: onCloseHandler,
        className: "w3a--text-app-gray-900 dark:w3a--text-app-white",
        children: (0, import_jsx_runtime.jsx)("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M0.292787 1.29299C0.480314 1.10552 0.734622 1.0002 0.999786 1.0002C1.26495 1.0002 1.51926 1.10552 1.70679 1.29299L5.99979 5.58599L10.2928 1.29299C10.385 1.19748 10.4954 1.1213 10.6174 1.06889C10.7394 1.01648 10.8706 0.988893 11.0034 0.987739C11.1362 0.986585 11.2678 1.01189 11.3907 1.06217C11.5136 1.11245 11.6253 1.1867 11.7192 1.28059C11.8131 1.37449 11.8873 1.48614 11.9376 1.60904C11.9879 1.73193 12.0132 1.86361 12.012 1.99639C12.0109 2.12917 11.9833 2.26039 11.9309 2.38239C11.8785 2.5044 11.8023 2.61474 11.7068 2.70699L7.41379 6.99999L11.7068 11.293C11.8889 11.4816 11.9897 11.7342 11.9875 11.9964C11.9852 12.2586 11.88 12.5094 11.6946 12.6948C11.5092 12.8802 11.2584 12.9854 10.9962 12.9877C10.734 12.9899 10.4814 12.8891 10.2928 12.707L5.99979 8.41399L1.70679 12.707C1.51818 12.8891 1.26558 12.9899 1.00339 12.9877C0.741188 12.9854 0.490376 12.8802 0.304968 12.6948C0.11956 12.5094 0.0143906 12.2586 0.0121121 11.9964C0.00983372 11.7342 0.110629 11.4816 0.292787 11.293L4.58579 6.99999L0.292787 2.70699C0.105316 2.51946 0 2.26515 0 1.99999C0 1.73483 0.105316 1.48052 0.292787 1.29299V1.29299Z",
          fill: "currentColor"
        })
      })
    }), children]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Modal/Modal.js
var import_react2 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function Modal(props) {
  const {
    children,
    open,
    onClose,
    placement = "center",
    padding = true,
    shadow = true,
    border = false,
    showCloseIcon = true,
    borderRadius = "large"
  } = props;
  const [isOpen, setIsOpen] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    if (open) {
      document.body.style.overflow = "hidden";
      setTimeout(() => {
        setIsOpen(true);
      }, 50);
    } else {
      setIsOpen(false);
      document.body.style.overflow = "";
    }
  }, [open]);
  const positions = (0, import_react2.useMemo)(() => ({
    center: "w3a--top-0 w3a--left-0 w3a--items-center w3a--justify-center",
    "top-center": "w3a--top-8 w3a--left-0 w3a--items-start w3a--justify-center",
    "bottom-center": "w3a--bottom-8 w3a--left-0 w3a--items-end w3a--justify-center",
    left: "sm:w3a--left-8 w3a--flex w3a--items-center w3a--justify-center sm:w3a--justify-start",
    right: "sm:w3a--right-8 w3a--flex w3a--items-center w3a--justify-center sm:w3a--justify-end"
  }), []);
  const placementClass = (0, import_react2.useMemo)(() => positions[placement], [placement, positions]);
  const onCloseHandler = () => {
    if (onClose) onClose();
  };
  return (0, import_jsx_runtime2.jsx)("div", {
    className: cn2("w3a--fixed w3a--z-50 w3a--overflow-hidden w3a--flex w3a--transition-all", placementClass, {
      "w3a--w-screen w3a--h-screen": isOpen,
      "w3a--w-0 w3a--h-0 w3a--delay-500": !isOpen
    }),
    children: (0, import_jsx_runtime2.jsxs)("div", {
      className: cn2("w3a--bg-app-light-surface1 dark:w3a--bg-app-dark-surface-main w3a--w-[356px] [@media(min-width:375px)]:w3a--w-[393px] w3a--h-auto w3a--flex w3a--flex-col w3a--duration-500", {
        "w3a--translate-y-0 w3a--delay-100": isOpen,
        "w3a--translate-y-[100vh]": !isOpen,
        "w3a--p-4": padding,
        "w3a--shadow-xl sm:w3a--shadow-lg": shadow,
        "w3a--border w3a--border-app-gray-100 dark:w3a--border-app-gray-800": border,
        "w3a--rounded-[30px]": borderRadius === "large",
        "w3a--rounded-2xl": borderRadius === "medium",
        "w3a--rounded-none": borderRadius === "small"
      }),
      children: [showCloseIcon && (0, import_jsx_runtime2.jsx)("div", {
        className: "w3a--absolute w3a--right-6 w3a--top-[30px] w3a--z-10 w3a--cursor-pointer",
        children: (0, import_jsx_runtime2.jsx)("svg", {
          width: "13",
          height: "13",
          viewBox: "0 0 13 13",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          onClick: onCloseHandler,
          className: "w3a--text-app-gray-500 hover:w3a--text-app-gray-900 dark:w3a--text-app-gray-200 dark:hover:w3a--text-app-white",
          children: (0, import_jsx_runtime2.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M0.292787 1.29299C0.480314 1.10552 0.734622 1.0002 0.999786 1.0002C1.26495 1.0002 1.51926 1.10552 1.70679 1.29299L5.99979 5.58599L10.2928 1.29299C10.385 1.19748 10.4954 1.1213 10.6174 1.06889C10.7394 1.01648 10.8706 0.988893 11.0034 0.987739C11.1362 0.986585 11.2678 1.01189 11.3907 1.06217C11.5136 1.11245 11.6253 1.1867 11.7192 1.28059C11.8131 1.37449 11.8873 1.48614 11.9376 1.60904C11.9879 1.73193 12.0132 1.86361 12.012 1.99639C12.0109 2.12917 11.9833 2.26039 11.9309 2.38239C11.8785 2.5044 11.8023 2.61474 11.7068 2.70699L7.41379 6.99999L11.7068 11.293C11.8889 11.4816 11.9897 11.7342 11.9875 11.9964C11.9852 12.2586 11.88 12.5094 11.6946 12.6948C11.5092 12.8802 11.2584 12.9854 10.9962 12.9877C10.734 12.9899 10.4814 12.8891 10.2928 12.707L5.99979 8.41399L1.70679 12.707C1.51818 12.8891 1.26558 12.9899 1.00339 12.9877C0.741188 12.9854 0.490376 12.8802 0.304968 12.6948C0.11956 12.5094 0.0143906 12.2586 0.0121121 11.9964C0.00983372 11.7342 0.110629 11.4816 0.292787 11.293L4.58579 6.99999L0.292787 2.70699C0.105316 2.51946 0 2.26515 0 1.99999C0 1.73483 0.105316 1.48052 0.292787 1.29299V1.29299Z",
            fill: "currentColor"
          })
        })
      }), children]
    })
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Root/Root.js
var import_react28 = __toESM(require_react());

// node_modules/react-i18next/dist/es/Trans.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/TransWithoutContext.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
var import_void_elements = __toESM(require_void_elements());

// node_modules/react-i18next/dist/es/utils.js
var warn = (i18n, code, msg, rest) => {
  var _a2, _b, _c2, _d2;
  const args = [msg, {
    code,
    ...rest || {}
  }];
  if ((_b = (_a2 = i18n == null ? void 0 : i18n.services) == null ? void 0 : _a2.logger) == null ? void 0 : _b.forward) {
    return i18n.services.logger.forward(args, "warn", "react-i18next::", true);
  }
  if (isString(args[0])) args[0] = `react-i18next:: ${args[0]}`;
  if ((_d2 = (_c2 = i18n == null ? void 0 : i18n.services) == null ? void 0 : _c2.logger) == null ? void 0 : _d2.warn) {
    i18n.services.logger.warn(...args);
  } else if (console == null ? void 0 : console.warn) {
    console.warn(...args);
  }
};
var alreadyWarned = {};
var warnOnce = (i18n, code, msg, rest) => {
  if (isString(msg) && alreadyWarned[msg]) return;
  if (isString(msg)) alreadyWarned[msg] = /* @__PURE__ */ new Date();
  warn(i18n, code, msg, rest);
};
var loadedClb = (i18n, cb) => () => {
  if (i18n.isInitialized) {
    cb();
  } else {
    const initialized = () => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0);
      cb();
    };
    i18n.on("initialized", initialized);
  }
};
var loadNamespaces = (i18n, ns2, cb) => {
  i18n.loadNamespaces(ns2, loadedClb(i18n, cb));
};
var loadLanguages = (i18n, lng, ns2, cb) => {
  if (isString(ns2)) ns2 = [ns2];
  if (i18n.options.preload && i18n.options.preload.indexOf(lng) > -1) return loadNamespaces(i18n, ns2, cb);
  ns2.forEach((n2) => {
    if (i18n.options.ns.indexOf(n2) < 0) i18n.options.ns.push(n2);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb));
};
var hasLoadedNamespace = (ns2, i18n, options2 = {}) => {
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce(i18n, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
      languages: i18n.languages
    });
    return true;
  }
  return i18n.hasLoadedNamespace(ns2, {
    lng: options2.lng,
    precheck: (i18nInstance3, loadNotPending) => {
      if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18nInstance3.services.backendConnector.backend && i18nInstance3.isLanguageChangingTo && !loadNotPending(i18nInstance3.isLanguageChangingTo, ns2)) return false;
    }
  });
};
var isString = (obj) => typeof obj === "string";
var isObject = (obj) => typeof obj === "object" && obj !== null;

// node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
var htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
};
var unescapeHtmlEntity = (m2) => htmlEntities[m2];
var unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);

// node_modules/react-i18next/dist/es/defaults.js
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape
};
var setDefaults = (options2 = {}) => {
  defaultOptions = {
    ...defaultOptions,
    ...options2
  };
};
var getDefaults = () => defaultOptions;

// node_modules/react-i18next/dist/es/i18nInstance.js
var i18nInstance;
var setI18n = (instance2) => {
  i18nInstance = instance2;
};
var getI18n = () => i18nInstance;

// node_modules/react-i18next/dist/es/context.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/initReactI18next.js
var initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};

// node_modules/react-i18next/dist/es/context.js
var I18nContext = (0, import_react4.createContext)();
var ReportNamespaces = class {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns2) => {
      if (!this.usedNamespaces[ns2]) this.usedNamespaces[ns2] = true;
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
};

// node_modules/react-i18next/dist/es/useTranslation.js
var import_react6 = __toESM(require_react(), 1);
var usePrevious = (value, ignore) => {
  const ref = (0, import_react6.useRef)();
  (0, import_react6.useEffect)(() => {
    ref.current = ignore ? ref.current : value;
  }, [value, ignore]);
  return ref.current;
};
var alwaysNewT = (i18n, language, namespace, keyPrefix) => i18n.getFixedT(language, namespace, keyPrefix);
var useMemoizedT = (i18n, language, namespace, keyPrefix) => (0, import_react6.useCallback)(alwaysNewT(i18n, language, namespace, keyPrefix), [i18n, language, namespace, keyPrefix]);
var useTranslation = (ns2, props = {}) => {
  var _a2, _b, _c2, _d2;
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = (0, import_react6.useContext)(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce(i18n, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = (k3, optsOrDefaultValue) => {
      if (isString(optsOrDefaultValue)) return optsOrDefaultValue;
      if (isObject(optsOrDefaultValue) && isString(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
      return Array.isArray(k3) ? k3[k3.length - 1] : k3;
    };
    const retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if ((_a2 = i18n.options.react) == null ? void 0 : _a2.wait) warnOnce(i18n, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = {
    ...getDefaults(),
    ...i18n.options.react,
    ...props
  };
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = ns2 || defaultNSFromContext || ((_b = i18n.options) == null ? void 0 : _b.defaultNS);
  namespaces = isString(namespaces) ? [namespaces] : namespaces || ["translation"];
  (_d2 = (_c2 = i18n.reportNamespaces).addUsedNamespaces) == null ? void 0 : _d2.call(_c2, namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions));
  const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  const getT = () => memoGetT;
  const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  const [t3, setT] = (0, import_react6.useState)(getT);
  let joinedNS = namespaces.join();
  if (props.lng) joinedNS = `${props.lng}${joinedNS}`;
  const previousJoinedNS = usePrevious(joinedNS);
  const isMounted = (0, import_react6.useRef)(true);
  (0, import_react6.useEffect)(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, () => {
          if (isMounted.current) setT(getNewT);
        });
      } else {
        loadNamespaces(i18n, namespaces, () => {
          if (isMounted.current) setT(getNewT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getNewT);
    }
    const boundReset = () => {
      if (isMounted.current) setT(getNewT);
    };
    if (bindI18n) i18n == null ? void 0 : i18n.on(bindI18n, boundReset);
    if (bindI18nStore) i18n == null ? void 0 : i18n.store.on(bindI18nStore, boundReset);
    return () => {
      isMounted.current = false;
      if (i18n && bindI18n) bindI18n == null ? void 0 : bindI18n.split(" ").forEach((e8) => i18n.off(e8, boundReset));
      if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach((e8) => i18n.store.off(e8, boundReset));
    };
  }, [i18n, joinedNS]);
  (0, import_react6.useEffect)(() => {
    if (isMounted.current && ready) {
      setT(getT);
    }
  }, [i18n, keyPrefix, ready]);
  const ret = [t3, i18n, ready];
  ret.t = t3;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready) return ret;
  if (!ready && !useSuspense) return ret;
  throw new Promise((resolve) => {
    if (props.lng) {
      loadLanguages(i18n, props.lng, namespaces, () => resolve());
    } else {
      loadNamespaces(i18n, namespaces, () => resolve());
    }
  });
};

// node_modules/react-i18next/dist/es/withTranslation.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/I18nextProvider.js
var import_react8 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/withSSR.js
var import_react10 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/useSSR.js
var import_react9 = __toESM(require_react(), 1);

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/context/RootContext.js
var import_react11 = __toESM(require_react());
var RootContext = (0, import_react11.createContext)({
  bodyState: {
    metamaskQrCode: {
      show: false,
      wallet: null
    },
    installLinks: {
      show: false,
      wallet: null
    },
    multiChainSelector: {
      show: false,
      wallet: null
    }
  },
  toast: {
    message: "",
    type: TOAST_TYPE.SUCCESS
  },
  setBodyState: () => {
  },
  setToast: () => {
  }
});

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/context/ThemeContext.js
var import_react12 = __toESM(require_react());
var ThemedContext = (0, import_react12.createContext)({
  isDark: true
  // default value
});

// node_modules/i18next/dist/esm/i18next.js
var isString2 = (obj) => typeof obj === "string";
var defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
var makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
var copy = (a, s, t3) => {
  a.forEach((m2) => {
    if (s[m2]) t3[m2] = s[m2];
  });
};
var lastOfPathSeparatorRegExp = /###/g;
var cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
var canNotTraverseDeeper = (object) => !object || isString2(object);
var getLastOfPath = (object, path, Empty) => {
  const stack = !isString2(path) ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
var setPath = (object, path, newValue) => {
  const {
    obj,
    k: k3
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k3] = newValue;
    return;
  }
  let e8 = path[path.length - 1];
  let p3 = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p3, Object);
  while (last.obj === void 0 && p3.length) {
    e8 = `${p3[p3.length - 1]}.${e8}`;
    p3 = p3.slice(0, p3.length - 1);
    last = getLastOfPath(object, p3, Object);
    if ((last == null ? void 0 : last.obj) && typeof last.obj[`${last.k}.${e8}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e8}`] = newValue;
};
var pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k: k3
  } = getLastOfPath(object, path, Object);
  obj[k3] = obj[k3] || [];
  obj[k3].push(newValue);
};
var getPath = (object, path) => {
  const {
    obj,
    k: k3
  } = getLastOfPath(object, path);
  if (!obj) return void 0;
  if (!Object.prototype.hasOwnProperty.call(obj, k3)) return void 0;
  return obj[k3];
};
var getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
var deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString2(target[prop]) || target[prop] instanceof String || isString2(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
var regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
var escape = (data) => {
  if (isString2(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
};
var RegExpCache = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
};
var chars = [" ", ",", "?", "!", ";"];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);
var looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0) return true;
  const r3 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
  let matched = !r3.test(key);
  if (!matched) {
    const ki2 = key.indexOf(keySeparator);
    if (ki2 > 0 && !r3.test(key.substring(0, ki2))) {
      matched = true;
    }
  }
  return matched;
};
var deepFind = (obj, path, keySeparator = ".") => {
  if (!obj) return void 0;
  if (obj[path]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path)) return void 0;
    return obj[path];
  }
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i2 = 0; i2 < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j3 = i2; j3 < tokens.length; ++j3) {
      if (j3 !== i2) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j3];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j3 < tokens.length - 1) {
          continue;
        }
        i2 += j3 - i2 + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
var getCleanedCode = (code) => code == null ? void 0 : code.replace("_", "-");
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    var _a2, _b;
    (_b = (_a2 = console == null ? void 0 : console[type]) == null ? void 0 : _a2.apply) == null ? void 0 : _b.call(_a2, console, args);
  }
};
var Logger = class _Logger {
  constructor(concreteLogger, options2 = {}) {
    this.init(concreteLogger, options2);
  }
  init(concreteLogger, options2 = {}) {
    this.prefix = options2.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options2;
    this.debug = options2.debug;
  }
  log(...args) {
    return this.forward(args, "log", "", true);
  }
  warn(...args) {
    return this.forward(args, "warn", "", true);
  }
  error(...args) {
    return this.forward(args, "error", "");
  }
  deprecate(...args) {
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString2(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options2) {
    options2 = options2 || this.options;
    options2.prefix = options2.prefix || this.prefix;
    return new _Logger(this.logger, options2);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event, ...args) {
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
var ResourceStore = class extends EventEmitter {
  constructor(data, options2 = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super();
    this.data = data || {};
    this.options = options2;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns2) {
    if (this.options.ns.indexOf(ns2) < 0) {
      this.options.ns.push(ns2);
    }
  }
  removeNamespaces(ns2) {
    const index = this.options.ns.indexOf(ns2);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns2, key, options2 = {}) {
    var _a2, _b;
    const keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns2];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString2(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns2 && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns2 = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString2(key)) return result;
    return deepFind((_b = (_a2 = this.data) == null ? void 0 : _a2[lng]) == null ? void 0 : _b[ns2], key, keySeparator);
  }
  addResource(lng, ns2, key, value, options2 = {
    silent: false
  }) {
    const keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
    let path = [lng, ns2];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns2;
      ns2 = path[1];
    }
    this.addNamespaces(ns2);
    setPath(this.data, path, value);
    if (!options2.silent) this.emit("added", lng, ns2, key, value);
  }
  addResources(lng, ns2, resources, options2 = {
    silent: false
  }) {
    for (const m2 in resources) {
      if (isString2(resources[m2]) || Array.isArray(resources[m2])) this.addResource(lng, ns2, m2, resources[m2], {
        silent: true
      });
    }
    if (!options2.silent) this.emit("added", lng, ns2, resources);
  }
  addResourceBundle(lng, ns2, resources, deep, overwrite, options2 = {
    silent: false,
    skipCopy: false
  }) {
    let path = [lng, ns2];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources;
      resources = ns2;
      ns2 = path[1];
    }
    this.addNamespaces(ns2);
    let pack = getPath(this.data, path) || {};
    if (!options2.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options2.silent) this.emit("added", lng, ns2, resources);
  }
  removeResourceBundle(lng, ns2) {
    if (this.hasResourceBundle(lng, ns2)) {
      delete this.data[lng][ns2];
    }
    this.removeNamespaces(ns2);
    this.emit("removed", lng, ns2);
  }
  hasResourceBundle(lng, ns2) {
    return this.getResource(lng, ns2) !== void 0;
  }
  getResourceBundle(lng, ns2) {
    if (!ns2) ns2 = this.options.defaultNS;
    return this.getResource(lng, ns2);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options2, translator) {
    processors.forEach((processor) => {
      var _a2;
      value = ((_a2 = this.processors[processor]) == null ? void 0 : _a2.process(value, key, options2, translator)) ?? value;
    });
    return value;
  }
};
var checkedLoadedFor = {};
var shouldHandleAsObject = (res) => !isString2(res) && typeof res !== "boolean" && typeof res !== "number";
var Translator = class _Translator extends EventEmitter {
  constructor(services, options2 = {}) {
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options2;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key, o = {
    interpolation: {}
  }) {
    const opt = {
      ...o
    };
    if (key == null) return false;
    const resolved = this.resolve(key, opt);
    return (resolved == null ? void 0 : resolved.res) !== void 0;
  }
  extractFromKey(key, opt) {
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    let namespaces = opt.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key,
          namespaces: isString2(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString2(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, o, lastKey) {
    let opt = typeof o === "object" ? {
      ...o
    } : o;
    if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
      opt = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") opt = {
      ...opt
    };
    if (!opt) opt = {};
    if (keys == null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = opt.returnDetails !== void 0 ? opt.returnDetails : this.options.returnDetails;
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], opt);
    const namespace = namespaces[namespaces.length - 1];
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const lng = opt.lng || this.language;
    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if ((lng == null ? void 0 : lng.toLowerCase()) === "cimode") {
      if (appendNamespaceToCIMode) {
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(opt)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(opt)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, opt);
    let res = resolved == null ? void 0 : resolved.res;
    const resUsedKey = (resolved == null ? void 0 : resolved.usedKey) || key;
    const resExactUsedKey = (resolved == null ? void 0 : resolved.exactUsedKey) || key;
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = opt.joinArrays !== void 0 ? opt.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = opt.count !== void 0 && !isString2(opt.count);
    const hasDefaultValue = _Translator.hasDefaultValue(opt);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
      ordinal: false
    }) : "";
    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString2(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!opt.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r3 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...opt,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r3;
          resolved.usedParams = this.getUsedParamsDetails(opt);
          return resolved;
        }
        return r3;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            if (hasDefaultValue && !res) {
              copy2[m2] = this.translate(deepKey, {
                ...opt,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m2] : void 0,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy2[m2] = this.translate(deepKey, {
                ...opt,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy2[m2] === deepKey) copy2[m2] = resForObjHndl[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString2(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, opt, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...opt,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
        } else {
          lngs.push(opt.lng || this.language);
        }
        const send = (l3, k3, specificDefaultValue) => {
          var _a2;
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l3, namespace, k3, defaultForMissing, updateMissing, opt);
          } else if ((_a2 = this.backendConnector) == null ? void 0 : _a2.saveMissing) {
            this.backendConnector.saveMissing(l3, namespace, k3, defaultForMissing, updateMissing, opt);
          }
          this.emit("missingKey", l3, namespace, k3, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, opt);
              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, opt, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {
        res = `${namespace}${nsSeparator}${key}`;
      }
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : void 0, opt);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(opt);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, opt, resolved, lastKey) {
    var _a2, _b;
    if ((_a2 = this.i18nFormat) == null ? void 0 : _a2.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...opt
      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!opt.skipInterpolation) {
      if (opt.interpolation) this.interpolator.init({
        ...opt,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...opt.interpolation
          }
        }
      });
      const skipOnVariables = isString2(res) && (((_b = opt == null ? void 0 : opt.interpolation) == null ? void 0 : _b.skipOnVariables) !== void 0 ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = opt.replace && !isString2(opt.replace) ? opt.replace : opt;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
      if (skipOnVariables) {
        const na2 = res.match(this.interpolator.nestingRegexp);
        const nestAft = na2 && na2.length;
        if (nestBef < nestAft) opt.nest = false;
      }
      if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;
      if (opt.nest !== false) res = this.interpolator.nest(res, (...args) => {
        if ((lastKey == null ? void 0 : lastKey[0]) === args[0] && !opt.context) {
          this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return this.translate(...args, key);
      }, opt);
      if (opt.interpolation) this.interpolator.reset();
    }
    const postProcess = opt.postProcess || this.options.postProcess;
    const postProcessorNames = isString2(postProcess) ? [postProcess] : postProcess;
    if (res != null && (postProcessorNames == null ? void 0 : postProcessorNames.length) && opt.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(opt)
        },
        ...opt
      } : opt, this);
    }
    return res;
  }
  resolve(keys, opt = {}) {
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString2(keys)) keys = [keys];
    keys.forEach((k3) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k3, opt);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = opt.count !== void 0 && !isString2(opt.count);
      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
      const needsContextHandling = opt.context !== void 0 && (isString2(opt.context) || typeof opt.context === "number") && opt.context !== "";
      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
      namespaces.forEach((ns2) => {
        var _a2, _b;
        if (this.isValidLookup(found)) return;
        usedNS = ns2;
        if (!checkedLoadedFor[`${codes[0]}-${ns2}`] && ((_a2 = this.utils) == null ? void 0 : _a2.hasLoadedNamespace) && !((_b = this.utils) == null ? void 0 : _b.hasLoadedNamespace(usedNS))) {
          checkedLoadedFor[`${codes[0]}-${ns2}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          var _a3;
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if ((_a3 = this.i18nFormat) == null ? void 0 : _a3.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns2, opt);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${opt.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns2, possibleKey, opt);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns2, key, options2 = {}) {
    var _a2;
    if ((_a2 = this.i18nFormat) == null ? void 0 : _a2.getResource) return this.i18nFormat.getResource(code, ns2, key, options2);
    return this.resourceStore.getResource(code, ns2, key, options2);
  }
  getUsedParamsDetails(options2 = {}) {
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options2.replace && !isString2(options2.replace);
    let data = useOptionsReplaceForData ? options2.replace : options2;
    if (useOptionsReplaceForData && typeof options2.count !== "undefined") {
      data.count = options2.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options2) {
    const prefix = "defaultValue";
    for (const option in options2) {
      if (Object.prototype.hasOwnProperty.call(options2, option) && prefix === option.substring(0, prefix.length) && void 0 !== options2[option]) {
        return true;
      }
    }
    return false;
  }
};
var LanguageUtil = class {
  constructor(options2) {
    this.options = options2;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p3 = code.split("-");
    if (p3.length === 2) return null;
    p3.pop();
    if (p3[p3.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p3.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p3 = code.split("-");
    return this.formatLanguageCode(p3[0]);
  }
  formatLanguageCode(code) {
    if (isString2(code) && code.indexOf("-") > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e8) {
      }
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngScOnly = this.getScriptPartFromCode(code);
        if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString2(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2) return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
      }
    };
    if (isString2(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString2(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc2) => {
      if (codes.indexOf(fc2) < 0) addCode(this.formatLanguageCode(fc2));
    });
    return codes;
  }
};
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
var dummyRule = {
  select: (count) => count === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
var PluralResolver = class {
  constructor(languageUtils, options2 = {}) {
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code, options2 = {}) {
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options2.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options2);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code, options2 = {}) {
    let rule = this.getRule(code, options2);
    if (!rule) rule = this.getRule("dev", options2);
    return (rule == null ? void 0 : rule.resolvedOptions().pluralCategories.length) > 1;
  }
  getPluralFormsOfKey(code, key, options2 = {}) {
    return this.getSuffixes(code, options2).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code, options2 = {}) {
    let rule = this.getRule(code, options2);
    if (!rule) rule = this.getRule("dev", options2);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options2.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count, options2 = {}) {
    const rule = this.getRule(code, options2);
    if (rule) {
      return `${this.options.prepend}${options2.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count, options2);
  }
};
var deepFindWithDefaults = (data, defaultData, key, keySeparator = ".", ignoreJSONStructure = true) => {
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString2(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === void 0) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
var regexSafe = (val) => val.replace(/\$/g, "$$$$");
var Interpolator = class {
  constructor(options2 = {}) {
    var _a2;
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = ((_a2 = options2 == null ? void 0 : options2.interpolation) == null ? void 0 : _a2.format) || ((value) => value);
    this.init(options2);
  }
  init(options2 = {}) {
    if (!options2.interpolation) options2.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options2.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if ((existingRegExp == null ? void 0 : existingRegExp.source) === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options2) {
    var _a2;
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options2,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p3 = key.split(this.formatSeparator);
      const k3 = p3.shift().trim();
      const f2 = p3.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k3, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
        ...options2,
        ...data,
        interpolationkey: k3
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = (options2 == null ? void 0 : options2.missingInterpolationHandler) || this.options.missingInterpolationHandler;
    const skipOnVariables = ((_a2 = options2 == null ? void 0 : options2.interpolation) == null ? void 0 : _a2.skipOnVariables) !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options2);
            value = isString2(temp) ? temp : "";
          } else if (options2 && Object.prototype.hasOwnProperty.call(options2, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString2(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc2, options2 = {}) {
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c2 = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c2[1]}`;
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (((matchedSingleQuotes == null ? void 0 : matchedSingleQuotes.length) ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e8) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e8);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options2
      };
      clonedOptions = clonedOptions.replace && !isString2(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf("}") + 1 : match[1].indexOf(this.formatSeparator);
      if (keyEndIndex !== -1) {
        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem) => elem.trim()).filter(Boolean);
        match[1] = match[1].slice(0, keyEndIndex);
      }
      value = fc2(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString2(value)) return value;
      if (!isString2(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (formatters.length) {
        value = formatters.reduce((v2, f2) => this.format(v2, f2, options2.lng, {
          ...options2,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
var parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p3 = formatStr.split("(");
    formatName = p3[0].toLowerCase().trim();
    const optStr = p3[1].substring(0, p3[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
var createCachedFormatter = (fn2) => {
  const cache2 = {};
  return (v2, l3, o) => {
    let optForCache = o;
    if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [o.interpolationkey]: void 0
      };
    }
    const key = l3 + JSON.stringify(optForCache);
    let frm = cache2[key];
    if (!frm) {
      frm = fn2(getCleanedCode(l3), o);
      cache2[key] = frm;
    }
    return frm(v2);
  };
};
var createNonCachedFormatter = (fn2) => (v2, l3, o) => fn2(getCleanedCode(l3), o)(v2);
var Formatter = class {
  constructor(options2 = {}) {
    this.logger = baseLogger.create("formatter");
    this.options = options2;
    this.init(options2);
  }
  init(services, options2 = {
    interpolation: {}
  }) {
    this.formatSeparator = options2.interpolation.formatSeparator || ",";
    const cf2 = options2.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;
    this.formats = {
      number: cf2((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: cf2((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: cf2((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: cf2((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: cf2((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
  }
  add(name, fc2) {
    this.formats[name.toLowerCase().trim()] = fc2;
  }
  addCached(name, fc2) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc2);
  }
  format(value, format, lng, options2 = {}) {
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f2) => {
      var _a2;
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f2);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = ((_a2 = options2 == null ? void 0 : options2.formatParams) == null ? void 0 : _a2[options2.interpolationkey]) || {};
          const l3 = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng;
          formatted = this.formats[formatName](mem, l3, {
            ...formatOptions,
            ...options2,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
var removePending = (q3, name) => {
  if (q3.pending[name] !== void 0) {
    delete q3.pending[name];
    q3.pendingCount--;
  }
};
var Connector = class extends EventEmitter {
  constructor(backend, store, services, options2 = {}) {
    var _a2, _b;
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options2.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options2.maxRetries >= 0 ? options2.maxRetries : 5;
    this.retryTimeout = options2.retryTimeout >= 1 ? options2.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    (_b = (_a2 = this.backend) == null ? void 0 : _a2.init) == null ? void 0 : _b.call(_a2, services, options2.backend, options2);
  }
  queueLoad(languages, namespaces, options2, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns2) => {
        const name = `${lng}|${ns2}`;
        if (!options2.reload && this.store.hasResourceBundle(lng, ns2)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns2] === void 0) toLoadNamespaces[ns2] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns2 = s[1];
    if (err) this.emit("failedLoading", lng, ns2, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns2, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q3) => {
      pushPath(q3.loaded, [lng], ns2);
      removePending(q3, name);
      if (err) q3.errors.push(err);
      if (q3.pendingCount === 0 && !q3.done) {
        Object.keys(q3.loaded).forEach((l3) => {
          if (!loaded[l3]) loaded[l3] = {};
          const loadedKeys = q3.loaded[l3];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l3][n2] === void 0) loaded[l3][n2] = true;
            });
          }
        });
        q3.done = true;
        if (q3.errors.length) {
          q3.callback(q3.errors);
        } else {
          q3.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q3) => !q3.done);
  }
  read(lng, ns2, fcName, tried = 0, wait = this.retryTimeout, callback) {
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns: ns2,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns2, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc2 = this.backend[fcName].bind(this.backend);
    if (fc2.length === 2) {
      try {
        const r3 = fc2(lng, ns2);
        if (r3 && typeof r3.then === "function") {
          r3.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r3);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc2(lng, ns2, resolver);
  }
  prepareLoading(languages, namespaces, options2 = {}, callback) {
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString2(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString2(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options2, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name, prefix = "") {
    const s = name.split("|");
    const lng = s[0];
    const ns2 = s[1];
    this.read(lng, ns2, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns2} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns2} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate, options2 = {}, clb = () => {
  }) {
    var _a2, _b, _c2, _d2, _e2;
    if (((_b = (_a2 = this.services) == null ? void 0 : _a2.utils) == null ? void 0 : _b.hasLoadedNamespace) && !((_d2 = (_c2 = this.services) == null ? void 0 : _c2.utils) == null ? void 0 : _d2.hasLoadedNamespace(namespace))) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if ((_e2 = this.backend) == null ? void 0 : _e2.create) {
      const opts = {
        ...options2,
        isUpdate
      };
      const fc2 = this.backend.create.bind(this.backend);
      if (fc2.length < 6) {
        try {
          let r3;
          if (fc2.length === 5) {
            r3 = fc2(languages, namespace, key, fallbackValue, opts);
          } else {
            r3 = fc2(languages, namespace, key, fallbackValue);
          }
          if (r3 && typeof r3.then === "function") {
            r3.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r3);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc2(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
var get2 = () => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString2(args[1])) ret.defaultValue = args[1];
    if (isString2(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options2 = args[3] || args[2];
      Object.keys(options2).forEach((key) => {
        ret[key] = options2[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  },
  cacheInBuiltFormats: true
});
var transformOptions = (options2) => {
  var _a2, _b;
  if (isString2(options2.ns)) options2.ns = [options2.ns];
  if (isString2(options2.fallbackLng)) options2.fallbackLng = [options2.fallbackLng];
  if (isString2(options2.fallbackNS)) options2.fallbackNS = [options2.fallbackNS];
  if (((_b = (_a2 = options2.supportedLngs) == null ? void 0 : _a2.indexOf) == null ? void 0 : _b.call(_a2, "cimode")) < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  if (typeof options2.initImmediate === "boolean") options2.initAsync = options2.initImmediate;
  return options2;
};
var noop = () => {
};
var bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
var I18n = class _I18n extends EventEmitter {
  constructor(options2 = {}, callback) {
    super();
    this.options = transformOptions(options2);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options2.isClone) {
      if (!this.options.initAsync) {
        this.init(options2, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options2, callback);
      }, 0);
    }
  }
  init(options2 = {}, callback) {
    this.isInitializing = true;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    if (options2.defaultNS == null && options2.ns) {
      if (isString2(options2.ns)) {
        options2.defaultNS = options2.ns;
      } else if (options2.ns.indexOf("translation") < 0) {
        options2.defaultNS = options2.ns[0];
      }
    }
    const defOpts = get2();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options2)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options2.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options2.keySeparator;
    }
    if (options2.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options2.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu2 = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu2;
      s.pluralResolver = new PluralResolver(lu2, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;
      if (usingLegacyFormatFunction) {
        this.logger.warn(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);
      }
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        if (s.formatter.init) s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init) m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = (...args) => this.store[fcName](...args);
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = (...args) => {
        this.store[fcName](...args);
        return this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t3) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t3);
        callback(err, t3);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language, callback = noop) {
    var _a2, _b;
    let usedCallback = callback;
    const usedLng = isString2(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if ((usedLng == null ? void 0 : usedLng.toLowerCase()) === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l3) => {
          if (l3 === "cimode") return;
          if (toLoad.indexOf(l3) < 0) toLoad.push(l3);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l3) => append(l3));
      } else {
        append(usedLng);
      }
      (_b = (_a2 = this.options.preload) == null ? void 0 : _a2.forEach) == null ? void 0 : _b.call(_a2, (l3) => append(l3));
      this.services.backendConnector.load(toLoad, this.options.ns, (e8) => {
        if (!e8 && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e8);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns2, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns2 === "function") {
      callback = ns2;
      ns2 = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns2) ns2 = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns2, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l3) {
    if (!l3 || !this.languages) return;
    if (["cimode", "dev"].indexOf(l3) > -1) return;
    for (let li2 = 0; li2 < this.languages.length; li2++) {
      const lngInLngs = this.languages[li2];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
    if (!this.resolvedLanguage && this.languages.indexOf(l3) < 0 && this.store.hasLanguageSomeTranslations(l3)) {
      this.resolvedLanguage = l3;
      this.languages.unshift(l3);
    }
  }
  changeLanguage(lng, callback) {
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l3) => {
      this.language = l3;
      this.languages = this.services.languageUtils.toResolveHierarchy(l3);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l3);
    };
    const done = (err, l3) => {
      if (l3) {
        if (this.isLanguageChangingTo === lng) {
          setLngProps(l3);
          this.translator.changeLanguage(l3);
          this.isLanguageChangingTo = void 0;
          this.emit("languageChanged", l3);
          this.logger.log("languageChanged", l3);
        }
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve((...args) => this.t(...args));
      if (callback) callback(err, (...args) => this.t(...args));
    };
    const setLng = (lngs) => {
      var _a2, _b;
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const fl2 = isString2(lngs) ? lngs : lngs && lngs[0];
      const l3 = this.store.hasLanguageSomeTranslations(fl2) ? fl2 : this.services.languageUtils.getBestMatchFromCodes(isString2(lngs) ? [lngs] : lngs);
      if (l3) {
        if (!this.language) {
          setLngProps(l3);
        }
        if (!this.translator.language) this.translator.changeLanguage(l3);
        (_b = (_a2 = this.services.languageDetector) == null ? void 0 : _a2.cacheUserLanguage) == null ? void 0 : _b.call(_a2, l3);
      }
      this.loadResources(l3, (err) => {
        done(err, l3);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns2, keyPrefix) {
    const fixedT = (key, opts, ...rest) => {
      let o;
      if (typeof opts !== "object") {
        o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        o = {
          ...opts
        };
      }
      o.lng = o.lng || fixedT.lng;
      o.lngs = o.lngs || fixedT.lngs;
      o.ns = o.ns || fixedT.ns;
      if (o.keyPrefix !== "") o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = this.options.keySeparator || ".";
      let resultKey;
      if (o.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k3) => `${o.keyPrefix}${keySeparator}${k3}`);
      } else {
        resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
      }
      return this.t(resultKey, o);
    };
    if (isString2(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns2;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t(...args) {
    var _a2;
    return (_a2 = this.translator) == null ? void 0 : _a2.translate(...args);
  }
  exists(...args) {
    var _a2;
    return (_a2 = this.translator) == null ? void 0 : _a2.exists(...args);
  }
  setDefaultNamespace(ns2) {
    this.options.defaultNS = ns2;
  }
  hasLoadedNamespace(ns2, options2 = {}) {
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options2.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l3, n2) => {
      const loadState = this.services.backendConnector.state[`${l3}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options2.precheck) {
      const preResult = options2.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns2)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2))) return true;
    return false;
  }
  loadNamespaces(ns2, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString2(ns2)) ns2 = [ns2];
    ns2.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString2(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    var _a2, _b;
    if (!lng) lng = this.resolvedLanguage || (((_a2 = this.languages) == null ? void 0 : _a2.length) > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    try {
      const l3 = new Intl.Locale(lng);
      if (l3 && l3.getTextInfo) {
        const ti2 = l3.getTextInfo();
        if (ti2 && ti2.direction) return ti2.direction;
      }
    } catch (e8) {
    }
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = ((_b = this.services) == null ? void 0 : _b.languageUtils) || new LanguageUtil(get2());
    if (lng.toLowerCase().indexOf("-latn") > 1) return "ltr";
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(options2 = {}, callback) {
    return new _I18n(options2, callback);
  }
  cloneInstance(options2 = {}, callback = noop) {
    const forkResourceStore = options2.forkResourceStore;
    if (forkResourceStore) delete options2.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options2,
      ...{
        isClone: true
      }
    };
    const clone = new _I18n(mergedOptions);
    if (options2.debug !== void 0 || options2.prefix !== void 0) {
      clone.logger = clone.logger.clone(options2);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone[m2] = this[m2];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l3) => {
        prev[l3] = {
          ...this.store.data[l3]
        };
        prev[l3] = Object.keys(prev[l3]).reduce((acc, n2) => {
          acc[n2] = {
            ...prev[l3][n2]
          };
          return acc;
        }, prev[l3]);
        return prev;
      }, {});
      clone.store = new ResourceStore(clonedData, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", (event, ...args) => {
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t2 = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace2 = instance.hasLoadedNamespace;
var loadNamespaces2 = instance.loadNamespaces;
var loadLanguages2 = instance.loadLanguages;

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/localeImport.js
var i18nInstance2 = instance.createInstance();
i18nInstance2.use(initReactI18next).init({
  resources: {
    en: {
      translation: en
    }
  },
  lng: "en",
  fallbackLng: "en",
  interpolation: {
    escapeValue: false
  },
  debug: false,
  react: {
    useSuspense: true
  }
});

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/BottomSheet/BottomSheet.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function BottomSheet({
  isShown,
  onClose,
  children,
  uiConfig
}) {
  const {
    borderRadiusType = "large"
  } = uiConfig;
  return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, {
    children: [(0, import_jsx_runtime3.jsx)("div", {
      className: cn2("w3a--bottom-sheet-bg w3a--fixed w3a--left-0 w3a--top-0 w3a--size-full w3a--transition-opacity w3a--duration-300", {
        "w3a--rounded-[30px]": borderRadiusType === "large",
        "w3a--rounded-2xl": borderRadiusType === "medium",
        "w3a--rounded-none": borderRadiusType === "small"
      }),
      onClick: onClose,
      "aria-hidden": "true",
      role: "button"
    }), (0, import_jsx_runtime3.jsxs)("div", {
      className: cn2(`w3a--fixed w3a--bottom-2 w3a--left-2 w3a--mx-auto w3a--flex w3a--w-[96%] w3a--flex-col 
      w3a--gap-y-2 w3a--border w3a--border-app-gray-100 w3a--bg-app-white w3a--p-4 w3a--shadow-lg w3a--transition-transform w3a--duration-500 
      w3a--ease-out dark:w3a--border-app-gray-600 dark:w3a--bg-app-dark-surface-main
      ${isShown ? "w3a--translate-y-0 w3a--delay-700" : "w3a--translate-y-full"}`, {
        "w3a--rounded-[30px]": borderRadiusType === "large",
        "w3a--rounded-2xl": borderRadiusType === "medium",
        "w3a--rounded-none": borderRadiusType === "small"
      }),
      children: [(0, import_jsx_runtime3.jsx)("div", {
        className: "w3a--absolute w3a--right-4 w3a--top-[16px] w3a--z-10 w3a--cursor-pointer",
        children: (0, import_jsx_runtime3.jsx)("svg", {
          width: "13",
          height: "13",
          viewBox: "0 0 13 13",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          onClick: onClose,
          className: "w3a--text-app-gray-500 hover:w3a--text-app-gray-900 dark:w3a--text-app-gray-200 dark:hover:w3a--text-app-white",
          children: (0, import_jsx_runtime3.jsx)("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M0.292787 1.29299C0.480314 1.10552 0.734622 1.0002 0.999786 1.0002C1.26495 1.0002 1.51926 1.10552 1.70679 1.29299L5.99979 5.58599L10.2928 1.29299C10.385 1.19748 10.4954 1.1213 10.6174 1.06889C10.7394 1.01648 10.8706 0.988893 11.0034 0.987739C11.1362 0.986585 11.2678 1.01189 11.3907 1.06217C11.5136 1.11245 11.6253 1.1867 11.7192 1.28059C11.8131 1.37449 11.8873 1.48614 11.9376 1.60904C11.9879 1.73193 12.0132 1.86361 12.012 1.99639C12.0109 2.12917 11.9833 2.26039 11.9309 2.38239C11.8785 2.5044 11.8023 2.61474 11.7068 2.70699L7.41379 6.99999L11.7068 11.293C11.8889 11.4816 11.9897 11.7342 11.9875 11.9964C11.9852 12.2586 11.88 12.5094 11.6946 12.6948C11.5092 12.8802 11.2584 12.9854 10.9962 12.9877C10.734 12.9899 10.4814 12.8891 10.2928 12.707L5.99979 8.41399L1.70679 12.707C1.51818 12.8891 1.26558 12.9899 1.00339 12.9877C0.741188 12.9854 0.490376 12.8802 0.304968 12.6948C0.11956 12.5094 0.0143906 12.2586 0.0121121 11.9964C0.00983372 11.7342 0.110629 11.4816 0.292787 11.293L4.58579 6.99999L0.292787 2.70699C0.105316 2.51946 0 2.26515 0 1.99999C0 1.73483 0.105316 1.48052 0.292787 1.29299V1.29299Z",
            fill: "currentColor"
          })
        })
      }), children]
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWallet.js
var import_react20 = __toESM(require_react());

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/context/AnalyticsContext.js
var import_react13 = __toESM(require_react());
var AnalyticsContext = (0, import_react13.createContext)({
  analytics: void 0
});

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWalletChainFilter/ConnectWalletChainFilter.js
var import_react14 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
function ConnectWalletChainFilter(props) {
  const {
    isDark,
    isLoading,
    selectedChain,
    setSelectedChain,
    chainNamespace
  } = props;
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const chains = (0, import_react14.useMemo)(() => {
    const chains2 = [{
      id: "all",
      name: "modal.allChains",
      icon: ""
    }];
    for (const chain of chainNamespace) {
      if (chain === CHAIN_NAMESPACES.EIP155 || chain === CHAIN_NAMESPACES.SOLANA) {
        chains2.push({
          id: chain,
          name: chain === CHAIN_NAMESPACES.EIP155 ? "EVM" : chain,
          icon: chain === CHAIN_NAMESPACES.EIP155 ? "ethereum" : chain
        });
      }
    }
    return chains2;
  }, [chainNamespace]);
  if (isLoading) {
    return (0, import_jsx_runtime4.jsx)("div", {
      className: "w3a--flex w3a--items-center w3a--justify-between w3a--gap-x-2",
      children: Array.from({
        length: chains.length
      }).map((_3, index) => (0, import_jsx_runtime4.jsx)("div", {
        className: "w3a--h-12 w3a--w-[100px] w3a--animate-pulse w3a--rounded-2xl w3a--bg-app-gray-200 dark:w3a--bg-app-gray-700"
      }, `chain-loader-${index}`))
    });
  }
  return (0, import_jsx_runtime4.jsx)("div", {
    className: "w3a--flex w3a--items-center w3a--justify-items-start w3a--gap-x-4",
    children: chains.map((chain) => (0, import_jsx_runtime4.jsxs)("button", {
      type: "button",
      className: cn2("w3a--flex w3a--w-[104px] w3a--items-center w3a--justify-center w3a--gap-x-1 w3a--text-xs w3a--font-medium w3a--px-4 w3a--py-3 w3a--text-app-gray-500 dark:w3a--text-app-gray-300 hover:w3a--bg-app-gray-200 dark:hover:w3a--bg-app-gray-700 w3a--h-12 w3a--rounded-2xl w3a--border w3a--border-transparent", {
        "w3a--bg-app-gray-100 dark:w3a--bg-app-gray-800 w3a--border-app-gray-200 dark:w3a--border-app-gray-700 w3a--text-app-gray-900 dark:w3a--text-app-white hover:!w3a--bg-app-gray-100 dark:hover:!w3a--bg-app-gray-800": selectedChain === chain.id
      }),
      onClick: () => setSelectedChain(chain.id),
      children: [chain.icon && (0, import_jsx_runtime4.jsx)("img", {
        src: getIcons(isDark ? `${chain.icon}-dark` : `${chain.icon}-light`),
        alt: chain.name,
        className: "w3a--size-5 w3a--object-contain"
      }), (0, import_jsx_runtime4.jsx)("span", {
        className: "first-letter:w3a--capitalize",
        children: t3(chain.name)
      })]
    }, chain.id))
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWalletHeader/ConnectWalletHeader.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
function ConnectWalletHeader(props) {
  const {
    onBackClick,
    currentPage,
    selectedButton
  } = props;
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const handleBack = () => {
    if (onBackClick) {
      onBackClick();
    }
  };
  return (0, import_jsx_runtime5.jsxs)("div", {
    className: "w3a--flex w3a--items-center w3a--justify-between",
    children: [(0, import_jsx_runtime5.jsx)("button", {
      type: "button",
      className: "w3a--z-20 w3a--flex w3a--size-5 w3a--cursor-pointer w3a--items-center w3a--justify-center w3a--rounded-full",
      onClick: handleBack,
      children: (0, import_jsx_runtime5.jsx)("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 20 20",
        className: "w3a--text-app-gray-500 hover:w3a--text-app-gray-900 dark:w3a--text-app-gray-200 dark:hover:w3a--text-app-white",
        children: (0, import_jsx_runtime5.jsx)("path", {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M9.707 16.707a1 1 0 0 1-1.414 0l-6-6a1 1 0 0 1 0-1.414l6-6a1 1 0 0 1 1.414 1.414L5.414 9H17a1 1 0 1 1 0 2H5.414l4.293 4.293a1 1 0 0 1 0 1.414",
          clipRule: "evenodd"
        })
      })
    }), (0, import_jsx_runtime5.jsx)("p", {
      className: "w3a--text-base w3a--font-medium w3a--text-app-gray-900 dark:w3a--text-app-white",
      children: currentPage === CONNECT_WALLET_PAGES.SELECTED_WALLET ? selectedButton === null || selectedButton === void 0 ? void 0 : selectedButton.displayName : currentPage === CONNECT_WALLET_PAGES.CONNECT_WALLET ? t3("modal.connectYourWallet") : currentPage
    }), (0, import_jsx_runtime5.jsx)("div", {
      className: "w3a--z-[-1] w3a--size-5"
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWalletList/ConnectWalletList.js
var import_react17 = __toESM(require_react());

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Button/Button.type.js
var BUTTON_TYPE = {
  SOCIAL: "social",
  WALLET: "wallet"
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Image/Image.js
var import_react15 = __toESM(require_react());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
function Image2(props) {
  const {
    id: id2 = "",
    isButton = false,
    imageData = "",
    height = "auto",
    width = "auto",
    extension = "svg",
    darkImageId = "",
    darkHoverImageId = "",
    imageId,
    hoverImageId,
    fallbackImageId
  } = props;
  const {
    isDark
  } = (0, import_react15.useContext)(ThemedContext);
  const imgName = (0, import_react15.useMemo)(() => isDark && darkImageId ? darkImageId : imageId, [isDark, darkImageId, imageId]);
  const hoverImgName = (0, import_react15.useMemo)(() => isDark && darkHoverImageId ? darkHoverImageId : hoverImageId, [isDark, darkHoverImageId, hoverImageId]);
  if (isButton) {
    if (imageData) {
      return (0, import_jsx_runtime6.jsx)("img", {
        id: id2,
        src: imageData,
        height,
        width,
        alt: hoverImageId,
        className: cn2("w3a--object-contain", `w3a--h-${height} w3a--w-${width}`)
      });
    }
    return (0, import_jsx_runtime6.jsx)("img", {
      id: id2,
      src: `https://images.web3auth.io/${hoverImgName}.${extension}`,
      height,
      width,
      alt: hoverImageId,
      className: cn2("w3a--rounded w3a--object-contain", `w3a--h-${height} w3a--w-${width}`)
    });
  }
  if (imageData) {
    return (0, import_jsx_runtime6.jsx)("img", {
      id: id2,
      src: imageData,
      height,
      width,
      alt: imageId,
      className: cn2("w3a--object-contain", `w3a--h-${height} w3a--w-${width}`),
      onError: ({
        currentTarget
      }) => {
        if (fallbackImageId) {
          const img = currentTarget;
          img.onerror = null;
          img.src = `https://images.web3auth.io/${fallbackImageId}.svg`;
        }
      }
    });
  }
  return (0, import_jsx_runtime6.jsx)("img", {
    id: id2,
    src: `https://images.web3auth.io/${imgName}.${extension}`,
    height,
    width,
    alt: imageId,
    className: cn2("w3a--rounded w3a--object-contain", `w3a--h-${height} w3a--w-${width}`),
    onError: ({
      currentTarget
    }) => {
      if (fallbackImageId) {
        const img = currentTarget;
        img.onerror = null;
        img.src = `https://images.web3auth.io/${fallbackImageId}.svg`;
      }
    }
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Button/ButtonSocial/ButtonSocial.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
function getProviderIcon(method, isDark, isPrimaryBtn) {
  const imageId = method === AUTH_CONNECTION.TWITTER ? `login-X${isDark ? "-light" : "-dark"}` : `login-${method}${isDark ? "-light" : "-dark"}`;
  const hoverId = method === AUTH_CONNECTION.APPLE || method === AUTH_CONNECTION.GITHUB || method === AUTH_CONNECTION.TWITTER ? imageId : `login-${method}-active`;
  if (isPrimaryBtn) {
    return (0, import_jsx_runtime7.jsx)(Image2, {
      width: "20",
      imageId: hoverId,
      hoverImageId: hoverId,
      isButton: true
    });
  }
  return (0, import_jsx_runtime7.jsx)(Image2, {
    width: "20",
    imageId,
    hoverImageId: hoverId
  });
}
function SocialLoginButton(props) {
  const {
    text,
    showIcon,
    showText,
    method,
    isDark,
    isPrimaryBtn,
    onClick,
    children,
    btnStyle,
    buttonRadius = "pill"
  } = props;
  return (0, import_jsx_runtime7.jsxs)("button", {
    type: "button",
    onClick: (e8) => onClick && onClick(e8),
    className: cn2("w3a--btn", btnStyle, {
      "w3a--rounded-full": buttonRadius === "pill",
      "w3a--rounded-lg": buttonRadius === "rounded",
      "w3a--rounded-none": buttonRadius === "square"
    }),
    children: [showIcon && getProviderIcon(method, isDark, isPrimaryBtn), showText && (0, import_jsx_runtime7.jsx)("p", {
      className: "w3a--text-sm w3a--font-normal w3a--text-app-gray-900 dark:w3a--text-app-white",
      children: text
    }), children]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Button/ButtonWallet/ButtonWallet.js
var import_classnames = __toESM(require_classnames());
var import_react16 = __toESM(require_react());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
function ButtonWallet(props) {
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const {
    deviceDetails,
    button,
    walletConnectUri,
    onClick,
    label,
    buttonRadius
  } = props;
  const isDark = (0, import_react16.useContext)(ThemedContext);
  const isLink = (0, import_react16.useMemo)(() => deviceDetails.platform !== "desktop" && button.href && button.hasWalletConnect && !button.isInstalled, [deviceDetails, button]);
  const href = (0, import_react16.useMemo)(() => button.href ? formatIOSMobile({
    uri: walletConnectUri,
    link: button.href
  }) : walletConnectUri, [button, walletConnectUri]);
  const handleBtnClick = () => {
    if (href && isLink) {
      window.open(href, "_blank");
    } else if (onClick) {
      onClick();
    }
  };
  return (0, import_jsx_runtime8.jsxs)("button", {
    type: "button",
    className: (0, import_classnames.default)(`w3a--group w3a--relative w3a--overflow-hidden w3a--flex w3a--w-full w3a--items-center w3a--justify-between w3a--bg-app-gray-50 w3a--p-3 hover:w3a--bg-app-gray-200 
        hover:w3a--text-app-gray-900 dark:w3a--bg-app-gray-800 dark:hover:w3a--bg-app-gray-600 active:w3a--scale-95 w3a--transition-all w3a--duration-150`, {
      "w3a--rounded-full": buttonRadius === "pill",
      "w3a--rounded-lg": buttonRadius === "rounded",
      "w3a--rounded-none": buttonRadius === "square"
    }),
    onClick: handleBtnClick,
    children: [(0, import_jsx_runtime8.jsxs)("div", {
      className: "w3a--flex w3a--items-center w3a--gap-x-2",
      children: [(0, import_jsx_runtime8.jsx)("figure", {
        className: "w3a--size-5",
        children: (0, import_jsx_runtime8.jsx)(Image2, {
          imageData: button.icon,
          imageId: `login-${button.name}`,
          hoverImageId: `login-${button.name}`,
          fallbackImageId: "wallet",
          height: "24",
          width: "24",
          isButton: true,
          extension: button.imgExtension || "webp"
        })
      }), (0, import_jsx_runtime8.jsx)("p", {
        className: "w3a--max-w-[180px] w3a--truncate w3a--text-base w3a--font-normal w3a--text-app-gray-700 dark:w3a--text-app-white",
        children: label
      })]
    }), button.hasInjectedWallet && (0, import_jsx_runtime8.jsx)("span", {
      className: "w3a--absolute w3a--right-4 w3a--top-1/2 w3a--flex w3a--w-auto -w3a--translate-y-1/2 w3a--items-center w3a--rounded-md w3a--bg-app-primary-100 w3a--px-2 w3a--py-1 w3a--text-xs w3a--font-medium w3a--text-app-primary-800 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-6 group-hover:w3a--opacity-0  dark:w3a--border dark:w3a--border-app-primary-400 dark:w3a--bg-transparent dark:w3a--text-app-primary-400",
      children: t3("modal.external.installed")
    }), (0, import_jsx_runtime8.jsx)("img", {
      id: "injected-wallet-arrow",
      className: "w3a--absolute w3a--right-4 w3a--top-1/2 -w3a--translate-x-10 -w3a--translate-y-1/2 w3a--opacity-0 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-0 group-hover:w3a--opacity-100",
      src: getIcons(isDark ? "chevron-right-light" : "chevron-right-dark"),
      alt: "arrow"
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Button/Button.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
function Button(props) {
  const {
    type,
    props: buttonProps
  } = props;
  const SocialButtonProps = buttonProps;
  const WalletButtonProps = buttonProps;
  const {
    text,
    showIcon,
    showText,
    method,
    isDark,
    isPrimaryBtn,
    onClick,
    children,
    btnStyle,
    buttonRadius
  } = SocialButtonProps;
  const {
    label,
    onClick: walletOnClick,
    button,
    deviceDetails,
    walletConnectUri,
    buttonRadius: walletButtonRadius
  } = WalletButtonProps;
  return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, {
    children: [type === BUTTON_TYPE.SOCIAL && (0, import_jsx_runtime9.jsx)(SocialLoginButton, {
      text,
      showIcon,
      showText,
      method,
      isDark,
      isPrimaryBtn,
      onClick,
      btnStyle,
      buttonRadius,
      children
    }), type === BUTTON_TYPE.WALLET && (0, import_jsx_runtime9.jsx)(ButtonWallet, {
      label,
      walletConnectUri,
      onClick: walletOnClick,
      button,
      deviceDetails,
      buttonRadius: walletButtonRadius
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWalletList/ConnectWalletList.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
function NoWalletsFound() {
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  return (0, import_jsx_runtime10.jsx)("div", {
    className: "w3a--flex w3a--w-full w3a--items-center w3a--justify-center w3a--py-6 w3a--text-center w3a--text-app-gray-400 dark:w3a--text-app-gray-500",
    children: t3("modal.external.no-wallets-found")
  });
}
function WalletsFound(props) {
  const {
    externalButtons,
    isLoading,
    handleWalletClick,
    deviceDetails,
    walletConnectUri,
    buttonRadius
  } = props;
  if (isLoading) {
    return (0, import_jsx_runtime10.jsx)("div", {
      className: "w3a--flex w3a--flex-col w3a--gap-y-2",
      children: Array.from({
        length: 6
      }).map((_3, index) => (0, import_jsx_runtime10.jsx)("div", {
        className: cn2("w3a--h-12 w3a--w-full w3a--animate-pulse w3a--rounded-2xl w3a--bg-app-gray-200 dark:w3a--bg-app-gray-700", {
          "w3a--rounded-full": buttonRadius === "pill",
          "w3a--rounded-lg": buttonRadius === "rounded",
          "w3a--rounded-none": buttonRadius === "square"
        })
      }, `loader-${index}`))
    });
  }
  return (0, import_jsx_runtime10.jsx)("div", {
    className: "w3a--flex w3a--flex-col w3a--gap-y-2 w3a--pr-1.5",
    children: externalButtons.map((button) => (0, import_jsx_runtime10.jsx)(Button, {
      type: BUTTON_TYPE.WALLET,
      props: {
        label: button.displayName,
        onClick: () => handleWalletClick(button),
        button,
        deviceDetails,
        walletConnectUri,
        buttonRadius
      }
    }, button.name))
  });
}
function MoreWalletsButton(props) {
  const {
    totalExternalWalletsCount,
    initialWalletCount,
    handleMoreWallets,
    isLoading,
    isDark,
    buttonRadius
  } = props;
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const onMoreWalletsClick = () => {
    if (handleMoreWallets) {
      handleMoreWallets();
    }
  };
  if (isLoading && initialWalletCount < totalExternalWalletsCount) {
    return (0, import_jsx_runtime10.jsx)("div", {
      className: cn2("w3a--h-12 w3a--w-full w3a--animate-pulse w3a--bg-app-gray-200 dark:w3a--bg-app-gray-700", {
        "w3a--rounded-full": buttonRadius === "pill",
        "w3a--rounded-lg": buttonRadius === "rounded",
        "w3a--rounded-none": buttonRadius === "square"
      })
    });
  }
  return (0, import_jsx_runtime10.jsxs)("button", {
    type: "button",
    className: cn2("w3a--flex w3a--items-center w3a--justify-start w3a--gap-x-2 w3a--bg-app-gray-50 w3a--p-3 hover:w3a--bg-app-gray-200 dark:w3a--bg-app-gray-800 dark:hover:w3a--bg-app-gray-600 active:w3a--scale-95 w3a--transition-all w3a--duration-150 w3a--mr-2.5", {
      "w3a--rounded-full": buttonRadius === "pill",
      "w3a--rounded-lg": buttonRadius === "rounded",
      "w3a--rounded-none": buttonRadius === "square"
    }),
    onClick: onMoreWalletsClick,
    children: [(0, import_jsx_runtime10.jsx)("img", {
      src: getIcons(isDark ? "view-dark" : "view-light"),
      alt: "view",
      height: "24",
      width: "24"
    }), (0, import_jsx_runtime10.jsx)("p", {
      className: "w3a--text-base w3a--font-normal w3a--text-app-gray-700 dark:w3a--text-app-white",
      children: t3("modal.connect-wallet.more-wallets")
    }), (0, import_jsx_runtime10.jsx)("span", {
      className: "w3a--inline-flex w3a--items-center w3a--rounded-full w3a--bg-app-primary-100 w3a--px-2 w3a--py-1 w3a--text-xs w3a--font-medium w3a--text-app-primary-800  dark:w3a--border dark:w3a--border-app-primary-400 dark:w3a--bg-transparent dark:w3a--text-app-primary-400",
      children: totalExternalWalletsCount - initialWalletCount
    })]
  });
}
function ConnectWalletList(props) {
  const {
    externalButtons,
    isLoading,
    totalExternalWalletsCount,
    initialWalletCount,
    handleWalletClick,
    handleMoreWallets,
    isDark,
    deviceDetails,
    walletConnectUri,
    buttonRadius
  } = props;
  const [showMoreWallets, setShowMoreWallets] = (0, import_react17.useState)(true);
  const onShowMoreWalletsClick = () => {
    setShowMoreWallets(false);
    handleMoreWallets();
  };
  return (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, {
    children: [(0, import_jsx_runtime10.jsx)("ul", {
      className: cn2("w3a--overflow-y-auto w3a--flex w3a--flex-col w3a--gap-y-2 w3a--h-[280px] w3a--social-container w3a--pr-2.5", {
        "w3a--h-[328px]": !showMoreWallets
      }),
      children: externalButtons.length === 0 ? (0, import_jsx_runtime10.jsx)(NoWalletsFound, {}) : (0, import_jsx_runtime10.jsx)(WalletsFound, {
        externalButtons,
        isLoading,
        handleWalletClick,
        deviceDetails,
        walletConnectUri,
        buttonRadius
      })
    }), showMoreWallets && totalExternalWalletsCount > 15 && !isLoading && initialWalletCount < totalExternalWalletsCount && (0, import_jsx_runtime10.jsx)(MoreWalletsButton, {
      totalExternalWalletsCount,
      initialWalletCount,
      handleMoreWallets: onShowMoreWalletsClick,
      isLoading,
      isDark,
      buttonRadius
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWalletQrCode/ConnectWalletQrCode.js
var import_react18 = __toESM(require_react());
var import_react_qrcode_logo = __toESM(require_dist2());
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
function ConnectWalletQrCode(props) {
  var _getComputedStyle;
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const {
    bodyState,
    setBodyState
  } = (0, import_react18.useContext)(RootContext);
  const {
    qrCodeValue,
    isDark,
    selectedButton,
    logoImage,
    primaryColor
  } = props;
  const isDesktop = (0, import_react18.useMemo)(() => {
    if (typeof window === "undefined") return false;
    const browser = bowser_default.getParser(window.navigator.userAgent);
    return browser.getPlatformType() === "desktop";
  }, []);
  const root = document.documentElement;
  const whiteColor = "#FFFFFF";
  const blackColor = "#000000";
  const modalColor = ((_getComputedStyle = getComputedStyle(root)) === null || _getComputedStyle === void 0 || (_getComputedStyle = _getComputedStyle.getPropertyValue("--app-gray-800")) === null || _getComputedStyle === void 0 ? void 0 : _getComputedStyle.trim()) || "#1f2a37";
  const qrColor = primaryColor && primaryColor.toLowerCase() === "#ffffff" ? "#000000" : primaryColor;
  return (0, import_jsx_runtime11.jsxs)("div", {
    className: "w3a--contents",
    children: [qrCodeValue ? (0, import_jsx_runtime11.jsxs)("div", {
      className: "w3a--flex w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-4 w3a--rounded-2xl w3a--border w3a--border-app-gray-200 w3a--p-4 dark:w3a--border-app-gray-700",
      children: [(0, import_jsx_runtime11.jsx)("div", {
        className: "w3a--relative w3a--flex w3a--size-[300px] w3a--items-center w3a--justify-center w3a--rounded-2xl",
        children: (0, import_jsx_runtime11.jsx)(import_react_qrcode_logo.QRCode, {
          size: isDesktop ? 300 : 260,
          eyeRadius: 5,
          qrStyle: "dots",
          removeQrCodeBehindLogo: true,
          logoImage: logoImage || WALLET_CONNECT_LOGO,
          value: qrCodeValue,
          logoHeight: 32,
          logoWidth: 32,
          logoPadding: 10,
          eyeColor: isDark ? whiteColor : qrColor,
          bgColor: isDark ? modalColor : whiteColor,
          fgColor: isDark ? whiteColor : blackColor
        })
      }), (0, import_jsx_runtime11.jsx)("p", {
        className: "w3a--text-center w3a--text-sm w3a--font-normal w3a--text-app-gray-500 dark:w3a--text-app-gray-300",
        children: t3("modal.external.walletconnect-copy")
      })]
    }) : (0, import_jsx_runtime11.jsx)("div", {
      className: "w3a--mx-auto w3a--flex w3a--size-[300px] w3a--animate-pulse w3a--items-center w3a--justify-center w3a--rounded-lg w3a--bg-app-gray-200 w3a--p-2 dark:w3a--bg-app-gray-700",
      children: (0, import_jsx_runtime11.jsx)(Image2, {
        imageId: `login-${selectedButton.name}`,
        hoverImageId: `login-${selectedButton.name}`,
        fallbackImageId: "wallet",
        height: "30",
        width: "30",
        isButton: true,
        extension: selectedButton.imgExtension
      })
    }), (0, import_jsx_runtime11.jsxs)("div", {
      className: "w3a--flex w3a--w-full w3a--items-center w3a--justify-between w3a--rounded-2xl w3a--bg-app-gray-50  w3a--px-4 w3a--py-2 w3a--text-app-gray-900 dark:w3a--bg-app-gray-800 dark:w3a--text-app-white",
      children: [(0, import_jsx_runtime11.jsxs)("p", {
        className: "w3a--text-sm w3a--text-app-gray-900 dark:w3a--text-app-white",
        children: [t3("modal.external.dont-have"), " ", (0, import_jsx_runtime11.jsx)("span", {
          children: selectedButton === null || selectedButton === void 0 ? void 0 : selectedButton.displayName
        }), "?"]
      }), (0, import_jsx_runtime11.jsx)("button", {
        type: "button",
        className: "w3a--appearance-none w3a--rounded-full w3a--border w3a--border-app-gray-200 w3a--bg-transparent w3a--px-5 w3a--py-2 w3a--text-base w3a--font-normal w3a--text-app-gray-700 w3a--transition-all w3a--duration-150 hover:w3a--border-transparent hover:w3a--shadow-light active:w3a--scale-95 dark:w3a--border-app-gray-700 dark:w3a--text-app-gray-300 dark:hover:w3a--border-transparent dark:hover:w3a--shadow-dark",
        onClick: () => {
          setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
            installLinks: {
              show: true,
              wallet: selectedButton
            }
          }));
        },
        children: t3("modal.external.get-wallet")
      })]
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWalletSearch/ConnectWalletSearch.js
var import_react19 = __toESM(require_react());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
function ConnectWalletSearch(props) {
  const {
    totalExternalWalletCount,
    isLoading,
    walletSearch,
    handleWalletSearch,
    buttonRadius
  } = props;
  const [isInputFocused, setIsInputFocused] = (0, import_react19.useState)(false);
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const onWalletSearch = (e8) => {
    handleWalletSearch(e8);
    setIsInputFocused(true);
  };
  return (0, import_jsx_runtime12.jsx)("input", {
    type: "text",
    value: walletSearch,
    onInput: onWalletSearch,
    onFocus: (e8) => {
      e8.target.placeholder = "";
      setIsInputFocused(true);
    },
    onBlur: (e8) => {
      e8.target.placeholder = t3("modal.external.search-wallet", {
        count: totalExternalWalletCount
      });
      setIsInputFocused(false);
    },
    placeholder: isLoading ? t3("modal.external.search-wallet-loading") : t3("modal.external.search-wallet", {
      count: totalExternalWalletCount
    }),
    disabled: isLoading,
    className: cn2("w3a--input w3a--appearance-none w3a--outline-none active:w3a--outline-none focus:w3a--outline-none w3a--bg-transparent placeholder:w3a--text-app-gray-400 dark:placeholder:w3a--text-app-gray-500 w3a--text-app-gray-900 dark:w3a--text-app-white", isInputFocused && "!w3a--border-app-primary-600", {
      "w3a--rounded-full": buttonRadius === "pill",
      "w3a--rounded-lg": buttonRadius === "rounded",
      "w3a--rounded-none": buttonRadius === "square"
    })
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWallet.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
function ConnectWallet(props) {
  var _selectedButton$walle;
  const {
    isDark,
    config,
    walletConnectUri,
    metamaskConnectUri,
    walletRegistry,
    allExternalButtons,
    customConnectorButtons,
    connectorVisibilityMap,
    deviceDetails,
    buttonRadius = "pill",
    chainNamespace,
    onBackClick,
    handleExternalWalletClick,
    handleWalletDetailsHeight
  } = props;
  const {
    bodyState,
    setBodyState
  } = (0, import_react20.useContext)(RootContext);
  const {
    analytics
  } = (0, import_react20.useContext)(AnalyticsContext);
  const [currentPage, setCurrentPage] = (0, import_react20.useState)(CONNECT_WALLET_PAGES.CONNECT_WALLET);
  const [selectedWallet, setSelectedWallet] = (0, import_react20.useState)(false);
  const [isLoading] = (0, import_react20.useState)(false);
  const [selectedButton, setSelectedButton] = (0, import_react20.useState)(null);
  const [walletSearch, setWalletSearch] = (0, import_react20.useState)("");
  const [selectedChain, setSelectedChain] = (0, import_react20.useState)("all");
  const [isShowAllWallets, setIsShowAllWallets] = (0, import_react20.useState)(false);
  const handleBack = () => {
    if (!selectedWallet && currentPage === CONNECT_WALLET_PAGES.CONNECT_WALLET && onBackClick) {
      onBackClick(false);
      return;
    }
    if (selectedWallet) {
      setCurrentPage(CONNECT_WALLET_PAGES.CONNECT_WALLET);
      setSelectedWallet(false);
      handleWalletDetailsHeight();
    }
  };
  const walletDiscoverySupported = (0, import_react20.useMemo)(() => {
    const supported = walletRegistry && Object.keys(walletRegistry.default || {}).length > 0 && Object.keys(walletRegistry.others || {}).length > 0;
    return supported;
  }, [walletRegistry]);
  const allUniqueButtons = (0, import_react20.useMemo)(() => {
    const uniqueButtonSet = /* @__PURE__ */ new Set();
    return customConnectorButtons.concat(allExternalButtons).filter((button) => {
      if (uniqueButtonSet.has(button.name)) return false;
      uniqueButtonSet.add(button.name);
      return true;
    });
  }, [allExternalButtons, customConnectorButtons]);
  const defaultButtonKeys = (0, import_react20.useMemo)(() => new Set(Object.keys(walletRegistry.default)), [walletRegistry]);
  const defaultButtons = (0, import_react20.useMemo)(() => {
    const buttons = [...allExternalButtons.filter((button) => button.hasInjectedWallet && defaultButtonKeys.has(button.name)), ...customConnectorButtons, ...allExternalButtons.filter((button) => !button.hasInjectedWallet && defaultButtonKeys.has(button.name))].sort((a, b3) => {
      if (a.name === WALLET_CONNECTORS.METAMASK && b3.name === WALLET_CONNECTORS.METAMASK) {
        if (a.hasInjectedWallet) return -1;
        if (b3.hasInjectedWallet) return 1;
        if (a.isInstalled) return -1;
        if (b3.isInstalled) return 1;
        return 0;
      }
      if (a.name === WALLET_CONNECTORS.METAMASK) return -1;
      if (b3.name === WALLET_CONNECTORS.METAMASK) return 1;
      return 0;
    });
    const buttonSet = /* @__PURE__ */ new Set();
    return buttons.filter((button) => {
      if (buttonSet.has(button.name)) return false;
      buttonSet.add(button.name);
      return true;
    }).filter((button) => {
      var _button$chainNamespac;
      return selectedChain === "all" || ((_button$chainNamespac = button.chainNamespaces) === null || _button$chainNamespac === void 0 ? void 0 : _button$chainNamespac.includes(selectedChain));
    });
  }, [allExternalButtons, customConnectorButtons, defaultButtonKeys, selectedChain]);
  const installedWalletButtons = (0, import_react20.useMemo)(() => {
    const visibilityMap = connectorVisibilityMap;
    return Object.keys(config).reduce((acc, localConnector) => {
      if (localConnector !== WALLET_CONNECTORS.WALLET_CONNECT_V2 && visibilityMap[localConnector]) {
        acc.push({
          name: localConnector,
          displayName: config[localConnector].label || localConnector,
          hasInjectedWallet: config[localConnector].isInjected,
          hasWalletConnect: false,
          hasInstallLinks: false
        });
      }
      return acc;
    }, []);
  }, [connectorVisibilityMap, config]);
  const handleWalletSearch = (e8) => {
    const searchValue = e8.target.value;
    setWalletSearch(searchValue);
  };
  const handleChainFilterChange = (chain) => {
    setSelectedChain(chain);
    setIsShowAllWallets(false);
  };
  const filteredButtons = (0, import_react20.useMemo)(() => {
    if (walletDiscoverySupported) {
      return [...allUniqueButtons.filter((button) => button.hasInjectedWallet), ...allUniqueButtons.filter((button) => !button.hasInjectedWallet)].sort((a, _3) => a.name === WALLET_CONNECTORS.METAMASK ? -1 : 1).filter((button) => selectedChain === "all" || button.chainNamespaces.includes(selectedChain)).filter((button) => button.name.toLowerCase().includes(walletSearch.toLowerCase()));
    }
    return installedWalletButtons;
  }, [walletDiscoverySupported, installedWalletButtons, walletSearch, allUniqueButtons, selectedChain]);
  const externalButtons = (0, import_react20.useMemo)(() => {
    if (walletDiscoverySupported && !walletSearch && !isShowAllWallets) {
      return defaultButtons;
    }
    return filteredButtons;
  }, [walletDiscoverySupported, walletSearch, filteredButtons, defaultButtons, isShowAllWallets]);
  const totalExternalWalletsCount = (0, import_react20.useMemo)(() => filteredButtons.length, [filteredButtons]);
  const initialWalletCount = (0, import_react20.useMemo)(() => {
    if (isShowAllWallets) return totalExternalWalletsCount;
    return walletDiscoverySupported ? defaultButtons.length : installedWalletButtons.length;
  }, [walletDiscoverySupported, defaultButtons, installedWalletButtons, isShowAllWallets, totalExternalWalletsCount]);
  const handleWalletClick = (button) => {
    analytics === null || analytics === void 0 || analytics.track(ANALYTICS_EVENTS.EXTERNAL_WALLET_SELECTED, {
      connector: button.isInstalled ? button.name : button.hasWalletConnect ? WALLET_CONNECTORS.WALLET_CONNECT_V2 : "",
      wallet_name: button.displayName,
      is_installed: button.isInstalled,
      is_injected: button.hasInjectedWallet,
      chain_namespaces: button.chainNamespaces,
      has_wallet_connect: button.hasWalletConnect,
      has_install_links: button.hasInstallLinks,
      has_wallet_registry_item: !!button.walletRegistryItem,
      total_external_wallets: allUniqueButtons.length
    });
    if (button.isInstalled) {
      var _button$chainNamespac2;
      if (button.name === WALLET_CONNECTORS.METAMASK && !button.hasInjectedWallet && deviceDetails.platform === "desktop") {
        handleExternalWalletClick({
          connector: button.name
        });
        setSelectedButton(button);
        setSelectedWallet(true);
        setCurrentPage(CONNECT_WALLET_PAGES.SELECTED_WALLET);
        handleWalletDetailsHeight();
        return;
      }
      if (((_button$chainNamespac2 = button.chainNamespaces) === null || _button$chainNamespac2 === void 0 ? void 0 : _button$chainNamespac2.length) > 1) {
        setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
          multiChainSelector: {
            show: true,
            wallet: button
          }
        }));
        return;
      }
      handleExternalWalletClick({
        connector: button.name
      });
      return;
    } else {
      if (button.hasWalletConnect) {
        setSelectedButton(button);
        setSelectedWallet(true);
        setCurrentPage(CONNECT_WALLET_PAGES.SELECTED_WALLET);
        handleWalletDetailsHeight();
      } else {
        setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
          installLinks: {
            show: true,
            wallet: button
          }
        }));
      }
    }
  };
  const handleMoreWallets = () => {
    setIsShowAllWallets(true);
  };
  const qrCodeValue = (0, import_react20.useMemo)(() => {
    if (!selectedWallet) return null;
    if (selectedButton.name === WALLET_CONNECTORS.METAMASK && !selectedButton.hasInjectedWallet) {
      return metamaskConnectUri;
    }
    return walletConnectUri;
  }, [metamaskConnectUri, selectedButton, selectedWallet, walletConnectUri]);
  return (0, import_jsx_runtime13.jsxs)("div", {
    className: "w3a--relative w3a--flex w3a--flex-1 w3a--flex-col w3a--gap-y-4",
    children: [(0, import_jsx_runtime13.jsx)(ConnectWalletHeader, {
      onBackClick: handleBack,
      currentPage,
      selectedButton
    }), selectedWallet ? (0, import_jsx_runtime13.jsx)(ConnectWalletQrCode, {
      qrCodeValue,
      isDark,
      selectedButton,
      primaryColor: (_selectedButton$walle = selectedButton.walletRegistryItem) === null || _selectedButton$walle === void 0 ? void 0 : _selectedButton$walle.primaryColor,
      logoImage: `https://images.web3auth.io/login-${selectedButton.name}.${selectedButton.imgExtension}`
    }) : (0, import_jsx_runtime13.jsxs)("div", {
      className: "w3a--flex w3a--flex-col w3a--gap-y-2",
      children: [(0, import_jsx_runtime13.jsx)(ConnectWalletChainFilter, {
        isDark,
        isLoading,
        selectedChain,
        setSelectedChain: handleChainFilterChange,
        chainNamespace
      }), (0, import_jsx_runtime13.jsx)(ConnectWalletSearch, {
        totalExternalWalletCount: totalExternalWalletsCount,
        isLoading,
        walletSearch,
        handleWalletSearch,
        buttonRadius
      }), (0, import_jsx_runtime13.jsx)(ConnectWalletList, {
        externalButtons,
        isLoading,
        totalExternalWalletsCount,
        initialWalletCount,
        handleWalletClick,
        handleMoreWallets,
        isDark,
        deviceDetails,
        walletConnectUri,
        buttonRadius
      })]
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/ConnectWallet/ConnectWalletChainNamespaceSelect/ConnectWalletChainNamespaceSelect.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var ConnectWalletChainNamespaceSelect = (props) => {
  const {
    isDark,
    wallet,
    handleExternalWalletClick
  } = props;
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const chainNamespaces = wallet.chainNamespaces.sort().map((chainNamespace) => {
    const imageId = chainNamespace === "eip155" ? "evm" : chainNamespace;
    const displayName = chainNamespace === "eip155" ? "EVM" : chainNamespace;
    return {
      chainNamespace,
      displayName,
      imageId: `chain-${imageId}`
    };
  });
  return (0, import_jsx_runtime14.jsxs)("div", {
    children: [(0, import_jsx_runtime14.jsx)("div", {
      className: "w3a--flex w3a--items-center w3a--justify-center",
      children: (0, import_jsx_runtime14.jsx)("p", {
        className: "w3a--text-base w3a--font-medium w3a--text-app-gray-900 dark:w3a--text-app-white",
        children: t3("modal.external.select-chain")
      })
    }), (0, import_jsx_runtime14.jsx)("div", {
      className: "w3a--my-6 w3a--flex w3a--justify-center",
      children: (0, import_jsx_runtime14.jsx)(Image2, {
        imageId: `login-${wallet.name}`,
        hoverImageId: `login-${wallet.name}`,
        fallbackImageId: "wallet",
        height: "100",
        width: "100",
        isButton: true,
        extension: wallet.imgExtension
      })
    }), (0, import_jsx_runtime14.jsx)("p", {
      className: "w3a--my-6 w3a--text-center w3a--text-sm w3a--text-app-gray-500",
      children: t3("modal.external.select-chain-description", {
        wallet: wallet.displayName
      })
    }), (0, import_jsx_runtime14.jsx)("ul", {
      className: "w3a--flex w3a--flex-col w3a--gap-3",
      children: chainNamespaces.map(({
        chainNamespace,
        displayName,
        imageId
      }) => (0, import_jsx_runtime14.jsx)("li", {
        children: (0, import_jsx_runtime14.jsxs)("button", {
          type: "button",
          className: "w3a--btn w3a--group w3a--relative w3a--h-11 w3a--w-full w3a--items-center !w3a--justify-between w3a--overflow-hidden w3a--rounded-full",
          onClick: () => handleExternalWalletClick({
            connector: wallet.name,
            chainNamespace
          }),
          children: [(0, import_jsx_runtime14.jsxs)("div", {
            className: "w3a--flex w3a--items-center",
            children: [(0, import_jsx_runtime14.jsx)(Image2, {
              imageId,
              hoverImageId: imageId,
              fallbackImageId: "wallet",
              height: "24",
              width: "24",
              isButton: true,
              extension: "svg"
            }), (0, import_jsx_runtime14.jsx)("p", {
              className: "w3a--ml-2 w3a--text-left w3a--text-sm first-letter:w3a--capitalize",
              children: displayName
            })]
          }), (0, import_jsx_runtime14.jsx)("img", {
            id: "chain-namespace-arrow",
            className: "w3a--absolute w3a--right-4 w3a--top-1/2 -w3a--translate-x-6 -w3a--translate-y-1/2 w3a--opacity-0 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-0 group-hover:w3a--opacity-100",
            src: getIcons(isDark ? "chevron-right-dark" : "chevron-right-light"),
            alt: "arrow"
          })]
        })
      }, chainNamespace))
    })]
  });
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Footer/Footer.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
function Footer({
  privacyPolicy,
  termsOfService
}) {
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  return (0, import_jsx_runtime15.jsxs)("div", {
    className: "w3a--mx-auto w3a--mt-auto w3a--flex w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-4 w3a--pt-5",
    children: [(privacyPolicy || termsOfService) && (0, import_jsx_runtime15.jsxs)("p", {
      className: "w3a--mx-auto w3a--w-4/5 w3a--text-center w3a--text-xs w3a--text-app-gray-500 dark:w3a--text-app-gray-400",
      children: [t3("modal.footer.by-signing-in"), " ", termsOfService && (0, import_jsx_runtime15.jsxs)("a", {
        href: termsOfService,
        className: "w3a--text-app-primary-600 dark:w3a--text-app-primary-500",
        children: [t3("modal.footer.terms-of-service"), " "]
      }), privacyPolicy && (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, {
        children: [t3("modal.footer.and"), " ", (0, import_jsx_runtime15.jsx)("a", {
          href: privacyPolicy,
          className: "w3a--text-app-primary-600 dark:w3a--text-app-primary-500",
          children: t3("modal.footer.privacy-policy")
        })]
      })]
    }), (0, import_jsx_runtime15.jsxs)("div", {
      className: "w3a--flex w3a--items-center w3a--justify-center w3a--gap-2",
      children: [(0, import_jsx_runtime15.jsx)("img", {
        height: "36",
        src: "https://images.web3auth.io/metamask-footer-logo-light.svg",
        alt: "Web3Auth Logo Light",
        className: "w3a--block w3a--h-9 dark:w3a--hidden"
      }), (0, import_jsx_runtime15.jsx)("img", {
        height: "36",
        src: "https://images.web3auth.io/metamask-footer-logo-dark.svg",
        alt: "Web3Auth Logo Dark",
        className: "w3a--hidden w3a--h-9 dark:w3a--block"
      })]
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Loader/Loader.js
var import_react21 = __toESM(require_react());

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/PulseLoader/PulseLoader.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var PulseLoader = () => {
  return (0, import_jsx_runtime16.jsxs)("div", {
    className: "w3a--flex w3a--items-center w3a--justify-center w3a--gap-x-2",
    children: [(0, import_jsx_runtime16.jsx)("div", {
      className: "w3a--size-3 w3a--animate-pulse w3a--rounded-full w3a--bg-app-gray-500 dark:w3a--bg-app-gray-200"
    }), (0, import_jsx_runtime16.jsx)("div", {
      className: "w3a--size-3 w3a--animate-pulse w3a--rounded-full w3a--bg-app-gray-400 dark:w3a--bg-app-gray-400"
    }), (0, import_jsx_runtime16.jsx)("div", {
      className: "w3a--size-3 w3a--animate-pulse w3a--rounded-full w3a--bg-app-gray-200 dark:w3a--bg-app-gray-600"
    })]
  });
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Loader/Loader.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
function ConnectingStatus(props) {
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const {
    connector,
    appLogo,
    connectorName
  } = props;
  const providerIcon = (0, import_react21.useMemo)(() => connector === "twitter" ? (0, import_jsx_runtime17.jsx)(Image2, {
    imageId: "login-x-dark"
  }) : (0, import_jsx_runtime17.jsx)(Image2, {
    imageId: `login-${connector}`,
    height: "40",
    width: "40"
  }), [connector]);
  return (0, import_jsx_runtime17.jsxs)("div", {
    className: "w3a--flex w3a--h-full w3a--flex-1 w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-4",
    children: [(0, import_jsx_runtime17.jsxs)("div", {
      className: "w3a--flex w3a--items-center w3a--justify-center w3a--gap-x-6",
      children: [(0, import_jsx_runtime17.jsx)("figure", {
        className: "w3a--flex w3a--size-10 w3a--items-center w3a--justify-center w3a--overflow-hidden",
        children: (0, import_jsx_runtime17.jsx)("img", {
          src: appLogo,
          alt: "",
          className: "w3a--size-full w3a--object-contain"
        })
      }), (0, import_jsx_runtime17.jsx)(PulseLoader, {}), providerIcon]
    }), (0, import_jsx_runtime17.jsxs)("div", {
      className: "w3a--flex w3a--flex-col w3a--gap-y-1",
      children: [(0, import_jsx_runtime17.jsx)("div", {
        className: "w3a--text-center w3a--text-sm w3a--text-app-gray-500 dark:w3a--text-app-gray-400",
        children: t3("modal.adapter-loader.message1", {
          adapter: connectorName
        })
      }), (0, import_jsx_runtime17.jsx)("div", {
        className: "w3a--text-center w3a--text-sm w3a--text-app-gray-500 dark:w3a--text-app-gray-400",
        children: t3("modal.adapter-loader.message2", {
          adapter: connectorName
        })
      })]
    })]
  });
}
function ConnectedStatus(props) {
  const {
    message
  } = props;
  return (0, import_jsx_runtime17.jsxs)("div", {
    className: "w3a--flex w3a--flex-col w3a--items-center w3a--gap-y-2",
    children: [(0, import_jsx_runtime17.jsx)("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 20 20",
      className: "w3a--connected-logo",
      children: (0, import_jsx_runtime17.jsx)("path", {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M6.267 3.455a3.07 3.07 0 0 0 1.745-.723 3.066 3.066 0 0 1 3.976 0 3.07 3.07 0 0 0 1.745.723 3.066 3.066 0 0 1 2.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 0 1 0 3.976 3.07 3.07 0 0 0-.723 1.745 3.066 3.066 0 0 1-2.812 2.812 3.07 3.07 0 0 0-1.745.723 3.066 3.066 0 0 1-3.976 0 3.07 3.07 0 0 0-1.745-.723 3.066 3.066 0 0 1-2.812-2.812 3.07 3.07 0 0 0-.723-1.745 3.066 3.066 0 0 1 0-3.976 3.07 3.07 0 0 0 .723-1.745 3.066 3.066 0 0 1 2.812-2.812m7.44 5.252a1 1 0 0 0-1.414-1.414L9 10.586 7.707 9.293a1 1 0 0 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0z",
        clipRule: "evenodd"
      })
    }), (0, import_jsx_runtime17.jsx)("p", {
      className: "w3a--text-center w3a--text-sm w3a--text-app-gray-500 dark:w3a--text-app-gray-400",
      children: message
    })]
  });
}
function ErroredStatus(props) {
  const {
    message
  } = props;
  return (0, import_jsx_runtime17.jsxs)("div", {
    className: "w3a--flex w3a--flex-col w3a--items-center w3a--gap-y-2",
    children: [(0, import_jsx_runtime17.jsx)("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 20 20",
      className: "w3a--error-logo",
      children: (0, import_jsx_runtime17.jsx)("path", {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M18 10a8 8 0 1 1-16.001 0A8 8 0 0 1 18 10m-7 4a1 1 0 1 1-2 0 1 1 0 0 1 2 0m-1-9a1 1 0 0 0-1 1v4a1 1 0 1 0 2 0V6a1 1 0 0 0-1-1",
        clipRule: "evenodd"
      })
    }), (0, import_jsx_runtime17.jsx)("p", {
      className: "w3a--text-center w3a--text-sm w3a--text-app-gray-500 dark:w3a--text-app-gray-400",
      children: message
    })]
  });
}
function Loader(props) {
  const {
    connector,
    connectorName,
    modalStatus,
    onClose,
    appLogo,
    message
  } = props;
  (0, import_react21.useEffect)(() => {
    if (modalStatus === MODAL_STATUS.CONNECTED) {
      setTimeout(() => {
        onClose();
      }, 1e3);
    }
  }, [modalStatus, onClose]);
  return (0, import_jsx_runtime17.jsxs)("div", {
    className: "w3a--flex w3a--h-full w3a--flex-1 w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-4",
    children: [modalStatus === MODAL_STATUS.CONNECTING && (0, import_jsx_runtime17.jsx)(ConnectingStatus, {
      connector,
      connectorName,
      appLogo
    }), modalStatus === MODAL_STATUS.CONNECTED && (0, import_jsx_runtime17.jsx)(ConnectedStatus, {
      message
    }), modalStatus === MODAL_STATUS.ERRORED && (0, import_jsx_runtime17.jsx)(ErroredStatus, {
      message
    })]
  });
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e8) {
  if (void 0 === e8) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e8;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t3, e8) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e9) {
    return t4.__proto__ = e9, t4;
  }, _setPrototypeOf(t3, e8);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t3, o) {
  t3.prototype = Object.create(o.prototype), t3.prototype.constructor = t3, _setPrototypeOf(t3, o);
}

// node_modules/@hcaptcha/react-hcaptcha/dist/esm/index.js
var React = __toESM(require_react());

// node_modules/@hcaptcha/loader/dist/index.mjs
var K2 = Object.defineProperty;
var Y2 = Object.defineProperties;
var V2 = Object.getOwnPropertyDescriptors;
var y2 = Object.getOwnPropertySymbols;
var P2 = Object.prototype.hasOwnProperty;
var D2 = Object.prototype.propertyIsEnumerable;
var I2 = (t3, e8, r3) => e8 in t3 ? K2(t3, e8, { enumerable: true, configurable: true, writable: true, value: r3 }) : t3[e8] = r3;
var d2 = (t3, e8) => {
  for (var r3 in e8 || (e8 = {})) P2.call(e8, r3) && I2(t3, r3, e8[r3]);
  if (y2) for (var r3 of y2(e8)) D2.call(e8, r3) && I2(t3, r3, e8[r3]);
  return t3;
};
var O2 = (t3, e8) => Y2(t3, V2(e8));
var M2 = (t3, e8) => {
  var r3 = {};
  for (var n2 in t3) P2.call(t3, n2) && e8.indexOf(n2) < 0 && (r3[n2] = t3[n2]);
  if (t3 != null && y2) for (var n2 of y2(t3)) e8.indexOf(n2) < 0 && D2.call(t3, n2) && (r3[n2] = t3[n2]);
  return r3;
};
var l2 = (t3, e8, r3) => (I2(t3, typeof e8 != "symbol" ? e8 + "" : e8, r3), r3);
var x2 = (t3, e8, r3) => new Promise((n2, s) => {
  var a = (c2) => {
    try {
      o(r3.next(c2));
    } catch (i2) {
      s(i2);
    }
  }, u2 = (c2) => {
    try {
      o(r3.throw(c2));
    } catch (i2) {
      s(i2);
    }
  }, o = (c2) => c2.done ? n2(c2.value) : Promise.resolve(c2.value).then(a, u2);
  o((r3 = r3.apply(t3, e8)).next());
});
var L2 = "hCaptcha-script";
var b2 = "hCaptchaOnLoad";
var _2 = "script-error";
var g2 = "@hCaptcha/loader";
function U2(t3) {
  return Object.entries(t3).filter(([, e8]) => e8 || e8 === false).map(([e8, r3]) => `${encodeURIComponent(e8)}=${encodeURIComponent(String(r3))}`).join("&");
}
function R2(t3) {
  let e8 = t3 && t3.ownerDocument || document, r3 = e8.defaultView || e8.parentWindow || window;
  return { document: e8, window: r3 };
}
function S2(t3) {
  return t3 || document.head;
}
function F2(t3) {
  var e8;
  t3.setTag("source", g2), t3.setTag("url", document.URL), t3.setContext("os", { UA: navigator.userAgent }), t3.setContext("browser", d2({}, z2())), t3.setContext("device", O2(d2({}, J2()), { screen_width_pixels: screen.width, screen_height_pixels: screen.height, language: navigator.language, orientation: ((e8 = screen.orientation) == null ? void 0 : e8.type) || "Unknown", processor_count: navigator.hardwareConcurrency, platform: navigator.platform }));
}
function z2() {
  var n2, s, a, u2, o, c2;
  let t3 = navigator.userAgent, e8, r3;
  return t3.indexOf("Firefox") !== -1 ? (e8 = "Firefox", r3 = (n2 = t3.match(/Firefox\/([\d.]+)/)) == null ? void 0 : n2[1]) : t3.indexOf("Edg") !== -1 ? (e8 = "Microsoft Edge", r3 = (s = t3.match(/Edg\/([\d.]+)/)) == null ? void 0 : s[1]) : t3.indexOf("Chrome") !== -1 && t3.indexOf("Safari") !== -1 ? (e8 = "Chrome", r3 = (a = t3.match(/Chrome\/([\d.]+)/)) == null ? void 0 : a[1]) : t3.indexOf("Safari") !== -1 && t3.indexOf("Chrome") === -1 ? (e8 = "Safari", r3 = (u2 = t3.match(/Version\/([\d.]+)/)) == null ? void 0 : u2[1]) : t3.indexOf("Opera") !== -1 || t3.indexOf("OPR") !== -1 ? (e8 = "Opera", r3 = (o = t3.match(/(Opera|OPR)\/([\d.]+)/)) == null ? void 0 : o[2]) : t3.indexOf("MSIE") !== -1 || t3.indexOf("Trident") !== -1 ? (e8 = "Internet Explorer", r3 = (c2 = t3.match(/(MSIE |rv:)([\d.]+)/)) == null ? void 0 : c2[2]) : (e8 = "Unknown", r3 = "Unknown"), { name: e8, version: r3 };
}
function J2() {
  let t3 = navigator.userAgent, e8;
  t3.indexOf("Win") !== -1 ? e8 = "Windows" : t3.indexOf("Mac") !== -1 ? e8 = "Mac" : t3.indexOf("Linux") !== -1 ? e8 = "Linux" : t3.indexOf("Android") !== -1 ? e8 = "Android" : t3.indexOf("like Mac") !== -1 || t3.indexOf("iPhone") !== -1 || t3.indexOf("iPad") !== -1 ? e8 = "iOS" : e8 = "Unknown";
  let r3;
  return /Mobile|iPhone|iPod|Android/i.test(t3) ? r3 = "Mobile" : /Tablet|iPad/i.test(t3) ? r3 = "Tablet" : r3 = "Desktop", { model: e8, family: e8, device: r3 };
}
var Q2 = class B2 {
  constructor(e8) {
    l2(this, "_parent");
    l2(this, "breadcrumbs", []);
    l2(this, "context", {});
    l2(this, "extra", {});
    l2(this, "tags", {});
    l2(this, "request");
    l2(this, "user");
    this._parent = e8;
  }
  get parent() {
    return this._parent;
  }
  child() {
    return new B2(this);
  }
  setRequest(e8) {
    return this.request = e8, this;
  }
  removeRequest() {
    return this.request = void 0, this;
  }
  addBreadcrumb(e8) {
    return typeof e8.timestamp > "u" && (e8.timestamp = (/* @__PURE__ */ new Date()).toISOString()), this.breadcrumbs.push(e8), this;
  }
  setExtra(e8, r3) {
    return this.extra[e8] = r3, this;
  }
  removeExtra(e8) {
    return delete this.extra[e8], this;
  }
  setContext(e8, r3) {
    return typeof r3.type > "u" && (r3.type = e8), this.context[e8] = r3, this;
  }
  removeContext(e8) {
    return delete this.context[e8], this;
  }
  setTags(e8) {
    return this.tags = d2(d2({}, this.tags), e8), this;
  }
  setTag(e8, r3) {
    return this.tags[e8] = r3, this;
  }
  removeTag(e8) {
    return delete this.tags[e8], this;
  }
  setUser(e8) {
    return this.user = e8, this;
  }
  removeUser() {
    return this.user = void 0, this;
  }
  toBody() {
    let e8 = [], r3 = this;
    for (; r3; ) e8.push(r3), r3 = r3.parent;
    return e8.reverse().reduce((n2, s) => {
      var a;
      return n2.breadcrumbs = [...(a = n2.breadcrumbs) != null ? a : [], ...s.breadcrumbs], n2.extra = d2(d2({}, n2.extra), s.extra), n2.contexts = d2(d2({}, n2.contexts), s.context), n2.tags = d2(d2({}, n2.tags), s.tags), s.user && (n2.user = s.user), s.request && (n2.request = s.request), n2;
    }, { breadcrumbs: [], extra: {}, contexts: {}, tags: {}, request: void 0, user: void 0 });
  }
  clear() {
    this.breadcrumbs = [], this.context = {}, this.tags = {}, this.user = void 0;
  }
};
var Z2 = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var ee2 = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js))(?::(\d+))?(?::(\d+))?\s*$/i;
var te2 = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
var re2 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
var N2 = "?";
var k2 = "An unknown error occurred";
var ne2 = "0.0.4";
function se2(t3) {
  for (let e8 = 0; e8 < t3.length; e8++) t3[e8] = Math.floor(Math.random() * 256);
  return t3;
}
function p2(t3) {
  return (t3 + 256).toString(16).substring(1);
}
function oe2() {
  let t3 = se2(new Array(16));
  return t3[6] = t3[6] & 15 | 64, t3[8] = t3[8] & 63 | 128, p2(t3[0]) + p2(t3[1]) + p2(t3[2]) + p2(t3[3]) + "-" + p2(t3[4]) + p2(t3[5]) + "-" + p2(t3[6]) + p2(t3[7]) + "-" + p2(t3[8]) + p2(t3[9]) + "-" + p2(t3[10]) + p2(t3[11]) + p2(t3[12]) + p2(t3[13]) + p2(t3[14]) + p2(t3[15]);
}
var ie2 = [[Z2, "chrome"], [te2, "winjs"], [ee2, "gecko"]];
function ae2(t3) {
  var n2, s, a, u2;
  if (!t3.stack) return null;
  let e8 = [], r3 = (a = (s = (n2 = t3.stack).split) == null ? void 0 : s.call(n2, `
`)) != null ? a : [];
  for (let o = 0; o < r3.length; ++o) {
    let c2 = null, i2 = null, f2 = null;
    for (let [v2, w2] of ie2) if (i2 = v2.exec(r3[o]), i2) {
      f2 = w2;
      break;
    }
    if (!(!i2 || !f2)) {
      if (f2 === "chrome") c2 = { filename: (u2 = i2[2]) != null && u2.startsWith("address at ") ? i2[2].substring(11) : i2[2], function: i2[1] || N2, lineno: i2[3] ? +i2[3] : null, colno: i2[4] ? +i2[4] : null };
      else if (f2 === "winjs") c2 = { filename: i2[2], function: i2[1] || N2, lineno: +i2[3], colno: i2[4] ? +i2[4] : null };
      else if (f2 === "gecko") o === 0 && !i2[5] && t3.columnNumber !== void 0 && e8.length > 0 && (e8[0].column = t3.columnNumber + 1), c2 = { filename: i2[3], function: i2[1] || N2, lineno: i2[4] ? +i2[4] : null, colno: i2[5] ? +i2[5] : null };
      else continue;
      !c2.function && c2.lineno && (c2.function = N2), e8.push(c2);
    }
  }
  return e8.length ? e8.reverse() : null;
}
function ce2(t3) {
  let e8 = ae2(t3);
  return { type: t3.name, value: t3.message, stacktrace: { frames: e8 != null ? e8 : [] } };
}
function ue2(t3) {
  let e8 = re2.exec(t3), r3 = e8 ? e8.slice(1) : [];
  if (r3.length !== 6) throw new Error("Invalid DSN");
  let n2 = r3[5].split("/"), s = n2.slice(0, -1).join("/");
  return r3[0] + "://" + r3[3] + (r3[4] ? ":" + r3[4] : "") + (s ? "/" + s : "") + "/api/" + n2.pop() + "/envelope/?sentry_version=7&sentry_key=" + r3[1] + (r3[2] ? "&sentry_secret=" + r3[2] : "");
}
function le2(t3, e8, r3) {
  var s, a;
  let n2 = d2({ event_id: oe2().replaceAll("-", ""), platform: "javascript", sdk: { name: "@hcaptcha/sentry", version: ne2 }, environment: e8, release: r3, timestamp: Date.now() / 1e3 }, t3.scope.toBody());
  if (t3.type === "exception") {
    n2.message = (a = (s = t3.error) == null ? void 0 : s.message) != null ? a : "Unknown error", n2.fingerprint = [n2.message];
    let u2 = [], o = t3.error;
    for (let c2 = 0; c2 < 5 && o && (u2.push(ce2(o)), !(!o.cause || !(o.cause instanceof Error))); c2++) o = o.cause;
    n2.exception = { values: u2.reverse() };
  }
  return t3.type === "message" && (n2.message = t3.message, n2.level = t3.level), n2;
}
function de2(t3) {
  if (t3 instanceof Error) return t3;
  if (typeof t3 == "string") return new Error(t3);
  if (typeof t3 == "object" && t3 !== null && !Array.isArray(t3)) {
    let r3 = t3, { message: n2 } = r3, s = M2(r3, ["message"]), a = new Error(typeof n2 == "string" ? n2 : k2);
    return Object.assign(a, s);
  }
  let e8 = new Error(k2);
  return Object.assign(e8, { cause: t3 });
}
function pe2(t3, e8, r3) {
  return x2(this, null, function* () {
    var n2, s;
    try {
      if (typeof fetch < "u" && typeof AbortSignal < "u") {
        let a;
        if (r3) {
          let c2 = new AbortController();
          a = c2.signal, setTimeout(() => c2.abort(), r3);
        }
        let u2 = yield fetch(t3, O2(d2({}, e8), { signal: a })), o = yield u2.text();
        return { status: u2.status, body: o };
      }
      return yield new Promise((a, u2) => {
        var c2, i2;
        let o = new XMLHttpRequest();
        if (o.open((c2 = e8 == null ? void 0 : e8.method) != null ? c2 : "GET", t3), o.onload = () => a({ status: o.status, body: o.responseText }), o.onerror = () => u2(new Error("XHR Network Error")), e8 == null ? void 0 : e8.headers) for (let [f2, v2] of Object.entries(e8.headers)) o.setRequestHeader(f2, v2);
        if (r3) {
          let f2 = setTimeout(() => {
            o.abort(), u2(new Error("Request timed out"));
          }, r3);
          o.onloadend = () => {
            clearTimeout(f2);
          };
        }
        o.send((i2 = e8 == null ? void 0 : e8.body) == null ? void 0 : i2.toString());
      });
    } catch (a) {
      return { status: 0, body: (s = (n2 = a == null ? void 0 : a.toString) == null ? void 0 : n2.call(a)) != null ? s : "Unknown error" };
    }
  });
}
var h2;
var A2 = (h2 = class {
  constructor(e8) {
    l2(this, "apiURL");
    l2(this, "dsn");
    l2(this, "environment");
    l2(this, "release");
    l2(this, "sampleRate");
    l2(this, "debug");
    l2(this, "_scope");
    l2(this, "shouldBuffer", false);
    l2(this, "bufferlimit", 20);
    l2(this, "buffer", []);
    var r3, n2, s, a, u2;
    this.environment = e8.environment, this.release = e8.release, this.sampleRate = (r3 = e8.sampleRate) != null ? r3 : 1, this.debug = (n2 = e8.debug) != null ? n2 : false, this._scope = (s = e8.scope) != null ? s : new Q2(), this.apiURL = ue2(e8.dsn), this.dsn = e8.dsn, this.shouldBuffer = (a = e8.buffer) != null ? a : false, this.bufferlimit = (u2 = e8.bufferLimit) != null ? u2 : 20;
  }
  static init(e8) {
    h2._instance || (h2._instance = new h2(e8));
  }
  static get instance() {
    if (!h2._instance) throw new Error("Sentry has not been initialized");
    return h2._instance;
  }
  log(...e8) {
    this.debug && console.log(...e8);
  }
  get scope() {
    return this._scope;
  }
  static get scope() {
    return h2.instance.scope;
  }
  withScope(e8) {
    let r3 = this._scope.child();
    e8(r3);
  }
  static withScope(e8) {
    h2.instance.withScope(e8);
  }
  captureException(e8, r3) {
    this.captureEvent({ type: "exception", level: "error", error: de2(e8), scope: r3 != null ? r3 : this._scope });
  }
  static captureException(e8, r3) {
    h2.instance.captureException(e8, r3);
  }
  captureMessage(e8, r3 = "info", n2) {
    this.captureEvent({ type: "message", level: r3, message: e8, scope: n2 != null ? n2 : this._scope });
  }
  static captureMessage(e8, r3 = "info", n2) {
    h2.instance.captureMessage(e8, r3, n2);
  }
  captureEvent(e8) {
    if (Math.random() >= this.sampleRate) {
      this.log("Dropped event due to sample rate");
      return;
    }
    if (this.shouldBuffer) {
      if (this.buffer.length >= this.bufferlimit) return;
      this.buffer.push(e8);
    } else this.sendEvent(e8);
  }
  sendEvent(e8, r3 = 5e3) {
    return x2(this, null, function* () {
      try {
        this.log("Sending sentry event", e8);
        let n2 = le2(e8, this.environment, this.release), s = { event_id: n2.event_id, dsn: this.dsn }, a = { type: "event" }, u2 = JSON.stringify(s) + `
` + JSON.stringify(a) + `
` + JSON.stringify(n2), o = yield pe2(this.apiURL, { method: "POST", headers: { "Content-Type": "application/x-sentry-envelope" }, body: u2 }, r3);
        this.log("Sentry response", o.status), o.status !== 200 && (console.log(o.body), console.error("Failed to send event to Sentry", o));
      } catch (n2) {
        console.error("Failed to send event", n2);
      }
    });
  }
  flush(e8 = 5e3) {
    return x2(this, null, function* () {
      try {
        this.log("Flushing sentry events", this.buffer.length);
        let r3 = this.buffer.splice(0, this.buffer.length).map((n2) => this.sendEvent(n2, e8));
        yield Promise.all(r3), this.log("Flushed all events");
      } catch (r3) {
        console.error("Failed to flush events", r3);
      }
    });
  }
  static flush(e8 = 5e3) {
    return h2.instance.flush(e8);
  }
  static reset() {
    h2._instance = void 0;
  }
}, l2(h2, "_instance"), h2);
var he2 = "https://d233059272824702afc8c43834c4912d@sentry.hcaptcha.com/6";
var fe2 = "2.0.1";
var me2 = "production";
function j2(t3 = true) {
  if (!t3) return q2();
  A2.init({ dsn: he2, release: fe2, environment: me2 });
  let e8 = A2.scope;
  return F2(e8), q2(e8);
}
function q2(t3 = null) {
  return { addBreadcrumb: (e8) => {
    t3 && t3.addBreadcrumb(e8);
  }, captureRequest: (e8) => {
    t3 && t3.setRequest(e8);
  }, captureException: (e8) => {
    t3 && A2.captureException(e8, t3);
  } };
}
function H2({ scriptLocation: t3, query: e8, loadAsync: r3 = true, crossOrigin: n2 = "anonymous", apihost: s = "https://js.hcaptcha.com", cleanup: a = true, secureApi: u2 = false, scriptSource: o = "" } = {}, c2) {
  let i2 = S2(t3), f2 = R2(i2);
  return new Promise((v2, w2) => {
    let m2 = f2.document.createElement("script");
    m2.id = L2, o ? m2.src = `${o}?onload=${b2}` : u2 ? m2.src = `${s}/1/secure-api.js?onload=${b2}` : m2.src = `${s}/1/api.js?onload=${b2}`, m2.crossOrigin = n2, m2.async = r3;
    let T2 = (E2, X2) => {
      try {
        !u2 && a && i2.removeChild(m2), X2(E2);
      } catch (G2) {
        w2(G2);
      }
    };
    m2.onload = (E2) => T2(E2, v2), m2.onerror = (E2) => {
      c2 && c2(m2.src), T2(E2, w2);
    }, m2.src += e8 !== "" ? `&${e8}` : "", i2.appendChild(m2);
  });
}
var C2 = [];
function ge2(t3 = { cleanup: true }, e8) {
  try {
    e8.addBreadcrumb({ category: g2, message: "hCaptcha loader params", data: t3 });
    let r3 = S2(t3.scriptLocation), n2 = R2(r3), s = C2.find(({ scope: u2 }) => u2 === n2.window);
    if (s) return e8.addBreadcrumb({ category: g2, message: "hCaptcha already loaded" }), s.promise;
    let a = new Promise((u2, o) => x2(this, null, function* () {
      try {
        n2.window[b2] = () => {
          e8.addBreadcrumb({ category: g2, message: "hCaptcha script called onload function" }), u2(n2.window.hcaptcha);
        };
        let c2 = U2({ custom: t3.custom, render: t3.render, sentry: t3.sentry, assethost: t3.assethost, imghost: t3.imghost, reportapi: t3.reportapi, endpoint: t3.endpoint, host: t3.host, recaptchacompat: t3.recaptchacompat, hl: t3.hl });
        yield H2(d2({ query: c2 }, t3), (i2) => {
          e8.captureRequest({ url: i2, method: "GET" });
        }), e8.addBreadcrumb({ category: g2, message: "hCaptcha loaded", data: s });
      } catch (c2) {
        e8.addBreadcrumb({ category: g2, message: "hCaptcha failed to load" });
        let i2 = C2.findIndex((f2) => f2.scope === n2.window);
        i2 !== -1 && C2.splice(i2, 1), o(new Error(_2));
      }
    }));
    return C2.push({ promise: a, scope: n2.window }), a;
  } catch (r3) {
    return e8.captureException(r3), Promise.reject(new Error(_2));
  }
}
function $2(t3, e8, r3 = 0) {
  return x2(this, null, function* () {
    let n2 = r3 < 2 ? "Retry loading hCaptcha Api" : "Exceeded maximum retries";
    try {
      return yield ge2(t3, e8);
    } catch (s) {
      return e8.addBreadcrumb({ category: g2, message: n2 }), r3 >= 2 ? (e8.captureException(s), Promise.reject(s)) : (r3 += 1, $2(t3, e8, r3));
    }
  });
}
function xe2() {
  return x2(this, arguments, function* (t3 = {}) {
    let e8 = j2(t3.sentry);
    return yield $2(t3, e8);
  });
}

// node_modules/@hcaptcha/react-hcaptcha/dist/esm/utils.js
function getFrame(element) {
  var doc = element && element.ownerDocument || document;
  var win = doc.defaultView || doc.parentWindow || window;
  return {
    document: doc,
    window: win
  };
}
function getMountElement(element) {
  return element || document.head;
}

// node_modules/@hcaptcha/react-hcaptcha/dist/esm/index.js
var HCaptcha = function(_React$Component) {
  _inheritsLoose(HCaptcha2, _React$Component);
  function HCaptcha2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this._hcaptcha = void 0;
    _this.renderCaptcha = _this.renderCaptcha.bind(_assertThisInitialized(_this));
    _this.resetCaptcha = _this.resetCaptcha.bind(_assertThisInitialized(_this));
    _this.removeCaptcha = _this.removeCaptcha.bind(_assertThisInitialized(_this));
    _this.isReady = _this.isReady.bind(_assertThisInitialized(_this));
    _this._onReady = null;
    _this.loadCaptcha = _this.loadCaptcha.bind(_assertThisInitialized(_this));
    _this.handleOnLoad = _this.handleOnLoad.bind(_assertThisInitialized(_this));
    _this.handleSubmit = _this.handleSubmit.bind(_assertThisInitialized(_this));
    _this.handleExpire = _this.handleExpire.bind(_assertThisInitialized(_this));
    _this.handleError = _this.handleError.bind(_assertThisInitialized(_this));
    _this.handleOpen = _this.handleOpen.bind(_assertThisInitialized(_this));
    _this.handleClose = _this.handleClose.bind(_assertThisInitialized(_this));
    _this.handleChallengeExpired = _this.handleChallengeExpired.bind(_assertThisInitialized(_this));
    _this.ref = React.createRef();
    _this.apiScriptRequested = false;
    _this.sentryHub = null;
    _this.captchaId = "";
    _this.state = {
      isApiReady: false,
      isRemoved: false,
      elementId: props.id
    };
    return _this;
  }
  var _proto = HCaptcha2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    var element = getMountElement(this.props.scriptLocation);
    var frame = getFrame(element);
    this._hcaptcha = frame.window.hcaptcha || void 0;
    var isApiReady = typeof this._hcaptcha !== "undefined";
    if (isApiReady) {
      this.setState({
        isApiReady: true
      }, function() {
        _this2.renderCaptcha();
      });
      return;
    }
    this.loadCaptcha();
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    var hcaptcha = this._hcaptcha;
    var captchaId = this.captchaId;
    if (!this.isReady()) {
      return;
    }
    hcaptcha.reset(captchaId);
    hcaptcha.remove(captchaId);
  };
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
    if (this.state.isApiReady !== nextState.isApiReady || this.state.isRemoved !== nextState.isRemoved) {
      return false;
    }
    return true;
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this3 = this;
    var keys = ["sitekey", "size", "theme", "tabindex", "languageOverride", "endpoint"];
    var match = keys.every(function(key) {
      return prevProps[key] === _this3.props[key];
    });
    if (!match) {
      this.removeCaptcha(function() {
        _this3.renderCaptcha();
      });
    }
  };
  _proto.loadCaptcha = function loadCaptcha() {
    if (this.apiScriptRequested) {
      return;
    }
    var _this$props = this.props, apihost = _this$props.apihost, assethost = _this$props.assethost, endpoint = _this$props.endpoint, host = _this$props.host, imghost = _this$props.imghost, hl2 = _this$props.languageOverride, reCaptchaCompat = _this$props.reCaptchaCompat, reportapi = _this$props.reportapi, sentry = _this$props.sentry, custom = _this$props.custom, loadAsync = _this$props.loadAsync, scriptLocation = _this$props.scriptLocation, scriptSource = _this$props.scriptSource, secureApi = _this$props.secureApi, _this$props$cleanup = _this$props.cleanup, cleanup = _this$props$cleanup === void 0 ? true : _this$props$cleanup;
    var mountParams = {
      render: "explicit",
      apihost,
      assethost,
      endpoint,
      hl: hl2,
      host,
      imghost,
      recaptchacompat: reCaptchaCompat === false ? "off" : null,
      reportapi,
      sentry,
      custom,
      loadAsync,
      scriptLocation,
      scriptSource,
      secureApi,
      cleanup
    };
    xe2(mountParams).then(this.handleOnLoad, this.handleError)["catch"](this.handleError);
    this.apiScriptRequested = true;
  };
  _proto.renderCaptcha = function renderCaptcha(onRender) {
    var _this4 = this;
    var onReady = this.props.onReady;
    var isApiReady = this.state.isApiReady;
    var captchaId = this.captchaId;
    if (!isApiReady || captchaId) return;
    var renderParams = Object.assign({
      "open-callback": this.handleOpen,
      "close-callback": this.handleClose,
      "error-callback": this.handleError,
      "chalexpired-callback": this.handleChallengeExpired,
      "expired-callback": this.handleExpire,
      "callback": this.handleSubmit
    }, this.props, {
      hl: this.props.hl || this.props.languageOverride,
      languageOverride: void 0
    });
    var hcaptcha = this._hcaptcha;
    var id2 = hcaptcha.render(this.ref.current, renderParams);
    this.captchaId = id2;
    this.setState({
      isRemoved: false
    }, function() {
      onRender && onRender();
      onReady && onReady();
      _this4._onReady && _this4._onReady(id2);
    });
  };
  _proto.resetCaptcha = function resetCaptcha() {
    var hcaptcha = this._hcaptcha;
    var captchaId = this.captchaId;
    if (!this.isReady()) {
      return;
    }
    hcaptcha.reset(captchaId);
  };
  _proto.removeCaptcha = function removeCaptcha(callback) {
    var _this5 = this;
    var hcaptcha = this._hcaptcha;
    var captchaId = this.captchaId;
    if (!this.isReady()) {
      return;
    }
    this.setState({
      isRemoved: true
    }, function() {
      _this5.captchaId = "";
      hcaptcha.remove(captchaId);
      callback && callback();
    });
  };
  _proto.handleOnLoad = function handleOnLoad() {
    var _this6 = this;
    this.setState({
      isApiReady: true
    }, function() {
      var element = getMountElement(_this6.props.scriptLocation);
      var frame = getFrame(element);
      _this6._hcaptcha = frame.window.hcaptcha;
      _this6.renderCaptcha(function() {
        var onLoad = _this6.props.onLoad;
        if (onLoad) onLoad();
      });
    });
  };
  _proto.handleSubmit = function handleSubmit(event) {
    var onVerify = this.props.onVerify;
    var isRemoved = this.state.isRemoved;
    var hcaptcha = this._hcaptcha;
    var captchaId = this.captchaId;
    if (typeof hcaptcha === "undefined" || isRemoved) return;
    var token = hcaptcha.getResponse(captchaId);
    var ekey = hcaptcha.getRespKey(captchaId);
    if (onVerify) onVerify(token, ekey);
  };
  _proto.handleExpire = function handleExpire() {
    var onExpire = this.props.onExpire;
    var hcaptcha = this._hcaptcha;
    var captchaId = this.captchaId;
    if (!this.isReady()) {
      return;
    }
    hcaptcha.reset(captchaId);
    if (onExpire) onExpire();
  };
  _proto.handleError = function handleError(event) {
    var onError = this.props.onError;
    var hcaptcha = this._hcaptcha;
    var captchaId = this.captchaId;
    if (this.isReady()) {
      hcaptcha.reset(captchaId);
    }
    if (onError) onError(event);
  };
  _proto.isReady = function isReady() {
    var _this$state = this.state, isApiReady = _this$state.isApiReady, isRemoved = _this$state.isRemoved;
    return isApiReady && !isRemoved;
  };
  _proto.handleOpen = function handleOpen() {
    if (!this.isReady() || !this.props.onOpen) {
      return;
    }
    this.props.onOpen();
  };
  _proto.handleClose = function handleClose() {
    if (!this.isReady() || !this.props.onClose) {
      return;
    }
    this.props.onClose();
  };
  _proto.handleChallengeExpired = function handleChallengeExpired() {
    if (!this.isReady() || !this.props.onChalExpired) {
      return;
    }
    this.props.onChalExpired();
  };
  _proto.execute = function execute(opts) {
    var _this7 = this;
    if (opts === void 0) {
      opts = null;
    }
    opts = typeof opts === "object" ? opts : null;
    try {
      var hcaptcha = this._hcaptcha;
      var captchaId = this.captchaId;
      if (!this.isReady()) {
        var _opts;
        var onReady = new Promise(function(resolve, reject) {
          _this7._onReady = function(id2) {
            try {
              var _hcaptcha = _this7._hcaptcha;
              if (opts && opts.async) {
                _hcaptcha.execute(id2, opts).then(resolve)["catch"](reject);
              } else {
                resolve(_hcaptcha.execute(id2, opts));
              }
            } catch (e8) {
              reject(e8);
            }
          };
        });
        return (_opts = opts) != null && _opts.async ? onReady : null;
      }
      return hcaptcha.execute(captchaId, opts);
    } catch (error) {
      if (opts && opts.async) {
        return Promise.reject(error);
      }
      return null;
    }
  };
  _proto.close = function close() {
    var hcaptcha = this._hcaptcha;
    var captchaId = this.captchaId;
    if (!this.isReady()) {
      return;
    }
    return hcaptcha.close(captchaId);
  };
  _proto.setData = function setData(data) {
    var hcaptcha = this._hcaptcha;
    var captchaId = this.captchaId;
    if (!this.isReady()) {
      return;
    }
    if (data && typeof data !== "object") {
      data = null;
    }
    hcaptcha.setData(captchaId, data);
  };
  _proto.getResponse = function getResponse() {
    var hcaptcha = this._hcaptcha;
    return hcaptcha.getResponse(this.captchaId);
  };
  _proto.getRespKey = function getRespKey() {
    var hcaptcha = this._hcaptcha;
    return hcaptcha.getRespKey(this.captchaId);
  };
  _proto.render = function render() {
    var elementId = this.state.elementId;
    return React.createElement("div", {
      ref: this.ref,
      id: elementId
    });
  };
  return HCaptcha2;
}(React.Component);
var esm_default = HCaptcha;

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Login/Login.js
var import_react26 = __toESM(require_react());

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/handlers/AbstractHandler.js
var PasswordlessHandler = class {
  constructor(params) {
    _defineProperty(this, "authBaseApiUrl", void 0);
    _defineProperty(this, "passwordlessParams", void 0);
    _defineProperty(this, "trackingIdentifier", void 0);
    _defineProperty(this, "version", `web3auth-${version2.split(".")[0]}`);
    if (!params.authConnection) throw WalletInitializationError.invalidParams("authConnection is required");
    if (!params.web3authClientId) throw WalletInitializationError.invalidParams("web3authClientId is required");
    if (!params.loginHint) throw WalletInitializationError.invalidParams("loginHint is required");
    if (!params.network) throw WalletInitializationError.invalidParams("network is required");
    if (!params.authBuildEnv) params.authBuildEnv = BUILD_ENV.PRODUCTION;
    this.authBaseApiUrl = `${PASSWORDLESS_BUILD_ENV_MAP[params.authBuildEnv]}/api/v3/auth`;
    this.passwordlessParams = params;
  }
  get name() {
    if (this.passwordlessParams.authConnection === AUTH_CONNECTION.EMAIL_PASSWORDLESS) return "Email";
    if (this.passwordlessParams.authConnection === AUTH_CONNECTION.SMS_PASSWORDLESS) return "Mobile";
    throw WalletInitializationError.invalidParams("Invalid authConnection");
  }
  get connection() {
    if (this.passwordlessParams.authConnection === AUTH_CONNECTION.EMAIL_PASSWORDLESS) return "email";
    if (this.passwordlessParams.authConnection === AUTH_CONNECTION.SMS_PASSWORDLESS) return "sms";
    throw WalletInitializationError.invalidParams("Invalid authConnection");
  }
  get trackingId() {
    return this.trackingIdentifier;
  }
  get sessionStorageAvailable() {
    return storageAvailable("sessionStorage");
  }
  get whiteLabelParams() {
    var _ref;
    const {
      uiConfig
    } = this.passwordlessParams;
    if (!uiConfig) return {};
    const {
      appName,
      appUrl,
      defaultLanguage,
      mode,
      logoLight,
      logoDark,
      theme
    } = uiConfig;
    const finalLogo = (_ref = mode === "dark" ? logoDark : logoLight) !== null && _ref !== void 0 ? _ref : "";
    return {
      mode: mode !== null && mode !== void 0 ? mode : "light",
      name: appName !== null && appName !== void 0 ? appName : "",
      url: appUrl !== null && appUrl !== void 0 ? appUrl : "",
      language: defaultLanguage !== null && defaultLanguage !== void 0 ? defaultLanguage : "en",
      logo: finalLogo.includes(".svg") ? "" : finalLogo,
      theme: theme !== null && theme !== void 0 ? theme : {}
    };
  }
  set trackingId(value) {
    this.trackingIdentifier = value;
  }
  async start(params) {
    try {
      const result = await post(`${this.authBaseApiUrl}/passwordless/start`, params);
      if (result && result.success) {
        var _result$data;
        this.trackingId = (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.trackingId;
        if (this.sessionStorageAvailable) window.sessionStorage.setItem("trackingId", this.trackingId);
      }
      return result;
    } catch (e8) {
      return this.handleError(e8);
    }
  }
  async verify(params) {
    try {
      const result = await post(`${this.authBaseApiUrl}/passwordless/verify`, params);
      if (result.success) {
        if (this.sessionStorageAvailable) window.sessionStorage.removeItem("trackingId");
        return {
          success: true,
          data: {
            id_token: result.id_token
          }
        };
      }
      return {
        success: false,
        error: result.message
      };
    } catch (e8) {
      return this.handleError(e8);
    }
  }
  async handleError(e8) {
    let error;
    if (e8.status === 429) {
      error = "passwordless.error-too-many-requests";
    } else {
      try {
        const err = await e8.json();
        error = err.error_code ? getErrorMessages(err.error_code) : err.message;
      } catch {
        error = "passwordless.something-wrong-error";
      }
    }
    return {
      success: false,
      error
    };
  }
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/handlers/EmailPasswordlessHandler.js
var EmailPasswordlessHandler = class extends PasswordlessHandler {
  constructor(params) {
    var _window$sessionStorag;
    super(params);
    _defineProperty(this, "mailSent", void 0);
    this.mailSent = false;
    if (this.sessionStorageAvailable) this.trackingId = (_window$sessionStorag = window.sessionStorage.getItem("trackingId")) !== null && _window$sessionStorag !== void 0 ? _window$sessionStorag : void 0;
  }
  async sendVerificationCode({
    captchaToken
  }) {
    const {
      loginHint,
      network,
      web3authClientId
    } = this.passwordlessParams;
    const finalParams = {
      client_id: web3authClientId,
      web3auth_client_id: web3authClientId,
      connection: this.connection,
      login_hint: loginHint,
      tracking_id: this.trackingId,
      whitelabel: this.whiteLabelParams,
      version: this.version,
      network,
      flow_type: EMAIL_FLOW.code,
      captcha_token: captchaToken
    };
    return super.start(finalParams);
  }
  async verifyCode(code) {
    const {
      loginHint,
      network,
      web3authClientId
    } = this.passwordlessParams;
    const params = {
      client_id: web3authClientId,
      login_hint: loginHint,
      code,
      connection: "email",
      tracking_id: this.trackingId,
      version: this.version,
      network,
      flow_type: EMAIL_FLOW.code
    };
    return super.verify(params);
  }
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/handlers/SmsPasswordlessHandler.js
var SmsPasswordlessHandler = class extends PasswordlessHandler {
  constructor(params) {
    super(params);
    if (this.sessionStorageAvailable) {
      var _window$sessionStorag;
      this.trackingId = (_window$sessionStorag = window.sessionStorage.getItem("trackingId")) !== null && _window$sessionStorag !== void 0 ? _window$sessionStorag : void 0;
    }
  }
  async sendVerificationCode({
    captchaToken
  }) {
    const {
      loginHint,
      network,
      web3authClientId
    } = this.passwordlessParams;
    const finalParams = _objectSpread2({
      client_id: web3authClientId,
      web3auth_client_id: web3authClientId,
      connection: this.connection,
      login_hint: loginHint,
      tracking_id: this.trackingId,
      whitelabel: this.whiteLabelParams,
      version: this.version,
      network
    }, captchaToken && {
      captcha_token: captchaToken
    });
    return super.start(finalParams);
  }
  async verifyCode(code) {
    const {
      loginHint,
      network,
      web3authClientId
    } = this.passwordlessParams;
    const params = {
      client_id: web3authClientId,
      login_hint: loginHint,
      code,
      connection: this.connection,
      tracking_id: this.trackingId,
      version: this.version,
      network
    };
    return super.verify(params);
  }
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/handlers/factory.js
var createPasswordlessHandler = (authConnection, params) => {
  switch (authConnection) {
    case AUTH_CONNECTION.EMAIL_PASSWORDLESS:
      return new EmailPasswordlessHandler(params);
    case AUTH_CONNECTION.SMS_PASSWORDLESS:
      return new SmsPasswordlessHandler(params);
    default:
      throw WalletInitializationError.invalidParams(`Unsupported auth connection: ${authConnection}`);
  }
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/helper/testAccounts.js
var EMAIL_TEST_ACCOUNT_PREFIX = "test_account_";
var EMAIL_TEST_ACCOUNT_POSTFIX = "@example.com";
var PHONE_TEST_ACCOUNT_PREFIX = "+1-555";
var isTestAccountPattern = (authConnection, loginHint) => {
  if (authConnection === AUTH_CONNECTION.EMAIL_PASSWORDLESS) {
    return loginHint.startsWith(EMAIL_TEST_ACCOUNT_PREFIX) && loginHint.endsWith(EMAIL_TEST_ACCOUNT_POSTFIX);
  } else if (authConnection === AUTH_CONNECTION.SMS_PASSWORDLESS) {
    return loginHint.startsWith(PHONE_TEST_ACCOUNT_PREFIX);
  }
  throw WalletInitializationError.invalidParams(`Unsupported auth connection: ${authConnection}`);
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/LoginHint/LoginHint.js
var import_react22 = __toESM(require_react());
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var LoginHint = ({
  children,
  content,
  isDark = false,
  hideHint = false
}) => {
  const [showPopover, setShowPopover] = (0, import_react22.useState)(false);
  const handleMouseEnter = () => {
    setShowPopover(true);
  };
  const handleMouseLeave = () => {
    setShowPopover(false);
  };
  const triangleStyle = (0, import_react22.useMemo)(() => {
    const triangleSize = "8px";
    const triangleColor = isDark ? "#ffffff" : "#1f2a37";
    return {
      borderTop: `${triangleSize} solid transparent`,
      borderRight: "none",
      borderBottom: `${triangleSize} solid transparent`,
      borderLeft: `${triangleSize} solid ${triangleColor}`,
      left: "0%",
      top: `calc(100% - ${triangleSize})`
    };
  }, [isDark]);
  return (0, import_jsx_runtime18.jsxs)("div", {
    className: "w3a--relative",
    "aria-hidden": true,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onFocus: handleMouseEnter,
    onBlur: handleMouseLeave,
    onClick: handleMouseLeave,
    children: [children, showPopover && !hideHint && (0, import_jsx_runtime18.jsxs)("div", {
      "data-popover": true,
      role: "tooltip",
      className: cn2("w3a--absolute w3a--z-[45] w3a--shadow-2xl w3a--rounded-lg w3a--bottom-[100%] w3a--left-[50%] w3a--w-max w3a--text-xs w3a--px-[6px] w3a--py-[3px]", isDark ? "w3a--bg-app-white w3a--text-app-gray-900" : "w3a--bg-app-gray-800 w3a--text-app-gray-100"),
      children: [content, (0, import_jsx_runtime18.jsx)("div", {
        className: "w3a--absolute",
        style: triangleStyle
      })]
    })]
  });
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/SocialLoginList/SocialLoginList.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
function getProviderIcon2(method, isDark, extension) {
  const imageId = method === AUTH_CONNECTION.TWITTER ? `login-X${isDark ? "-light" : "-dark"}` : `login-${method}${isDark ? "-light" : "-dark"}`;
  const hoverId = method === AUTH_CONNECTION.APPLE || method === AUTH_CONNECTION.GITHUB || method === AUTH_CONNECTION.TWITTER ? imageId : `login-${method}-active`;
  return (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, {
    children: [(0, import_jsx_runtime19.jsx)("img", {
      id: "active-login-img",
      src: `https://images.web3auth.io/${hoverId}${extension}`,
      alt: "active-login-img",
      className: "w3a--hidden w3a--size-5 w3a--object-contain group-hover:w3a--block"
    }), (0, import_jsx_runtime19.jsx)("img", {
      id: "login-img",
      src: `https://images.web3auth.io/${imageId}${extension}`,
      alt: "login-img",
      className: "w3a--block w3a--size-5 w3a--object-contain group-hover:w3a--hidden"
    })]
  });
}
function SocialLoginList(props) {
  const {
    visibleRow,
    otherRow,
    isDark,
    canShowMore,
    handleSocialLoginClick,
    handleExpandSocialLogins,
    buttonRadius
  } = props;
  const getGridRowFromVisibleLogin = () => {
    if (visibleRow.length === 1) {
      return "w3a--grid-cols-1";
    } else if (visibleRow.length === 2) {
      return "w3a--grid-cols-2";
    } else if (visibleRow.length === 3) {
      return "w3a--grid-cols-3";
    } else {
      return "w3a--grid-cols-4";
    }
  };
  if (visibleRow.length !== 0 && (otherRow === null || otherRow === void 0 ? void 0 : otherRow.length) === 0) {
    return (0, import_jsx_runtime19.jsx)("div", {
      className: "w3a--flex w3a--w-full w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-2",
      children: (0, import_jsx_runtime19.jsxs)("div", {
        className: cn2("w3a--grid w3a--w-full w3a--gap-x-2", getGridRowFromVisibleLogin()),
        children: [visibleRow.filter((_3, index) => visibleRow.length === 4 ? index <= 3 : index < 3).map((row) => (0, import_jsx_runtime19.jsx)(LoginHint, {
          content: "Last Login",
          isDark,
          hideHint: true,
          children: (0, import_jsx_runtime19.jsx)(Button, {
            type: BUTTON_TYPE.SOCIAL,
            props: {
              showText: false,
              method: row.method,
              isDark,
              isPrimaryBtn: false,
              btnStyle: "w3a--flex w3a--items-center !w3a--justify-center w3a--w-full w3a--h-11 w3a--group",
              children: (0, import_jsx_runtime19.jsx)(import_jsx_runtime19.Fragment, {
                children: getProviderIcon2(row.method, isDark, ".svg")
              }),
              onClick: () => handleSocialLoginClick({
                connector: row.connector,
                loginParams: row.loginParams
              }),
              buttonRadius
            }
          }, row.method)
        }, row.method)), canShowMore && visibleRow.length > 4 && (0, import_jsx_runtime19.jsx)(Button, {
          type: BUTTON_TYPE.SOCIAL,
          props: {
            showIcon: false,
            onClick: handleExpandSocialLogins,
            btnStyle: "w3a--flex w3a--items-center !w3a--justify-center w3a--w-full w3a--h-11",
            children: (0, import_jsx_runtime19.jsx)("img", {
              src: getIcons(isDark ? "dots-dark-horizontal" : "dots-light-horizontal"),
              alt: "Logo",
              className: "w3a--object-contain"
            }),
            buttonRadius
          }
        })]
      })
    });
  }
  return (0, import_jsx_runtime19.jsxs)("div", {
    className: "w3a--flex w3a--w-full w3a--flex-col w3a--items-start w3a--justify-start w3a--gap-y-4",
    children: [(0, import_jsx_runtime19.jsx)("button", {
      type: "button",
      className: "w3a--appearance-none",
      onClick: () => handleExpandSocialLogins(),
      children: (0, import_jsx_runtime19.jsx)("img", {
        src: getIcons(isDark ? "arrow-left-dark" : "arrow-left-light"),
        alt: "Logo",
        className: "w3a--object-contain"
      })
    }), (0, import_jsx_runtime19.jsx)("div", {
      className: "w3a--social-container w3a--grid w3a--h-[300px] w3a--w-full w3a--auto-rows-min w3a--grid-cols-1 w3a--gap-y-2 w3a--overflow-y-auto w3a--pl-2 w3a--pr-3",
      children: otherRow.map((row) => (0, import_jsx_runtime19.jsx)("div", {
        className: "w3a--h-11 w3a--w-full",
        children: (0, import_jsx_runtime19.jsx)(Button, {
          type: BUTTON_TYPE.SOCIAL,
          props: {
            method: row.method,
            isDark,
            isPrimaryBtn: false,
            onClick: () => handleSocialLoginClick({
              connector: row.connector,
              loginParams: row.loginParams
            }),
            btnStyle: "w3a--group w3a--relative w3a--overflow-hidden w3a--flex w3a--items-center !w3a--justify-start w3a--w-full w3a--h-11",
            buttonRadius,
            children: (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, {
              children: [getProviderIcon2(row.method, isDark, ".svg"), (0, import_jsx_runtime19.jsx)("p", {
                className: "w3a--text-sm w3a--font-normal w3a--text-app-gray-900 dark:w3a--text-app-white",
                children: row.name
              }), (0, import_jsx_runtime19.jsx)("img", {
                id: "login-arrow",
                className: "w3a--absolute w3a--right-4 w3a--top-1/2 -w3a--translate-x-10 -w3a--translate-y-1/2 w3a--opacity-0 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-0 group-hover:w3a--opacity-100",
                src: getIcons(isDark ? "chevron-right-dark" : "chevron-right-light"),
                alt: "arrow"
              })]
            })
          }
        })
      }, row.method))
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Login/LoginOtp/LoginOtp.js
var import_react24 = __toESM(require_react());

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Otp/Otp.js
var import_react23 = __toESM(require_react());
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var OtpInput = (0, import_react23.forwardRef)(({
  length,
  loading,
  resendTimer = 60,
  onComplete,
  onChange,
  error = false,
  success = false,
  disabled = false,
  classes,
  helperText = "",
  onResendTimer,
  showCta = true,
  showTimer = true,
  autoFocus = false,
  placeholder = "",
  autoComplete = "one-time-code",
  type = "text",
  resendBtnText = ""
}, ref) => {
  const [otpArray, setOtpArray] = (0, import_react23.useState)(Array(length).fill(""));
  const [timer, setTimer] = (0, import_react23.useState)(resendTimer !== null && resendTimer !== void 0 ? resendTimer : 0);
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const inputRefs = (0, import_react23.useRef)([]);
  const isInputValueValid = (value) => {
    return /^\d$/.test(value) && value.trim().length === 1;
  };
  const handleKeyDown = (e8, index) => {
    if (e8.key === "Backspace" || e8.key === "Delete") {
      e8.preventDefault();
      const newOtpArray = [...otpArray];
      if (otpArray[index] !== "") {
        newOtpArray[index] = "";
      } else if (index > 0) {
        var _inputRefs$current;
        (_inputRefs$current = inputRefs.current[index - 1]) === null || _inputRefs$current === void 0 || _inputRefs$current.focus();
        newOtpArray[index - 1] = "";
      }
      setOtpArray(newOtpArray);
      if (onChange) onChange(newOtpArray.join(""));
    } else if (e8.key === "ArrowLeft") {
      var _inputRefs$current2;
      e8.preventDefault();
      (_inputRefs$current2 = inputRefs.current[index - 1]) === null || _inputRefs$current2 === void 0 || _inputRefs$current2.focus();
    } else if (e8.key === "ArrowRight") {
      var _inputRefs$current3;
      e8.preventDefault();
      (_inputRefs$current3 = inputRefs.current[index + 1]) === null || _inputRefs$current3 === void 0 || _inputRefs$current3.focus();
    } else if (e8.key === " " || e8.key === "Spacebar" || e8.key === "Space" || !isInputValueValid(e8.key) && inputRefs.current[index + 1]) {
      e8.preventDefault();
      inputRefs.current[index + 1].value = "";
    }
  };
  const handleInputChange = (e8, index) => {
    e8.preventDefault();
    const {
      value
    } = e8.target;
    if (value && value.length > 1 && value.length === length) {
      var _inputRefs$current4;
      const pastedOtp = value.split("");
      const newOtpArray = [...otpArray];
      pastedOtp.forEach((key, idx) => {
        newOtpArray[idx] = key;
      });
      setOtpArray(newOtpArray);
      (_inputRefs$current4 = inputRefs.current[pastedOtp.length === length ? length - 1 : pastedOtp.length]) === null || _inputRefs$current4 === void 0 || _inputRefs$current4.focus();
      if (onComplete && length === newOtpArray.length) onComplete(newOtpArray.join(""));
    } else if (isInputValueValid(value)) {
      const newOtpArray = [...otpArray].slice(0, length);
      newOtpArray[index] = value;
      setOtpArray(newOtpArray);
      const otp = newOtpArray.join("");
      if (index < length - 1 && inputRefs.current[index + 1]) {
        var _inputRefs$current5;
        (_inputRefs$current5 = inputRefs.current[index + 1]) === null || _inputRefs$current5 === void 0 || _inputRefs$current5.focus();
      }
      if (onChange) onChange(value);
      if (onComplete && length === otp.length) onComplete(otp);
    }
  };
  const handlePaste = (e8) => {
    e8.preventDefault();
    const pastedData = e8.clipboardData.getData("text").slice(0, length);
    if (pastedData && /^\d+$/.test(pastedData)) {
      var _inputRefs$current6;
      const pastedOtp = pastedData.split("");
      const newOtpArray = [...otpArray];
      pastedOtp.forEach((key, index) => {
        newOtpArray[index] = key;
      });
      setOtpArray(newOtpArray);
      (_inputRefs$current6 = inputRefs.current[pastedOtp.length === length ? length - 1 : pastedOtp.length]) === null || _inputRefs$current6 === void 0 || _inputRefs$current6.focus();
      if (onComplete && length === newOtpArray.length) onComplete(newOtpArray.join(""));
    }
  };
  const handleResendClick = () => {
    setTimer(resendTimer || 0);
    if (onResendTimer) onResendTimer();
  };
  (0, import_react23.useEffect)(() => {
    let interval = null;
    if (showCta && showTimer) {
      interval = window.setInterval(() => {
        if (timer > 0) {
          setTimer((prev) => prev - 1);
        } else {
          clearInterval(interval);
        }
      }, 1e3);
    }
    return () => {
      clearInterval(interval);
    };
  }, [timer]);
  (0, import_react23.useEffect)(() => {
    if (inputRefs && autoFocus) {
      var _inputRefs$current7;
      (_inputRefs$current7 = inputRefs.current) === null || _inputRefs$current7 === void 0 || _inputRefs$current7[0].focus();
    }
  }, [autoFocus]);
  const helperTextClass = cn2("w3a--text-xs w3a--font-normal w3a--text-app-gray-500 dark:w3a--text-app-white w3a--mt-2", {
    "w3a--text-app-red-500 dark:w3a--text-app-red-400": error,
    "w3a--text-app-green-500 dark:w3a--text-app-green-400": success
  }, classes === null || classes === void 0 ? void 0 : classes.helperText);
  const inputKey = (/* @__PURE__ */ new Date()).getFullYear();
  return (0, import_jsx_runtime20.jsxs)("div", {
    className: cn2("w3a--flex w3a--flex-col w3a--items-center", classes === null || classes === void 0 ? void 0 : classes.root),
    ref,
    children: [(0, import_jsx_runtime20.jsx)("form", {
      className: cn2("w3a--flex w3a--space-x-2", classes === null || classes === void 0 ? void 0 : classes.inputContainer),
      children: otpArray.map((digit, index) => {
        var _classes$success, _classes$error, _classes$disabled;
        return (0, import_jsx_runtime20.jsx)("input", {
          id: `${inputKey + index}`,
          type,
          value: digit,
          autoComplete,
          placeholder: Array.isArray(placeholder) ? placeholder[index] : placeholder,
          inputMode: "numeric",
          onInput: (e8) => handleInputChange(e8, index),
          onKeyUp: (e8) => handleKeyDown(e8, index),
          onPaste: handlePaste,
          className: cn2("w3a--w-12 w3a--h-[42px] w3a--rounded-full w3a--border w3a--text-center w3a--text-xl w3a--focus:outline-none w3a--active:outline-none w3a--focus:border-app-primary-600 dark:w3a--focus:border-app-primary-500 w3a--border-app-gray-300 dark:w3a--border-app-gray-500 w3a--bg-app-gray-50 dark:w3a--bg-app-gray-700 w3a--text-app-gray-900 dark:w3a--text-app-white", success && ((_classes$success = classes === null || classes === void 0 ? void 0 : classes.success) !== null && _classes$success !== void 0 ? _classes$success : "w3a--border-app-green-400 dark:w3a--border-app-green-500 w3a--focus:w3a--border-app-green-400 dark:w3a--focus:w3a--border-app-green-500"), error && ((_classes$error = classes === null || classes === void 0 ? void 0 : classes.error) !== null && _classes$error !== void 0 ? _classes$error : "w3a--border-app-red-600 dark:w3a--border-app-red-500 w3a--focus:w3a--border-app-red-600 dark:w3a--focus:w3a--border-app-red-500"), disabled && ((_classes$disabled = classes === null || classes === void 0 ? void 0 : classes.disabled) !== null && _classes$disabled !== void 0 ? _classes$disabled : "w3a--border-app-gray-200 w3a--bg-app-gray-200 dark:w3a--border-app-gray-700 w3a--focus:w3a--border-app-gray-200 dark:w3a--focus:w3a--border-app-gray-700 w3a--cursor-not-allowed"), classes === null || classes === void 0 ? void 0 : classes.input),
          ref: (el2) => {
            inputRefs.current[index] = el2;
          },
          disabled
        }, `${inputKey + index}`);
      })
    }), helperText && (0, import_jsx_runtime20.jsx)("p", {
      className: helperTextClass,
      children: helperText
    }), loading && (0, import_jsx_runtime20.jsx)("div", {
      className: "w3a--mt-3",
      children: (0, import_jsx_runtime20.jsx)(PulseLoader, {})
    }), showCta && !loading && (0, import_jsx_runtime20.jsx)("div", {
      className: cn2("w3a--flex w3a--items-center w3a--mt-3", classes === null || classes === void 0 ? void 0 : classes.ctaContainer),
      children: timer > 0 && showTimer ? (0, import_jsx_runtime20.jsx)("span", {
        className: cn2("w3a--text-xs w3a--text-app-gray-500 dark:w3a--text-app-gray-400", classes === null || classes === void 0 ? void 0 : classes.timerText),
        children: t3("modal.resendTimer", {
          timer
        })
      }) : (0, import_jsx_runtime20.jsx)("button", {
        type: "button",
        className: cn2("w3a--text-xs w3a--p-0 w3a--text-app-primary-600 dark:w3a--text-app-primary-500", classes === null || classes === void 0 ? void 0 : classes.resendBtnText),
        onClick: handleResendClick,
        disabled: timer > 0 && showTimer,
        children: resendBtnText || t3("modal.resendCode")
      })
    })]
  });
});
OtpInput.displayName = "OtpInput";

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Login/LoginOtp/LoginOtp.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
function OtpInput2(props) {
  const {
    setShowOtpFlow,
    handleOtpComplete,
    authConnection,
    loginHint = "",
    errorMessage,
    otpLoading,
    countryFlag
  } = props;
  const isMobileOtp = (0, import_react24.useMemo)(() => authConnection === AUTH_CONNECTION.SMS_PASSWORDLESS, [authConnection]);
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const parsedLoginHint = (0, import_react24.useMemo)(() => {
    if (authConnection === AUTH_CONNECTION.EMAIL_PASSWORDLESS) return loginHint;
    const [countryCode, number] = loginHint.includes("-") ? loginHint.split("-") : ["", loginHint];
    const masked = `${number}`.slice(-Math.floor(number.length / 2)).padStart(`${number}`.length, "*");
    return `${countryFlag} ${countryCode} ${masked}`;
  }, [loginHint, authConnection, countryFlag]);
  return (0, import_jsx_runtime21.jsxs)(import_jsx_runtime21.Fragment, {
    children: [(0, import_jsx_runtime21.jsx)("div", {
      className: "w3a--mr-auto w3a--flex w3a--w-full w3a--items-start w3a--justify-start",
      children: (0, import_jsx_runtime21.jsx)("button", {
        type: "button",
        className: "w3a--z-20 w3a--flex w3a--size-5 w3a--cursor-pointer w3a--items-center w3a--justify-center w3a--rounded-full",
        onClick: () => setShowOtpFlow(false),
        children: (0, import_jsx_runtime21.jsx)("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          fill: "none",
          viewBox: "0 0 20 20",
          className: "w3a--text-app-gray-900 dark:w3a--text-app-white",
          children: (0, import_jsx_runtime21.jsx)("path", {
            fill: "currentColor",
            fillRule: "evenodd",
            d: "M9.707 16.707a1 1 0 0 1-1.414 0l-6-6a1 1 0 0 1 0-1.414l6-6a1 1 0 0 1 1.414 1.414L5.414 9H17a1 1 0 1 1 0 2H5.414l4.293 4.293a1 1 0 0 1 0 1.414",
            clipRule: "evenodd"
          })
        })
      })
    }), (0, import_jsx_runtime21.jsxs)("div", {
      className: "-w3a--mt-10 w3a--flex w3a--size-full w3a--flex-1 w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-4",
      children: [(0, import_jsx_runtime21.jsx)("img", {
        src: getIcons(isMobileOtp ? "sms-otp-light" : "email-otp-light"),
        alt: "otp",
        className: "w3a--size-auto"
      }), (0, import_jsx_runtime21.jsxs)("div", {
        className: "w3a--mx-auto -w3a--mt-6 w3a--flex w3a--w-full w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-2",
        children: [(0, import_jsx_runtime21.jsx)("p", {
          className: "w3a--text-lg w3a--font-bold w3a--text-app-gray-900 dark:w3a--text-app-white",
          children: isMobileOtp ? t3("modal.otp.mobile-title") : t3("modal.otp.email-title")
        }), (0, import_jsx_runtime21.jsxs)("div", {
          className: "w3a--mx-auto w3a--flex w3a--w-full w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-1",
          children: [(0, import_jsx_runtime21.jsx)("p", {
            className: "w3a--text-center w3a--text-sm w3a--font-normal w3a--text-app-gray-500 dark:w3a--text-app-gray-300",
            children: isMobileOtp ? t3("modal.otp.mobile-subtext") : t3("modal.otp.email-subtext")
          }), (0, import_jsx_runtime21.jsx)("p", {
            className: "w3a--text-center w3a--text-sm w3a--font-normal w3a--text-app-gray-500 dark:w3a--text-app-gray-300",
            children: isMobileOtp ? parsedLoginHint : t3("modal.otp.email-subtext-example", {
              email: parsedLoginHint
            })
          })]
        })]
      }), (0, import_jsx_runtime21.jsx)(OtpInput, {
        length: 6,
        onComplete: handleOtpComplete,
        error: Boolean(errorMessage),
        helperText: errorMessage,
        loading: otpLoading,
        disabled: otpLoading
      })]
    })]
  });
}
function LoginOtp(props) {
  const {
    otpLoading,
    setShowOtpFlow,
    handleOtpComplete,
    authConnection,
    loginHint,
    errorMessage,
    countryFlag
  } = props;
  return (0, import_jsx_runtime21.jsx)("div", {
    className: "w3a--flex w3a--size-full w3a--flex-1 w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-4",
    children: (0, import_jsx_runtime21.jsx)(OtpInput2, {
      errorMessage,
      setShowOtpFlow,
      handleOtpComplete,
      authConnection,
      loginHint,
      otpLoading,
      countryFlag
    })
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Login/LoginPasswordLess/LoginPasswordLess.js
var import_react25 = __toESM(require_react());
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
function LoginPasswordLess(props) {
  const {
    isModalVisible,
    isPasswordLessCtaClicked,
    setIsPasswordLessCtaClicked,
    title,
    placeholder,
    handleFormSubmit,
    errorMessage,
    isDark,
    isPasswordLessLoading,
    buttonRadius
  } = props;
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const inputRef = (0, import_react25.useRef)(null);
  const [inputValue, setInputValue] = (0, import_react25.useState)("");
  const [isInputFocused, setIsInputFocused] = (0, import_react25.useState)(false);
  const onInputChange = (e8) => {
    setInputValue(e8.target.value);
    setIsInputFocused(true);
  };
  const handleEnter = (e8) => {
    const {
      key
    } = e8;
    if (key === "Enter") {
      handleFormSubmit(inputValue);
      setIsInputFocused(false);
    }
  };
  const onFormSubmit = (e8) => {
    e8.preventDefault();
    e8.stopPropagation();
    handleFormSubmit(inputValue);
    setIsInputFocused(false);
  };
  (0, import_react25.useEffect)(() => {
    if (!isModalVisible) {
      setIsPasswordLessCtaClicked(false);
    }
  }, [isModalVisible, setIsPasswordLessCtaClicked]);
  (0, import_react25.useEffect)(() => {
    if (isPasswordLessCtaClicked) {
      var _inputRef$current;
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
    }
  }, [isPasswordLessCtaClicked]);
  if (!isPasswordLessCtaClicked) {
    return (0, import_jsx_runtime22.jsxs)("button", {
      type: "button",
      className: cn2("w3a--btn !w3a--justify-between w3a--relative w3a--group w3a--overflow-hidden", {
        "w3a--rounded-full": buttonRadius === "pill",
        "w3a--rounded-lg": buttonRadius === "rounded",
        "w3a--rounded-none": buttonRadius === "square"
      }),
      onClick: () => {
        setIsPasswordLessCtaClicked(true);
      },
      children: [(0, import_jsx_runtime22.jsx)("p", {
        className: "w3a--text-app-gray-900 dark:w3a--text-app-white",
        children: t3("modal.passwordless.title", {
          title
        })
      }), (0, import_jsx_runtime22.jsx)("img", {
        id: "passwordless-arrow",
        className: "w3a--absolute w3a--right-4 w3a--top-1/2 -w3a--translate-x-6 -w3a--translate-y-1/2 w3a--opacity-0 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-0 group-hover:w3a--opacity-100",
        src: getIcons(isDark ? "chevron-right-dark" : "chevron-right-light"),
        alt: "arrow"
      })]
    });
  }
  return (0, import_jsx_runtime22.jsxs)(import_jsx_runtime22.Fragment, {
    children: [(0, import_jsx_runtime22.jsxs)("div", {
      className: cn2("w3a--input", isInputFocused && "!w3a--border-app-primary-600", {
        "w3a--rounded-full": buttonRadius === "pill",
        "w3a--rounded-lg": buttonRadius === "rounded",
        "w3a--rounded-none": buttonRadius === "square"
      }),
      children: [(0, import_jsx_runtime22.jsx)("input", {
        ref: inputRef,
        onInput: onInputChange,
        value: inputValue,
        placeholder,
        onFocus: () => {
          setIsInputFocused(true);
        },
        onBlur: (e8) => {
          e8.target.placeholder = `${placeholder}`;
          setIsInputFocused(false);
        },
        type: "text",
        className: cn2("w3a--w-full w3a--appearance-none w3a--bg-transparent w3a--text-app-gray-900 w3a--outline-none placeholder:w3a--text-xs placeholder:w3a--text-app-gray-400 focus:w3a--outline-none active:w3a--outline-none dark:w3a--text-app-white dark:placeholder:w3a--text-app-gray-500"),
        onKeyDown: (e8) => handleEnter(e8),
        disabled: isPasswordLessLoading
      }), isPasswordLessLoading && (0, import_jsx_runtime22.jsx)(PulseLoader, {}), inputValue && !isPasswordLessLoading && (0, import_jsx_runtime22.jsx)("button", {
        type: "button",
        className: "w3a--appearance-none",
        onClick: onFormSubmit,
        children: (0, import_jsx_runtime22.jsx)("img", {
          src: getIcons(isDark ? "chevron-right-dark" : "chevron-right-light"),
          alt: "arrow"
        })
      })]
    }), errorMessage && !isInputFocused && isPasswordLessCtaClicked && (0, import_jsx_runtime22.jsx)("p", {
      className: "w3a--w-full w3a--pl-6 w3a--text-start w3a--text-xs w3a--font-normal w3a--text-app-red-500 dark:w3a--text-app-red-400",
      children: errorMessage
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Login/Login.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var restrictedLoginMethods2 = [AUTH_CONNECTION.SMS_PASSWORDLESS, AUTH_CONNECTION.EMAIL_PASSWORDLESS, AUTH_CONNECTION.AUTHENTICATOR, AUTH_CONNECTION.PASSKEYS, AUTH_CONNECTION.TELEGRAM, AUTH_CONNECTION.CUSTOM];
function Login(props) {
  const {
    web3authClientId,
    web3authNetwork,
    authBuildEnv,
    appLogo,
    isModalVisible,
    handleSocialLoginHeight,
    socialLoginsConfig,
    installedExternalWalletConfig,
    isDark,
    handleSocialLoginClick,
    totalExternalWallets,
    isEmailPasswordLessLoginVisible,
    isSmsPasswordLessLoginVisible,
    handleExternalWalletBtnClick,
    handleExternalWalletClick,
    areSocialLoginsVisible,
    showPasswordLessInput,
    showExternalWalletButton,
    showExternalWalletCount,
    showInstalledExternalWallets,
    logoAlignment = "center",
    buttonRadius = "pill",
    deviceDetails
  } = props;
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const {
    bodyState,
    setBodyState
  } = (0, import_react26.useContext)(RootContext);
  const {
    analytics
  } = (0, import_react26.useContext)(AnalyticsContext);
  const [countryCode, setCountryCode] = (0, import_react26.useState)("");
  const [countryFlag, setCountryFlag] = (0, import_react26.useState)("");
  const [passwordlessErrorMessage, setPasswordlessErrorMessage] = (0, import_react26.useState)("");
  const [otpErrorMessage, setOtpErrorMessage] = (0, import_react26.useState)("");
  const [expand, setExpand] = (0, import_react26.useState)(false);
  const [canShowMore, setCanShowMore] = (0, import_react26.useState)(false);
  const [visibleRow, setVisibleRow] = (0, import_react26.useState)([]);
  const [otherRow, setOtherRow] = (0, import_react26.useState)([]);
  const [isPasswordLessCtaClicked, setIsPasswordLessCtaClicked] = (0, import_react26.useState)(false);
  const [showOtpFlow, setShowOtpFlow] = (0, import_react26.useState)(false);
  const [authConnection, setAuthConnection] = (0, import_react26.useState)(void 0);
  const [passwordlessHandler, setPasswordlessHandler] = (0, import_react26.useState)(void 0);
  const [isPasswordLessLoading, setIsPasswordLessLoading] = (0, import_react26.useState)(false);
  const [otpLoading, setOtpLoading] = (0, import_react26.useState)(false);
  const [showCaptcha, setShowCaptcha] = (0, import_react26.useState)(false);
  const [captchaError, setCaptchaError] = (0, import_react26.useState)("");
  const captchaRef = (0, import_react26.useRef)(null);
  const handleExpand = () => {
    setExpand((prev) => !prev);
    setIsPasswordLessCtaClicked(false);
    handleSocialLoginHeight();
  };
  (0, import_react26.useEffect)(() => {
    const maxOptions = Object.keys(socialLoginsConfig.loginMethods).filter((loginMethodKey) => {
      return socialLoginsConfig.loginMethods[loginMethodKey].showOnModal;
    });
    const visibleRows = [];
    const otherRows = [];
    const loginMethodsOrder = (socialLoginsConfig.loginMethodsOrder || []).reduce((acc, method, index) => {
      acc[method] = index;
      return acc;
    }, {});
    const loginOptions = Object.keys(socialLoginsConfig.loginMethods).filter((method) => {
      return !socialLoginsConfig.loginMethods[method].showOnModal === false && !restrictedLoginMethods2.includes(method);
    }).sort((a, b3) => {
      var _loginMethodsOrder$a, _loginMethodsOrder$b;
      const maxOrder = (socialLoginsConfig.loginMethodsOrder || []).length;
      const aOrder = (_loginMethodsOrder$a = loginMethodsOrder[a]) !== null && _loginMethodsOrder$a !== void 0 ? _loginMethodsOrder$a : maxOrder;
      const bOrder = (_loginMethodsOrder$b = loginMethodsOrder[b3]) !== null && _loginMethodsOrder$b !== void 0 ? _loginMethodsOrder$b : maxOrder;
      const {
        mainOption: aMainOption
      } = socialLoginsConfig.loginMethods[a] || {};
      const {
        mainOption: bMainOption
      } = socialLoginsConfig.loginMethods[b3] || {};
      if (aMainOption && bMainOption) {
        return aOrder - bOrder;
      }
      if (aMainOption) return -1;
      if (bMainOption) return 1;
      return aOrder - bOrder;
    });
    loginOptions.forEach((method, index) => {
      var _socialLoginsConfig$u;
      const connectorConfig = socialLoginsConfig.loginMethods[method];
      const name = capitalizeFirstLetter(connectorConfig.name || method);
      const order = index + 1;
      const isPrimaryBtn = (socialLoginsConfig === null || socialLoginsConfig === void 0 || (_socialLoginsConfig$u = socialLoginsConfig.uiConfig) === null || _socialLoginsConfig$u === void 0 ? void 0 : _socialLoginsConfig$u.primaryButton) === "socialLogin" && order === 1;
      const loginOptionLength = loginOptions.length;
      const moreThanFour = loginOptionLength >= 4;
      const lengthCheck = moreThanFour ? order > 0 && order <= loginOptionLength : order > 0 && order < 4;
      if (lengthCheck) {
        visibleRows.push({
          method,
          isDark,
          isPrimaryBtn,
          name,
          connector: socialLoginsConfig.connector,
          loginParams: {
            authConnection: connectorConfig.authConnection || method,
            authConnectionId: connectorConfig.authConnectionId,
            groupedAuthConnectionId: connectorConfig.groupedAuthConnectionId,
            extraLoginOptions: connectorConfig.extraLoginOptions,
            name,
            login_hint: ""
          },
          order
        });
      }
      otherRows.push({
        method,
        isDark,
        isPrimaryBtn,
        name: name === "Twitter" ? "X" : name,
        connector: socialLoginsConfig.connector,
        loginParams: {
          authConnection: method,
          authConnectionId: connectorConfig.authConnectionId,
          groupedAuthConnectionId: connectorConfig.groupedAuthConnectionId,
          extraLoginOptions: connectorConfig.extraLoginOptions,
          name,
          login_hint: ""
        },
        order
      });
    });
    setVisibleRow(visibleRows);
    setOtherRow(otherRows);
    setCanShowMore(maxOptions.length > 4);
  }, [socialLoginsConfig, isDark, buttonRadius]);
  const handleCustomLogin = async (authConnection2, loginHint) => {
    try {
      const handler = createPasswordlessHandler(authConnection2, {
        loginHint,
        web3authClientId,
        network: web3authNetwork,
        uiConfig: socialLoginsConfig.uiConfig,
        authConnection: authConnection2,
        authBuildEnv
      });
      let token = void 0;
      if (!isTestAccountPattern(authConnection2, loginHint)) {
        var _captchaRef$current;
        const res = await ((_captchaRef$current = captchaRef.current) === null || _captchaRef$current === void 0 ? void 0 : _captchaRef$current.execute({
          async: true
        }));
        if (!res) {
          throw WalletLoginError.connectionError("Captcha token is required");
        }
        token = res.response;
      }
      const result = await handler.sendVerificationCode({
        captchaToken: token
      });
      if (result !== null && result !== void 0 && result.error) {
        setPasswordlessErrorMessage(t3(result.error));
        return;
      }
      setAuthConnection(authConnection2);
      setShowOtpFlow(true);
      setPasswordlessHandler(handler);
    } catch (error) {
      log.error(error);
    } finally {
      setIsPasswordLessLoading(false);
    }
  };
  const handleFormSubmit = async (loginHint) => {
    setIsPasswordLessLoading(true);
    if (isEmailPasswordLessLoginVisible) {
      const isEmailValid = loginHint.match(/^([\w.%+-]+)@([\w-]+\.)+([\w]{2,})$/i);
      if (isEmailValid) {
        const connectorConfig = socialLoginsConfig.loginMethods[AUTH_CONNECTION.EMAIL_PASSWORDLESS];
        if (connectorConfig.isDefault) {
          return handleSocialLoginClick({
            connector: socialLoginsConfig.connector,
            loginParams: {
              authConnection: AUTH_CONNECTION.EMAIL_PASSWORDLESS,
              authConnectionId: connectorConfig.authConnectionId,
              groupedAuthConnectionId: connectorConfig.groupedAuthConnectionId,
              extraLoginOptions: connectorConfig.extraLoginOptions,
              loginHint,
              name: "Email"
            }
          });
        } else {
          return handleCustomLogin(AUTH_CONNECTION.EMAIL_PASSWORDLESS, loginHint);
        }
      }
    }
    if (isSmsPasswordLessLoginVisible) {
      const number = loginHint.startsWith("+") ? loginHint : `${countryCode}${loginHint}`;
      const result = await validatePhoneNumber(number);
      if (result.success) {
        const finalLoginHint = typeof result.parsed_number === "string" ? result.parsed_number : number;
        const connectorConfig = socialLoginsConfig.loginMethods[AUTH_CONNECTION.SMS_PASSWORDLESS];
        if (connectorConfig.isDefault) {
          return handleSocialLoginClick({
            connector: socialLoginsConfig.connector,
            loginParams: {
              authConnection: AUTH_CONNECTION.SMS_PASSWORDLESS,
              authConnectionId: connectorConfig.authConnectionId,
              groupedAuthConnectionId: connectorConfig.groupedAuthConnectionId,
              extraLoginOptions: connectorConfig.extraLoginOptions,
              loginHint: finalLoginHint,
              name: "Mobile"
            }
          });
        } else {
          setCountryFlag(result.country_flag);
          return handleCustomLogin(AUTH_CONNECTION.SMS_PASSWORDLESS, finalLoginHint);
        }
      }
    }
    setPasswordlessErrorMessage(invalidInputErrorMessage);
    setIsPasswordLessLoading(false);
    return void 0;
  };
  const title = (0, import_react26.useMemo)(() => {
    if (isEmailPasswordLessLoginVisible && isSmsPasswordLessLoginVisible) return t3("modal.social.passwordless-title");
    if (isEmailPasswordLessLoginVisible) return t3("modal.social.email");
    return t3("modal.social.phone");
  }, [isEmailPasswordLessLoginVisible, isSmsPasswordLessLoginVisible, t3]);
  const placeholder = (0, import_react26.useMemo)(() => {
    if (isEmailPasswordLessLoginVisible && isSmsPasswordLessLoginVisible) return "+(00)123456/name@example.com";
    if (isEmailPasswordLessLoginVisible) return "name@example.com";
    return "+(00)123456";
  }, [isEmailPasswordLessLoginVisible, isSmsPasswordLessLoginVisible]);
  const invalidInputErrorMessage = (0, import_react26.useMemo)(() => {
    if (isEmailPasswordLessLoginVisible && isSmsPasswordLessLoginVisible) return t3("modal.errors-invalid-number-email");
    if (isEmailPasswordLessLoginVisible) return t3("modal.errors-invalid-email");
    return t3("modal.errors-invalid-number");
  }, [isEmailPasswordLessLoginVisible, isSmsPasswordLessLoginVisible, t3]);
  (0, import_react26.useEffect)(() => {
    const getLocation = async () => {
      const result = await getUserCountry();
      if (result && result.dialCode) {
        setCountryCode(result.dialCode);
      }
    };
    if (isSmsPasswordLessLoginVisible) getLocation();
  }, [isSmsPasswordLessLoginVisible]);
  const handleConnectWallet = (e8) => {
    analytics === null || analytics === void 0 || analytics.track(ANALYTICS_EVENTS.EXTERNAL_WALLET_LIST_EXPANDED, {
      total_external_wallets: totalExternalWallets,
      installed_external_wallets: installedExternalWallets.length
    });
    setIsPasswordLessCtaClicked(false);
    e8.preventDefault();
    if (handleExternalWalletBtnClick) handleExternalWalletBtnClick(true);
  };
  const handleOtpComplete = async (otp) => {
    setOtpLoading(true);
    if (otpErrorMessage) setOtpErrorMessage("");
    try {
      var _result$data;
      const connectorConfig = socialLoginsConfig.loginMethods[authConnection];
      const result = await (passwordlessHandler === null || passwordlessHandler === void 0 ? void 0 : passwordlessHandler.verifyCode(otp));
      if (result !== null && result !== void 0 && result.error) {
        setOtpErrorMessage(t3(result.error));
        return;
      }
      if (result !== null && result !== void 0 && (_result$data = result.data) !== null && _result$data !== void 0 && _result$data.id_token) {
        var _result$data2;
        return handleSocialLoginClick({
          connector: socialLoginsConfig.connector,
          loginParams: {
            authConnection,
            authConnectionId: connectorConfig.authConnectionId,
            groupedAuthConnectionId: connectorConfig.groupedAuthConnectionId,
            extraLoginOptions: _objectSpread2(_objectSpread2({}, connectorConfig.extraLoginOptions), {}, {
              id_token: (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : _result$data2.id_token
            }),
            loginHint: passwordlessHandler.passwordlessParams.loginHint,
            name: passwordlessHandler.name
          }
        });
      }
    } catch (error) {
      log.error(error);
    } finally {
      setOtpLoading(false);
    }
  };
  const handleInstalledWalletClick = (wallet) => {
    var _wallet$chainNamespac;
    analytics === null || analytics === void 0 || analytics.track(ANALYTICS_EVENTS.EXTERNAL_WALLET_SELECTED, {
      connector: wallet.name,
      wallet_name: wallet.displayName,
      is_installed: wallet.isInstalled,
      is_injected: wallet.hasInjectedWallet,
      chain_namespaces: wallet.chainNamespaces,
      has_wallet_connect: wallet.hasWalletConnect,
      has_install_links: wallet.hasInstallLinks,
      has_wallet_registry_item: !!wallet.walletRegistryItem,
      total_external_wallets: totalExternalWallets
    });
    if (wallet.name === WALLET_CONNECTORS.METAMASK && !wallet.hasInjectedWallet && deviceDetails.platform === "desktop") {
      handleExternalWalletClick({
        connector: wallet.name
      });
      setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
        metamaskQrCode: {
          show: true,
          wallet
        }
      }));
      return;
    }
    if (((_wallet$chainNamespac = wallet.chainNamespaces) === null || _wallet$chainNamespac === void 0 ? void 0 : _wallet$chainNamespac.length) > 1) {
      setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
        multiChainSelector: {
          show: true,
          wallet
        }
      }));
    } else {
      handleExternalWalletClick({
        connector: wallet.name
      });
    }
  };
  const installedExternalWallets = (0, import_react26.useMemo)(() => {
    if (showInstalledExternalWallets) return installedExternalWalletConfig;
    return installedExternalWalletConfig.filter((wallet) => wallet.name === WALLET_CONNECTORS.METAMASK);
  }, [installedExternalWalletConfig, showInstalledExternalWallets]);
  if (showOtpFlow) {
    return (0, import_jsx_runtime23.jsx)(LoginOtp, {
      otpLoading,
      loginHint: passwordlessHandler === null || passwordlessHandler === void 0 ? void 0 : passwordlessHandler.passwordlessParams.loginHint,
      setShowOtpFlow,
      authConnection,
      handleOtpComplete,
      errorMessage: otpErrorMessage,
      countryFlag
    });
  }
  const socialLoginSection = (otherRow2 = []) => {
    return (0, import_jsx_runtime23.jsx)(SocialLoginList, {
      otherRow: otherRow2,
      isDark,
      visibleRow,
      canShowMore,
      handleSocialLoginClick,
      socialLoginsConfig,
      handleExpandSocialLogins: handleExpand,
      buttonRadius
    }, "social-login-section");
  };
  const passwordlessLoginSection = () => {
    return (0, import_jsx_runtime23.jsx)(LoginPasswordLess, {
      isModalVisible,
      isPasswordLessCtaClicked,
      setIsPasswordLessCtaClicked,
      title,
      placeholder,
      handleFormSubmit,
      errorMessage: passwordlessErrorMessage,
      isDark,
      buttonRadius,
      isPasswordLessLoading
    }, "passwordless-section");
  };
  const externalWalletSection = () => {
    return (0, import_jsx_runtime23.jsxs)("div", {
      className: cn2("w3a--flex w3a--w-full w3a--flex-col w3a--items-start w3a--justify-start w3a--gap-y-2"),
      children: [installedExternalWallets.length > 0 && installedExternalWallets.map((wallet) => (0, import_jsx_runtime23.jsxs)("button", {
        type: "button",
        className: cn2("w3a--btn !w3a--justify-between w3a--group w3a--relative w3a--overflow-hidden", {
          "w3a--rounded-full": buttonRadius === "pill",
          "w3a--rounded-lg": buttonRadius === "rounded",
          "w3a--rounded-none": buttonRadius === "square"
        }),
        onClick: () => handleInstalledWalletClick(wallet),
        children: [(0, import_jsx_runtime23.jsx)("p", {
          className: "w3a--max-w-[180px] w3a--truncate w3a--text-base w3a--font-normal w3a--text-app-gray-700 dark:w3a--text-app-white",
          children: wallet.displayName
        }), (0, import_jsx_runtime23.jsxs)("div", {
          className: "w3a--absolute w3a--right-4 w3a--top-1/2 w3a--flex w3a--w-auto -w3a--translate-y-1/2 w3a--items-center w3a--gap-x-2 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-6 group-hover:w3a--opacity-0",
          children: [wallet.hasInjectedWallet && (0, import_jsx_runtime23.jsx)("span", {
            className: "w3a--inline-flex w3a--items-center w3a--rounded-md w3a--bg-app-primary-100 w3a--px-2 w3a--py-1 w3a--text-xs w3a--font-medium w3a--text-app-primary-800  dark:w3a--border dark:w3a--border-app-primary-400 dark:w3a--bg-transparent dark:w3a--text-app-primary-400",
            children: t3("modal.external.installed")
          }), (0, import_jsx_runtime23.jsx)("figure", {
            className: "w3a--size-5",
            children: (0, import_jsx_runtime23.jsx)(Image2, {
              imageData: wallet.icon,
              imageId: `login-${wallet.name}`,
              hoverImageId: `login-${wallet.name}`,
              fallbackImageId: "wallet",
              height: "24",
              width: "24",
              isButton: true,
              extension: wallet.imgExtension || "webp"
            })
          })]
        }), (0, import_jsx_runtime23.jsx)("img", {
          id: "injected-wallet-arrow",
          className: "w3a--absolute w3a--right-4 w3a--top-1/2 -w3a--translate-x-10 -w3a--translate-y-1/2 w3a--opacity-0 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-0 group-hover:w3a--opacity-100",
          src: getIcons(isDark ? "chevron-right-dark" : "chevron-right-light"),
          alt: "arrow"
        })]
      }, wallet.name)), totalExternalWallets > 3 && (0, import_jsx_runtime23.jsxs)("button", {
        type: "button",
        className: cn2("w3a--btn !w3a--justify-between w3a--group w3a--relative w3a--overflow-hidden", {
          "w3a--rounded-full": buttonRadius === "pill",
          "w3a--rounded-lg": buttonRadius === "rounded",
          "w3a--rounded-none": buttonRadius === "square"
        }),
        onClick: handleConnectWallet,
        children: [(0, import_jsx_runtime23.jsx)("p", {
          className: "w3a--text-base w3a--font-normal w3a--text-app-gray-900 dark:w3a--text-app-white",
          children: t3("modal.external.all-wallets")
        }), showExternalWalletCount && totalExternalWallets > 0 && (0, import_jsx_runtime23.jsx)("div", {
          id: "external-wallet-count",
          className: "w3a--absolute w3a--right-4 w3a--top-1/2 w3a--w-auto -w3a--translate-y-1/2 w3a--rounded-full w3a--bg-app-primary-100 w3a--px-2.5 w3a--py-0.5 w3a--text-xs w3a--font-medium w3a--text-app-primary-800 w3a--transition-all w3a--delay-300 w3a--duration-300 group-hover:w3a--translate-x-6 group-hover:w3a--opacity-0 group-hover:w3a--delay-0 dark:w3a--border dark:w3a--border-app-primary-500 dark:w3a--bg-transparent dark:w3a--text-app-primary-500",
          children: totalExternalWallets - 1
        }), (0, import_jsx_runtime23.jsx)("img", {
          id: "external-wallet-arrow",
          className: "w3a--absolute w3a--right-4 w3a--top-1/2 -w3a--translate-x-10 -w3a--translate-y-1/2 w3a--opacity-0 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-0 group-hover:w3a--opacity-100",
          src: getIcons(isDark ? "chevron-right-dark" : "chevron-right-light"),
          alt: "arrow"
        })]
      })]
    }, "external-wallets-section");
  };
  const headerLogo = [DEFAULT_LOGO_DARK, DEFAULT_LOGO_LIGHT].includes(appLogo) ? "" : appLogo;
  const delimiter = (index) => {
    return (0, import_jsx_runtime23.jsxs)("div", {
      className: cn2("w3a--flex w3a--w-full w3a--items-center w3a--gap-x-2", headerLogo ? "w3a--my-2" : "w3a--my-4"),
      children: [(0, import_jsx_runtime23.jsx)("div", {
        className: "w3a--h-px w3a--w-full w3a--bg-app-gray-200 dark:w3a--bg-app-gray-500"
      }), (0, import_jsx_runtime23.jsx)("p", {
        className: "w3a--text-xs w3a--font-normal w3a--uppercase w3a--text-app-gray-400 dark:w3a--text-app-gray-400",
        children: "or"
      }), (0, import_jsx_runtime23.jsx)("div", {
        className: "w3a--h-px w3a--w-full w3a--bg-app-gray-200 dark:w3a--bg-app-gray-500"
      })]
    }, `section-delimiter-${index}`);
  };
  const defaultView = () => {
    var _socialLoginsConfig$u2;
    const sectionMap = {
      social: socialLoginSection,
      passwordless: passwordlessLoginSection,
      externalWallets: externalWalletSection
    };
    const sectionVisibility = {
      social: areSocialLoginsVisible,
      passwordless: showPasswordLessInput,
      externalWallets: showExternalWalletButton
    };
    const signInMethods = ((_socialLoginsConfig$u2 = socialLoginsConfig.uiConfig) === null || _socialLoginsConfig$u2 === void 0 ? void 0 : _socialLoginsConfig$u2.signInMethods) || ["social", "passwordless", "externalWallets"];
    Object.entries(sectionVisibility).forEach(([method, visibility]) => {
      if (visibility && !signInMethods.includes(method)) {
        signInMethods.push(method);
      }
    });
    const sections = signInMethods.map((method) => sectionVisibility[method] && sectionMap[method]()).filter(Boolean);
    if (sections.length === 3) {
      const externalWalletIndex = signInMethods.findIndex((section) => section === "externalWallets");
      if (externalWalletIndex === 0) {
        sections.splice(1, 0, delimiter(1));
      } else if (externalWalletIndex === 1) {
        sections.splice(1, 0, delimiter(1));
        sections.splice(3, 0, delimiter(2));
      } else if (externalWalletIndex === 2) {
        sections.splice(2, 0, delimiter(1));
      }
    } else if (sections.length === 2) {
      if (sectionVisibility["externalWallets"]) {
        sections.splice(1, 0, delimiter(1));
      }
    }
    return sections;
  };
  const expandedView = () => socialLoginSection(otherRow);
  return (0, import_jsx_runtime23.jsxs)("div", {
    className: "w3a--flex w3a--flex-col w3a--items-center w3a--gap-y-4 w3a--p-2",
    children: [(0, import_jsx_runtime23.jsxs)("div", {
      className: cn2("w3a--flex w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-2 w3a--pt-6", logoAlignment === "center" ? "" : "w3a--w-full"),
      children: [headerLogo && (0, import_jsx_runtime23.jsx)("figure", {
        className: cn2("w3a--mx-auto w3a--h-12 w3a--w-[200px]", logoAlignment === "center" ? "w3a--flex w3a--justify-center w3a--items-center" : "w3a--ml-0 w3a--w-auto"),
        children: (0, import_jsx_runtime23.jsx)("img", {
          src: headerLogo,
          alt: "Logo",
          className: "w3a--size-full w3a--object-contain"
        })
      }), (0, import_jsx_runtime23.jsx)("p", {
        className: cn2("w3a--text-app-gray-900 dark:w3a--text-app-white", logoAlignment === "center" ? "w3a--text-center" : "w3a--text-left w3a--w-full w3a--ml-4", headerLogo ? "w3a--text-lg w3a--font-semibold" : "w3a--text-3xl w3a--font-medium"),
        children: t3("modal.social.sign-in")
      })]
    }), (0, import_jsx_runtime23.jsx)(esm_default, {
      ref: captchaRef,
      sitekey: CAPTCHA_SITE_KEY,
      size: "invisible",
      languageOverride: socialLoginsConfig.uiConfig.defaultLanguage,
      theme: socialLoginsConfig.uiConfig.theme,
      onOpen: () => setShowCaptcha(true),
      onClose: () => setShowCaptcha(false),
      onError: () => setCaptchaError("passwordless.captcha-default-error"),
      onChalExpired: () => setCaptchaError("passwordless.captcha-default-error")
    }), captchaError && showCaptcha && (0, import_jsx_runtime23.jsx)("p", {
      className: "-w3a--mt-2 w3a--w-full w3a--pl-6 w3a--text-start w3a--text-xs w3a--font-normal w3a--text-app-red-500 dark:w3a--text-app-red-400",
      children: t3(captchaError)
    }), !showCaptcha && (0, import_jsx_runtime23.jsxs)("div", {
      className: "w3a--flex w3a--w-full w3a--flex-col w3a--items-center w3a--justify-center w3a--gap-y-2",
      children: [!expand && defaultView(), expand && expandedView()]
    })]
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Toast/Toast.js
var import_react27 = __toESM(require_react());
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var Toast = () => {
  const {
    toast,
    setToast
  } = (0, import_react27.useContext)(RootContext);
  (0, import_react27.useEffect)(() => {
    if (toast.message) {
      setTimeout(() => {
        setToast({
          message: "",
          type: TOAST_TYPE.SUCCESS
        });
      }, 3e3);
    }
  }, [toast.message, setToast]);
  if (!toast.message) return null;
  const toastClass = {
    success: "w3a--border-app-green-200 w3a--bg-app-green-100 w3a--text-app-green-900",
    error: "w3a--border-app-red-200 w3a--bg-app-red-100 w3a--text-app-red-900",
    warning: "w3a--border-app-yellow-200 w3a--bg-app-yellow-100 w3a--text-app-yellow-900",
    info: "w3a--border-app-blue-200 w3a--bg-app-blue-100 w3a--text-app-blue-900"
  };
  const toastIconClass = {
    success: "w3a--text-app-green-900",
    error: "w3a--text-app-red-900",
    warning: "w3a--text-app-yellow-900",
    info: "w3a--text-app-blue-900"
  };
  return (0, import_jsx_runtime24.jsxs)("div", {
    className: `w3a--absolute w3a--inset-x-4 w3a--bottom-4 w3a--z-[60] w3a--mx-auto w3a--w-[90%] w3a--rounded-md w3a--border w3a--p-4 w3a--text-sm ${toastClass[toast.type]}`,
    children: [(0, import_jsx_runtime24.jsx)("div", {
      className: "w3a--absolute w3a--right-4 w3a--top-4 w3a--z-10 w3a--cursor-pointer",
      children: (0, import_jsx_runtime24.jsx)("svg", {
        width: "13",
        height: "13",
        viewBox: "0 0 13 13",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        onClick: () => setToast({
          message: "",
          type: TOAST_TYPE.SUCCESS
        }),
        className: toastIconClass[toast.type],
        children: (0, import_jsx_runtime24.jsx)("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M0.292787 1.29299C0.480314 1.10552 0.734622 1.0002 0.999786 1.0002C1.26495 1.0002 1.51926 1.10552 1.70679 1.29299L5.99979 5.58599L10.2928 1.29299C10.385 1.19748 10.4954 1.1213 10.6174 1.06889C10.7394 1.01648 10.8706 0.988893 11.0034 0.987739C11.1362 0.986585 11.2678 1.01189 11.3907 1.06217C11.5136 1.11245 11.6253 1.1867 11.7192 1.28059C11.8131 1.37449 11.8873 1.48614 11.9376 1.60904C11.9879 1.73193 12.0132 1.86361 12.012 1.99639C12.0109 2.12917 11.9833 2.26039 11.9309 2.38239C11.8785 2.5044 11.8023 2.61474 11.7068 2.70699L7.41379 6.99999L11.7068 11.293C11.8889 11.4816 11.9897 11.7342 11.9875 11.9964C11.9852 12.2586 11.88 12.5094 11.6946 12.6948C11.5092 12.8802 11.2584 12.9854 10.9962 12.9877C10.734 12.9899 10.4814 12.8891 10.2928 12.707L5.99979 8.41399L1.70679 12.707C1.51818 12.8891 1.26558 12.9899 1.00339 12.9877C0.741188 12.9854 0.490376 12.8802 0.304968 12.6948C0.11956 12.5094 0.0143906 12.2586 0.0121121 11.9964C0.00983372 11.7342 0.110629 11.4816 0.292787 11.293L4.58579 6.99999L0.292787 2.70699C0.105316 2.51946 0 2.26515 0 1.99999C0 1.73483 0.105316 1.48052 0.292787 1.29299V1.29299Z",
          fill: "currentColor"
        })
      })
    }), (0, import_jsx_runtime24.jsxs)("div", {
      className: "w3a--flex w3a--items-center w3a--gap-2",
      children: [(0, import_jsx_runtime24.jsx)("p", {
        className: toastIconClass[toast.type],
        children: "x"
      }), (0, import_jsx_runtime24.jsx)("p", {
        children: toast.message
      })]
    })]
  });
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Root/Root.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
function Root(props) {
  var _bodyState$installLin2, _bodyState$installLin4, _bodyState$metamaskQr2, _bodyState$metamaskQr3, _bodyState$metamaskQr4, _bodyState$multiChain, _bodyState$installLin5;
  const {
    setModalState,
    modalState,
    handleExternalWalletBtnClick,
    chainNamespaces,
    walletRegistry,
    appLogo,
    onCloseLoader,
    handleSocialLoginClick,
    showPasswordLessInput,
    showExternalWalletButton,
    socialLoginsConfig,
    areSocialLoginsVisible,
    isEmailPrimary,
    isExternalPrimary,
    showExternalWalletPage,
    isEmailPasswordLessLoginVisible,
    isSmsPasswordLessLoginVisible,
    preHandleExternalWalletClick,
    uiConfig,
    deviceDetails
  } = props;
  const {
    logoAlignment = "center",
    buttonRadiusType = "pill",
    privacyPolicy = "",
    tncLink = "",
    displayInstalledExternalWallets = true,
    displayExternalWalletsCount = true
  } = uiConfig;
  const [t3] = useTranslation(void 0, {
    i18n: i18nInstance2
  });
  const {
    isDark
  } = (0, import_react28.useContext)(ThemedContext);
  const [bodyState, setBodyState] = (0, import_react28.useState)({
    metamaskQrCode: {
      show: false,
      wallet: null
    },
    installLinks: {
      show: false,
      wallet: null
    },
    multiChainSelector: {
      show: false,
      wallet: null
    }
  });
  const [toast, setToast] = (0, import_react28.useState)({
    message: "",
    type: TOAST_TYPE.SUCCESS
  });
  const [isSocialLoginsExpanded, setIsSocialLoginsExpanded] = (0, import_react28.useState)(false);
  const [isWalletDetailsExpanded, setIsWalletDetailsExpanded] = (0, import_react28.useState)(false);
  const onExternalWalletBtnClick = (flag) => {
    setModalState(_objectSpread2(_objectSpread2({}, modalState), {}, {
      currentPage: PAGES.CONNECT_WALLET
    }));
    if (handleExternalWalletBtnClick) handleExternalWalletBtnClick(flag);
  };
  const onBackClick = (flag) => {
    setModalState(_objectSpread2(_objectSpread2({}, modalState), {}, {
      currentPage: PAGES.LOGIN
    }));
    if (handleExternalWalletBtnClick) handleExternalWalletBtnClick(flag);
  };
  const mobileInstallLinks = (0, import_react28.useMemo)(() => {
    var _bodyState$installLin;
    if (deviceDetails.platform === "desktop") return [];
    const installConfig = ((_bodyState$installLin = bodyState.installLinks) === null || _bodyState$installLin === void 0 || (_bodyState$installLin = _bodyState$installLin.wallet) === null || _bodyState$installLin === void 0 || (_bodyState$installLin = _bodyState$installLin.walletRegistryItem) === null || _bodyState$installLin === void 0 ? void 0 : _bodyState$installLin.app) || {};
    const installLinks = Object.keys(installConfig).reduce((acc, osKey) => {
      if (!["android", "ios"].includes(osKey)) return acc;
      const appId = installConfig[osKey];
      if (!appId) return acc;
      const appUrl = getMobileInstallLink(osKey, appId);
      if (!appUrl) return acc;
      const logoLight = `${osKey}-light`;
      const logoDark = `${osKey}-dark`;
      acc.push((0, import_jsx_runtime25.jsx)("li", {
        className: "w3a--w-full",
        children: (0, import_jsx_runtime25.jsx)("a", {
          href: appUrl,
          rel: "noopener noreferrer",
          target: "_blank",
          children: (0, import_jsx_runtime25.jsxs)("button", {
            type: "button",
            className: cn2("w3a--group w3a--relative w3a--overflow-hidden w3a--h-11 w3a--flex w3a--w-full w3a--items-center w3a--justify-start w3a--gap-x-2 w3a--border w3a--border-app-gray-200 w3a--bg-app-gray-50 w3a--px-5 w3a--py-2.5 hover:w3a--translate-y-[0.5px] hover:w3a--border-app-gray-50 dark:w3a--border-app-gray-500 dark:w3a--bg-app-gray-800 dark:hover:w3a--border-app-gray-800", {
              "w3a--rounded-full": buttonRadiusType === "pill",
              "w3a--rounded-lg": buttonRadiusType === "rounded",
              "w3a--rounded-none": buttonRadiusType === "square"
            }),
            children: [(0, import_jsx_runtime25.jsx)(Image2, {
              imageId: logoLight,
              darkImageId: logoDark,
              hoverImageId: logoLight,
              darkHoverImageId: logoDark,
              height: "28",
              width: "28",
              isButton: true
            }), (0, import_jsx_runtime25.jsx)("span", {
              className: "w3a--text-sm w3a--font-medium w3a--text-app-gray-900 dark:w3a--text-app-white",
              children: t3("modal.external.install-mobile-app", {
                os: getOsName(osKey)
              })
            }), (0, import_jsx_runtime25.jsx)("img", {
              id: "install-links-arrow",
              className: "w3a--absolute w3a--right-4 w3a--top-1/2 -w3a--translate-x-6 -w3a--translate-y-1/2 w3a--opacity-0 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-0 group-hover:w3a--opacity-100",
              src: getIcons(isDark ? "chevron-right-dark" : "chevron-right-light"),
              alt: "arrow"
            })]
          })
        })
      }, appUrl));
      return acc;
    }, []);
    return installLinks;
  }, [(_bodyState$installLin2 = bodyState.installLinks) === null || _bodyState$installLin2 === void 0 || (_bodyState$installLin2 = _bodyState$installLin2.wallet) === null || _bodyState$installLin2 === void 0 || (_bodyState$installLin2 = _bodyState$installLin2.walletRegistryItem) === null || _bodyState$installLin2 === void 0 ? void 0 : _bodyState$installLin2.app, deviceDetails.platform, isDark, t3, buttonRadiusType]);
  const desktopInstallLinks = (0, import_react28.useMemo)(() => {
    var _bodyState$installLin3;
    if (deviceDetails.platform !== "desktop") return [];
    const browserType = deviceDetails.browser === "brave" ? "chrome" : deviceDetails.browser;
    const browserExtensionConfig = ((_bodyState$installLin3 = bodyState.installLinks) === null || _bodyState$installLin3 === void 0 || (_bodyState$installLin3 = _bodyState$installLin3.wallet) === null || _bodyState$installLin3 === void 0 || (_bodyState$installLin3 = _bodyState$installLin3.walletRegistryItem) === null || _bodyState$installLin3 === void 0 ? void 0 : _bodyState$installLin3.app) || {};
    const extensionForCurrentBrowser = browserExtensionConfig.browser && browserExtensionConfig.browser.includes(browserType) ? browserExtensionConfig.browser : void 0;
    const browserExtensionId = browserExtensionConfig[browserType] || extensionForCurrentBrowser;
    const browserExtensionUrl = browserExtensionId ? getBrowserExtensionUrl(browserType, browserExtensionId) : null;
    const installLink = browserExtensionUrl ? (0, import_jsx_runtime25.jsx)("li", {
      children: (0, import_jsx_runtime25.jsx)("a", {
        href: browserExtensionUrl,
        rel: "noopener noreferrer",
        target: "_blank",
        children: (0, import_jsx_runtime25.jsxs)("button", {
          type: "button",
          className: cn2("w3a--group w3a--relative w3a--overflow-hidden w3a--h-11 w3a--flex w3a--w-full w3a--items-center w3a--justify-start w3a--gap-x-2 w3a--border w3a--border-app-gray-200 w3a--bg-app-gray-50 w3a--px-5 w3a--py-2.5 hover:w3a--translate-y-[0.5px] hover:w3a--border-app-gray-50 dark:w3a--border-app-gray-500 dark:w3a--bg-app-gray-800 dark:hover:w3a--border-app-gray-800", {
            "w3a--rounded-full": buttonRadiusType === "pill",
            "w3a--rounded-lg": buttonRadiusType === "rounded",
            "w3a--rounded-none": buttonRadiusType === "square"
          }),
          children: [(0, import_jsx_runtime25.jsx)(Image2, {
            imageId: deviceDetails.browser,
            darkImageId: deviceDetails.browser,
            hoverImageId: deviceDetails.browser,
            darkHoverImageId: deviceDetails.browser,
            height: "30",
            width: "30",
            isButton: true
          }), (0, import_jsx_runtime25.jsx)("span", {
            className: "w3a--text-sm w3a--font-medium w3a--text-app-gray-900 dark:w3a--text-app-white",
            children: t3("modal.external.install-browser-extension", {
              browser: getBrowserName(deviceDetails.browser)
            })
          }), (0, import_jsx_runtime25.jsx)("img", {
            id: "install-links-arrow",
            className: "w3a--absolute w3a--right-4 w3a--top-1/2 -w3a--translate-x-6 -w3a--translate-y-1/2 w3a--opacity-0 w3a--transition-all w3a--duration-300 group-hover:w3a--translate-x-0 group-hover:w3a--opacity-100",
            src: getIcons(isDark ? "chevron-right-dark" : "chevron-right-light"),
            alt: "arrow"
          })]
        })
      })
    }, browserExtensionUrl) : null;
    return [installLink, ...mobileInstallLinks];
  }, [(_bodyState$installLin4 = bodyState.installLinks) === null || _bodyState$installLin4 === void 0 || (_bodyState$installLin4 = _bodyState$installLin4.wallet) === null || _bodyState$installLin4 === void 0 || (_bodyState$installLin4 = _bodyState$installLin4.walletRegistryItem) === null || _bodyState$installLin4 === void 0 ? void 0 : _bodyState$installLin4.app, deviceDetails.browser, deviceDetails.platform, isDark, mobileInstallLinks, buttonRadiusType, t3]);
  const config = (0, import_react28.useMemo)(() => modalState.externalWalletsConfig, [modalState.externalWalletsConfig]);
  const connectorVisibilityMap = (0, import_react28.useMemo)(() => {
    const canShowMap = {};
    Object.keys(config).forEach((connector) => {
      var _config$connector;
      canShowMap[connector] = Boolean((_config$connector = config[connector]) === null || _config$connector === void 0 ? void 0 : _config$connector.showOnModal);
    });
    return canShowMap;
  }, [config]);
  const isWalletConnectConnectorIncluded = (0, import_react28.useMemo)(
    // WC is always included when enabling wallet discovery
    () => Object.keys((walletRegistry === null || walletRegistry === void 0 ? void 0 : walletRegistry.default) || {}).length > 0 || Object.keys((walletRegistry === null || walletRegistry === void 0 ? void 0 : walletRegistry.others) || {}).length > 0,
    [walletRegistry]
  );
  const generateWalletButtons = (0, import_react28.useCallback)((wallets) => {
    return Object.keys(wallets).reduce((acc, wallet) => {
      var _walletRegistryItem$c, _walletRegistryItem$i, _walletRegistryItem$w;
      if (connectorVisibilityMap[wallet] === false) return acc;
      const walletRegistryItem = wallets[wallet];
      let href = "";
      if (deviceDetails.platform !== "desktop") {
        var _walletRegistryItem$m, _walletRegistryItem$m2;
        const universalLink = walletRegistryItem === null || walletRegistryItem === void 0 || (_walletRegistryItem$m = walletRegistryItem.mobile) === null || _walletRegistryItem$m === void 0 ? void 0 : _walletRegistryItem$m.universal;
        const deepLink = walletRegistryItem === null || walletRegistryItem === void 0 || (_walletRegistryItem$m2 = walletRegistryItem.mobile) === null || _walletRegistryItem$m2 === void 0 ? void 0 : _walletRegistryItem$m2.native;
        href = universalLink || deepLink;
      }
      const connectorConfig = config[wallet];
      const connectorChainNamespaces = (connectorConfig === null || connectorConfig === void 0 ? void 0 : connectorConfig.chainNamespaces) || [];
      const registryNamespaces = new Set((_walletRegistryItem$c = walletRegistryItem.chains) === null || _walletRegistryItem$c === void 0 ? void 0 : _walletRegistryItem$c.map((chain) => chain.split(":")[0]));
      const injectedChainNamespaces = new Set((_walletRegistryItem$i = walletRegistryItem.injected) === null || _walletRegistryItem$i === void 0 ? void 0 : _walletRegistryItem$i.map((injected) => injected.namespace));
      const availableChainNamespaces = chainNamespaces.filter((x3) => registryNamespaces.has(x3) || injectedChainNamespaces.has(x3) || connectorChainNamespaces.includes(x3));
      const button = {
        name: wallet,
        displayName: walletRegistryItem.name,
        href,
        hasInjectedWallet: (connectorConfig === null || connectorConfig === void 0 ? void 0 : connectorConfig.isInjected) || false,
        isInstalled: !!connectorConfig,
        hasWalletConnect: isWalletConnectConnectorIncluded && ((_walletRegistryItem$w = walletRegistryItem.walletConnect) === null || _walletRegistryItem$w === void 0 || (_walletRegistryItem$w = _walletRegistryItem$w.sdks) === null || _walletRegistryItem$w === void 0 ? void 0 : _walletRegistryItem$w.includes("sign_v2")),
        hasInstallLinks: Object.keys(walletRegistryItem.app || {}).length > 0,
        walletRegistryItem,
        imgExtension: walletRegistryItem.imgExtension || "svg",
        icon: connectorConfig === null || connectorConfig === void 0 ? void 0 : connectorConfig.icon,
        chainNamespaces: availableChainNamespaces
      };
      if (!button.hasInjectedWallet && !button.hasWalletConnect && !button.hasInstallLinks) return acc;
      if (availableChainNamespaces.length === 0) return acc;
      acc.push(button);
      return acc;
    }, []);
  }, [connectorVisibilityMap, chainNamespaces, config, deviceDetails.platform, isWalletConnectConnectorIncluded]);
  const allButtons = (0, import_react28.useMemo)(() => {
    return [...generateWalletButtons(walletRegistry.default), ...generateWalletButtons(walletRegistry.others)];
  }, [generateWalletButtons, walletRegistry.default, walletRegistry.others]);
  const installedConnectorButtons = (0, import_react28.useMemo)(() => {
    const installedConnectors = Object.keys(config).reduce((acc, connector) => {
      if (connector === WALLET_CONNECTORS.WALLET_CONNECT_V2 || !connectorVisibilityMap[connector]) return acc;
      const connectorConfig = config[connector];
      acc.push({
        name: connector,
        displayName: (connectorConfig === null || connectorConfig === void 0 ? void 0 : connectorConfig.label) || connector,
        hasInjectedWallet: (connectorConfig === null || connectorConfig === void 0 ? void 0 : connectorConfig.isInjected) || false,
        isInstalled: true,
        hasWalletConnect: false,
        hasInstallLinks: false,
        icon: connectorConfig === null || connectorConfig === void 0 ? void 0 : connectorConfig.icon,
        chainNamespaces: (connectorConfig === null || connectorConfig === void 0 ? void 0 : connectorConfig.chainNamespaces) || []
      });
      return acc;
    }, []);
    const metamaskConnectorIdx = installedConnectors.findIndex((x3) => x3.name === WALLET_CONNECTORS.METAMASK && !x3.hasInjectedWallet);
    if (metamaskConnectorIdx !== -1) {
      const metamaskConnector = installedConnectors[metamaskConnectorIdx];
      let metamaskRegistryButton = allButtons.find((button) => button.name === WALLET_CONNECTORS.METAMASK);
      if (!metamaskRegistryButton) {
        metamaskRegistryButton = generateWalletButtons({
          [WALLET_CONNECTORS.METAMASK]: DEFAULT_METAMASK_WALLET_REGISTRY_ITEM
        })[0];
      }
      if (metamaskRegistryButton) {
        installedConnectors.splice(metamaskConnectorIdx, 1, _objectSpread2(_objectSpread2({}, metamaskRegistryButton), {}, {
          chainNamespaces: metamaskConnector.chainNamespaces,
          // preserve the chain namespaces
          isInstalled: true
        }));
      }
    }
    return installedConnectors;
  }, [allButtons, config, connectorVisibilityMap, generateWalletButtons]);
  const customConnectorButtons = (0, import_react28.useMemo)(() => {
    return installedConnectorButtons.filter((button) => !button.hasInjectedWallet);
  }, [installedConnectorButtons]);
  const topInstalledConnectorButtons = (0, import_react28.useMemo)(() => {
    const MAX_TOP_INSTALLED_CONNECTORS = 3;
    return installedConnectorButtons.sort((a, _3) => a.name === WALLET_CONNECTORS.METAMASK ? -1 : 1).slice(0, displayInstalledExternalWallets ? MAX_TOP_INSTALLED_CONNECTORS : 1);
  }, [installedConnectorButtons, displayInstalledExternalWallets]);
  const totalExternalWallets = (0, import_react28.useMemo)(() => {
    const uniqueWalletSet = /* @__PURE__ */ new Set();
    return allButtons.concat(installedConnectorButtons).filter((button) => {
      if (uniqueWalletSet.has(button.name)) return false;
      uniqueWalletSet.add(button.name);
      return true;
    }).length;
  }, [allButtons, installedConnectorButtons]);
  const handleSocialLoginHeight = () => {
    setIsSocialLoginsExpanded((prev) => !prev);
  };
  const handleWalletDetailsHeight = () => {
    setIsWalletDetailsExpanded((prev) => !prev);
  };
  const containerMaxHeight = (0, import_react28.useMemo)(() => {
    var _bodyState$metamaskQr;
    const isPrivacyPolicyOrTncLink = privacyPolicy || tncLink;
    if (modalState.status !== MODAL_STATUS.INITIALIZED) {
      return "530px";
    }
    if (isWalletDetailsExpanded) {
      return isPrivacyPolicyOrTncLink ? "640px" : "588px";
    }
    if ((_bodyState$metamaskQr = bodyState.metamaskQrCode) !== null && _bodyState$metamaskQr !== void 0 && _bodyState$metamaskQr.show) {
      return isPrivacyPolicyOrTncLink ? "640px" : "588px";
    }
    if (modalState.currentPage === PAGES.CONNECT_WALLET) {
      return isPrivacyPolicyOrTncLink ? "640px" : "580px";
    }
    if (isSocialLoginsExpanded) {
      return isPrivacyPolicyOrTncLink ? "644px" : "588px";
    }
    if (topInstalledConnectorButtons.length === 1) {
      return isPrivacyPolicyOrTncLink ? "560px" : "530px";
    }
    if (topInstalledConnectorButtons.length > 1) {
      const maxHeight = 500 + (topInstalledConnectorButtons.length - 1) * 58;
      if (isPrivacyPolicyOrTncLink) {
        return `${maxHeight + 60}px`;
      }
      return `${maxHeight + 16}px`;
    }
    return "539px";
  }, [privacyPolicy, tncLink, modalState.status, modalState.currentPage, isWalletDetailsExpanded, (_bodyState$metamaskQr2 = bodyState.metamaskQrCode) === null || _bodyState$metamaskQr2 === void 0 ? void 0 : _bodyState$metamaskQr2.show, isSocialLoginsExpanded, topInstalledConnectorButtons.length]);
  const contextValue = (0, import_react28.useMemo)(() => ({
    bodyState,
    setBodyState,
    toast,
    setToast
  }), [bodyState, setBodyState, toast, setToast]);
  const isShowLoader = (0, import_react28.useMemo)(() => {
    return modalState.status !== MODAL_STATUS.INITIALIZED;
  }, [modalState.status]);
  return (0, import_jsx_runtime25.jsx)(RootContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime25.jsxs)("div", {
      className: "w3a--relative w3a--flex w3a--flex-col",
      children: [(0, import_jsx_runtime25.jsxs)("div", {
        className: "w3a--relative w3a--h-screen w3a--overflow-hidden w3a--transition-all w3a--duration-[400ms] w3a--ease-in-out",
        style: {
          maxHeight: containerMaxHeight
        },
        children: [(0, import_jsx_runtime25.jsx)("div", {
          className: "w3a--modal-curtain"
        }), (0, import_jsx_runtime25.jsxs)("div", {
          className: "w3a--relative w3a--flex w3a--h-full w3a--flex-1 w3a--flex-col w3a--p-6",
          children: [isShowLoader ? (0, import_jsx_runtime25.jsx)(Loader, {
            connector: modalState.detailedLoaderConnector,
            connectorName: modalState.detailedLoaderConnectorName,
            modalStatus: modalState.status,
            onClose: onCloseLoader,
            appLogo
          }) : (0, import_jsx_runtime25.jsx)(import_jsx_runtime25.Fragment, {
            children: (_bodyState$metamaskQr3 = bodyState.metamaskQrCode) !== null && _bodyState$metamaskQr3 !== void 0 && _bodyState$metamaskQr3.show ? (0, import_jsx_runtime25.jsxs)("div", {
              className: "w3a--relative w3a--flex w3a--flex-1 w3a--flex-col w3a--gap-y-4",
              children: [(0, import_jsx_runtime25.jsx)(ConnectWalletHeader, {
                onBackClick: () => setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
                  metamaskQrCode: {
                    show: false,
                    wallet: null
                  }
                })),
                currentPage: CONNECT_WALLET_PAGES.SELECTED_WALLET,
                selectedButton: bodyState.metamaskQrCode.wallet
              }), (0, import_jsx_runtime25.jsx)(ConnectWalletQrCode, {
                qrCodeValue: modalState.metamaskConnectUri,
                isDark,
                selectedButton: bodyState.metamaskQrCode.wallet,
                primaryColor: (_bodyState$metamaskQr4 = bodyState.metamaskQrCode.wallet.walletRegistryItem) === null || _bodyState$metamaskQr4 === void 0 ? void 0 : _bodyState$metamaskQr4.primaryColor,
                logoImage: `https://images.web3auth.io/login-${bodyState.metamaskQrCode.wallet.name}.${bodyState.metamaskQrCode.wallet.imgExtension}`
              })]
            }) : (0, import_jsx_runtime25.jsxs)(import_jsx_runtime25.Fragment, {
              children: [modalState.currentPage === PAGES.LOGIN && showExternalWalletPage && modalState.status === MODAL_STATUS.INITIALIZED && (0, import_jsx_runtime25.jsx)(Login, {
                web3authClientId: modalState.web3authClientId,
                web3authNetwork: modalState.web3authNetwork,
                authBuildEnv: modalState.authBuildEnv,
                isModalVisible: modalState.modalVisibility,
                isDark,
                appLogo,
                showPasswordLessInput,
                showExternalWalletButton,
                showExternalWalletCount: displayExternalWalletsCount,
                showInstalledExternalWallets: displayInstalledExternalWallets,
                socialLoginsConfig,
                areSocialLoginsVisible,
                isEmailPrimary,
                isExternalPrimary,
                installedExternalWalletConfig: topInstalledConnectorButtons,
                isEmailPasswordLessLoginVisible,
                isSmsPasswordLessLoginVisible,
                totalExternalWallets,
                logoAlignment,
                buttonRadius: buttonRadiusType,
                deviceDetails,
                handleSocialLoginClick,
                handleExternalWalletBtnClick: onExternalWalletBtnClick,
                handleSocialLoginHeight,
                handleExternalWalletClick: preHandleExternalWalletClick
              }), modalState.currentPage === PAGES.CONNECT_WALLET && !showExternalWalletPage && modalState.status === MODAL_STATUS.INITIALIZED && (0, import_jsx_runtime25.jsx)(ConnectWallet, {
                isDark,
                walletConnectUri: modalState.walletConnectUri,
                metamaskConnectUri: modalState.metamaskConnectUri,
                config: modalState.externalWalletsConfig,
                walletRegistry,
                allExternalButtons: allButtons,
                connectorVisibilityMap,
                customConnectorButtons,
                deviceDetails,
                chainNamespace: chainNamespaces,
                buttonRadius: buttonRadiusType,
                handleWalletDetailsHeight,
                onBackClick,
                handleExternalWalletClick: preHandleExternalWalletClick
              })]
            })
          }), (0, import_jsx_runtime25.jsx)(Footer, {
            privacyPolicy,
            termsOfService: tncLink
          }), ((_bodyState$multiChain = bodyState.multiChainSelector) === null || _bodyState$multiChain === void 0 ? void 0 : _bodyState$multiChain.show) && (0, import_jsx_runtime25.jsx)(BottomSheet, {
            uiConfig,
            isShown: bodyState.multiChainSelector.show,
            onClose: () => setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
              multiChainSelector: {
                show: false,
                wallet: null
              }
            })),
            children: (0, import_jsx_runtime25.jsx)(ConnectWalletChainNamespaceSelect, {
              isDark,
              wallet: bodyState.multiChainSelector.wallet,
              handleExternalWalletClick: (params) => {
                preHandleExternalWalletClick(params);
                setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
                  multiChainSelector: {
                    show: false,
                    wallet: null
                  }
                }));
              }
            })
          }), ((_bodyState$installLin5 = bodyState.installLinks) === null || _bodyState$installLin5 === void 0 ? void 0 : _bodyState$installLin5.show) && (0, import_jsx_runtime25.jsxs)(BottomSheet, {
            uiConfig,
            isShown: bodyState.installLinks.show,
            onClose: () => setBodyState(_objectSpread2(_objectSpread2({}, bodyState), {}, {
              installLinks: {
                show: false,
                wallet: null
              }
            })),
            children: [(0, import_jsx_runtime25.jsx)("p", {
              className: "w3a--mb-2 w3a--text-center w3a--text-base w3a--font-semibold w3a--text-app-gray-900 dark:w3a--text-app-white",
              children: t3("modal.getWallet")
            }), (0, import_jsx_runtime25.jsx)("div", {
              className: "w3a--my-4 w3a--flex w3a--justify-center",
              children: (0, import_jsx_runtime25.jsx)(Image2, {
                imageId: `login-${bodyState.installLinks.wallet.name}`,
                hoverImageId: `login-${bodyState.installLinks.wallet.name}`,
                fallbackImageId: "wallet",
                height: "80",
                width: "80",
                isButton: true,
                extension: bodyState.installLinks.wallet.imgExtension
              })
            }), (0, import_jsx_runtime25.jsx)("ul", {
              className: "w3a--flex w3a--flex-col w3a--gap-y-2",
              children: deviceDetails.platform === "desktop" ? desktopInstallLinks : mobileInstallLinks
            })]
          })]
        })]
      }), (0, import_jsx_runtime25.jsx)(Toast, {})]
    })
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/components/Widget/Widget.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
function Widget(props) {
  const {
    stateListener,
    handleSocialLoginClick,
    handleExternalWalletClick,
    handleShowExternalWallets,
    closeModal,
    appLogo,
    appName,
    chainNamespaces,
    walletRegistry,
    uiConfig,
    deviceDetails
  } = props;
  const {
    widgetType
  } = uiConfig;
  const visible = (0, import_react29.useMemo)(() => widgetType === WIDGET_TYPE.EMBED, [widgetType]);
  const [modalState, setModalState] = (0, import_react29.useState)({
    externalWalletsVisibility: false,
    status: MODAL_STATUS.INITIALIZED,
    hasExternalWallets: false,
    externalWalletsInitialized: false,
    modalVisibility: false,
    modalVisibilityDelayed: false,
    postLoadingMessage: "",
    walletConnectUri: "",
    metamaskConnectUri: "",
    socialLoginsConfig: {
      loginMethods: {},
      loginMethodsOrder: [],
      connector: "",
      uiConfig: {}
    },
    externalWalletsConfig: {},
    showExternalWalletsOnly: false,
    currentPage: PAGES.LOGIN,
    detailedLoaderConnector: "",
    detailedLoaderConnectorName: "",
    web3authClientId: "",
    web3authNetwork: WEB3AUTH_NETWORK.SAPPHIRE_MAINNET,
    authBuildEnv: BUILD_ENV.PRODUCTION
  });
  (0, import_react29.useEffect)(() => {
    setModalState((prev) => _objectSpread2(_objectSpread2({}, prev), {}, {
      modalVisibility: visible
    }));
  }, [visible]);
  (0, import_react29.useEffect)(() => {
    stateListener.on("STATE_UPDATED", (newModalState) => {
      log.debug("state updated", newModalState);
      setModalState((prevState) => {
        const mergedState = cloneDeep2((0, import_deepmerge4.default)(prevState, newModalState, {
          arrayMerge: (_prevState, newState) => newState
        }));
        return mergedState;
      });
    });
    stateListener.emit("MOUNTED");
  }, [stateListener]);
  const preHandleExternalWalletClick = (params) => {
    const {
      connector
    } = params;
    setModalState((prevState) => _objectSpread2(_objectSpread2({}, prevState), {}, {
      detailedLoaderConnector: connector,
      detailedLoaderAdapterName: CONNECTOR_NAMES[connector]
    }));
    if (handleExternalWalletClick) handleExternalWalletClick(params);
  };
  const preHandleSocialWalletClick = (params) => {
    const {
      loginParams
    } = params;
    setModalState((prevState) => {
      return _objectSpread2(_objectSpread2({}, prevState), {}, {
        detailedLoaderConnector: loginParams.authConnection,
        detailedLoaderConnectorName: loginParams.name
      });
    });
    handleSocialLoginClick(params);
  };
  const areSocialLoginsVisible = (0, import_react29.useMemo)(() => {
    var _modalState$socialLog, _modalState$socialLog2;
    if (modalState.showExternalWalletsOnly) return false;
    if (Object.keys(((_modalState$socialLog = modalState.socialLoginsConfig) === null || _modalState$socialLog === void 0 ? void 0 : _modalState$socialLog.loginMethods) || {}).length === 0) return false;
    const isAnySocialLoginVisible = Object.entries(((_modalState$socialLog2 = modalState.socialLoginsConfig) === null || _modalState$socialLog2 === void 0 ? void 0 : _modalState$socialLog2.loginMethods) || {}).some(([k3, v2]) => k3 !== AUTH_CONNECTION.EMAIL_PASSWORDLESS && v2.showOnModal !== false);
    return isAnySocialLoginVisible;
  }, [modalState]);
  const isEmailPasswordLessLoginVisible = (0, import_react29.useMemo)(() => {
    var _modalState$socialLog3;
    return (_modalState$socialLog3 = modalState.socialLoginsConfig) === null || _modalState$socialLog3 === void 0 || (_modalState$socialLog3 = _modalState$socialLog3.loginMethods[AUTH_CONNECTION.EMAIL_PASSWORDLESS]) === null || _modalState$socialLog3 === void 0 ? void 0 : _modalState$socialLog3.showOnModal;
  }, [modalState.socialLoginsConfig]);
  const isSmsPasswordLessLoginVisible = (0, import_react29.useMemo)(() => {
    var _modalState$socialLog4;
    return (_modalState$socialLog4 = modalState.socialLoginsConfig) === null || _modalState$socialLog4 === void 0 || (_modalState$socialLog4 = _modalState$socialLog4.loginMethods[AUTH_CONNECTION.SMS_PASSWORDLESS]) === null || _modalState$socialLog4 === void 0 ? void 0 : _modalState$socialLog4.showOnModal;
  }, [modalState.socialLoginsConfig]);
  const isEmailPrimary = (0, import_react29.useMemo)(() => {
    var _modalState$socialLog5;
    return ((_modalState$socialLog5 = modalState.socialLoginsConfig) === null || _modalState$socialLog5 === void 0 || (_modalState$socialLog5 = _modalState$socialLog5.uiConfig) === null || _modalState$socialLog5 === void 0 ? void 0 : _modalState$socialLog5.primaryButton) === "emailLogin";
  }, [modalState.socialLoginsConfig]);
  const isExternalPrimary = (0, import_react29.useMemo)(() => {
    var _modalState$socialLog6;
    return ((_modalState$socialLog6 = modalState.socialLoginsConfig) === null || _modalState$socialLog6 === void 0 || (_modalState$socialLog6 = _modalState$socialLog6.uiConfig) === null || _modalState$socialLog6 === void 0 ? void 0 : _modalState$socialLog6.primaryButton) === "externalLogin";
  }, [modalState.socialLoginsConfig]);
  const showPasswordLessInput = (0, import_react29.useMemo)(() => isEmailPasswordLessLoginVisible || isSmsPasswordLessLoginVisible, [isEmailPasswordLessLoginVisible, isSmsPasswordLessLoginVisible]);
  const showExternalWalletButton = (0, import_react29.useMemo)(() => modalState.hasExternalWallets || !!modalState.externalWalletsConfig[WALLET_CONNECTORS.METAMASK], [modalState]);
  const showExternalWalletPage = (0, import_react29.useMemo)(() => (areSocialLoginsVisible || showPasswordLessInput || !!modalState.externalWalletsConfig[WALLET_CONNECTORS.METAMASK]) && !modalState.externalWalletsVisibility, [areSocialLoginsVisible, showPasswordLessInput, modalState]);
  const handleExternalWalletBtnClick = (flag) => {
    setModalState((prevState) => {
      return _objectSpread2(_objectSpread2({}, prevState), {}, {
        externalWalletsVisibility: flag
      });
    });
    if (flag && handleShowExternalWallets) handleShowExternalWallets(modalState.externalWalletsInitialized);
  };
  const onCloseModal = () => {
    setModalState((prevState) => _objectSpread2(_objectSpread2({}, prevState), {}, {
      externalWalletsVisibility: false,
      modalVisibility: false,
      currentPage: PAGES.LOGIN
    }));
    closeModal();
  };
  const onCloseLoader = () => {
    if (modalState.status === MODAL_STATUS.CONNECTED) {
      setModalState(_objectSpread2(_objectSpread2({}, modalState), {}, {
        modalVisibility: false,
        externalWalletsVisibility: false
      }));
    }
    if (modalState.status === MODAL_STATUS.ERRORED) {
      setModalState(_objectSpread2(_objectSpread2({}, modalState), {}, {
        modalVisibility: true,
        status: MODAL_STATUS.INITIALIZED
      }));
    }
  };
  const showCloseIcon = (0, import_react29.useMemo)(() => {
    return modalState.status === MODAL_STATUS.INITIALIZED || modalState.status === MODAL_STATUS.CONNECTED || modalState.status === MODAL_STATUS.ERRORED;
  }, [modalState.status]);
  (0, import_react29.useEffect)(() => {
    if (!modalState.modalVisibility) return;
    if (typeof modalState.externalWalletsConfig === "object") {
      var _modalState$externalW;
      const wcAvailable = (((_modalState$externalW = modalState.externalWalletsConfig[WALLET_CONNECTORS.WALLET_CONNECT_V2]) === null || _modalState$externalW === void 0 ? void 0 : _modalState$externalW.showOnModal) || false) !== false;
      if (wcAvailable && !modalState.walletConnectUri && typeof handleExternalWalletClick === "function") {
        handleExternalWalletClick({
          connector: WALLET_CONNECTORS.WALLET_CONNECT_V2
        });
      }
    }
  }, [modalState, handleExternalWalletClick]);
  if (widgetType === WIDGET_TYPE.MODAL) {
    return (0, import_jsx_runtime26.jsx)(Modal, {
      open: modalState.modalVisibility,
      placement: "center",
      padding: false,
      showCloseIcon,
      onClose: onCloseModal,
      borderRadius: uiConfig.borderRadiusType,
      children: modalState.modalVisibility && (0, import_jsx_runtime26.jsx)(Root, {
        appLogo,
        appName,
        chainNamespaces,
        walletRegistry,
        showPasswordLessInput,
        showExternalWalletButton,
        handleSocialLoginClick: (params) => preHandleSocialWalletClick(params),
        socialLoginsConfig: modalState.socialLoginsConfig,
        areSocialLoginsVisible,
        isEmailPrimary,
        isExternalPrimary,
        showExternalWalletPage,
        handleExternalWalletBtnClick,
        modalState,
        preHandleExternalWalletClick,
        setModalState,
        onCloseLoader,
        isEmailPasswordLessLoginVisible,
        isSmsPasswordLessLoginVisible,
        uiConfig,
        deviceDetails
      })
    });
  }
  return (0, import_jsx_runtime26.jsx)(Embed, {
    open: modalState.modalVisibility,
    padding: false,
    onClose: onCloseModal,
    borderRadius: uiConfig.borderRadiusType,
    children: modalState.modalVisibility && (0, import_jsx_runtime26.jsx)(Root, {
      chainNamespaces,
      walletRegistry,
      appLogo,
      appName,
      showPasswordLessInput,
      showExternalWalletButton,
      handleSocialLoginClick: (params) => preHandleSocialWalletClick(params),
      socialLoginsConfig: modalState.socialLoginsConfig,
      areSocialLoginsVisible,
      isEmailPrimary,
      isExternalPrimary,
      showExternalWalletPage,
      handleExternalWalletBtnClick,
      modalState,
      preHandleExternalWalletClick,
      setModalState,
      onCloseLoader,
      isEmailPasswordLessLoginVisible,
      isSmsPasswordLessLoginVisible,
      uiConfig,
      deviceDetails
    })
  });
}

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/ui/loginModal.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
function createWrapperForModal(parentZIndex) {
  const existingWrapper = document.getElementById("w3a-parent-container");
  if (existingWrapper) existingWrapper.remove();
  const parent = document.createElement("section");
  parent.classList.add("w3a-parent-container");
  parent.setAttribute("id", "w3a-parent-container");
  parent.style.zIndex = parentZIndex;
  parent.style.position = "relative";
  document.body.appendChild(parent);
}
function createWrapperForEmbed(targetId) {
  const targetElement = document.getElementById(targetId);
  if (!targetElement) {
    log.error(`Element with ID ${targetId} not found`);
    return;
  }
  targetElement.innerHTML = `<div id="w3a-parent-container" class="w3a-parent-container"></div>`;
}
var LoginModal = class {
  constructor(_uiConfig, callbacks) {
    _defineProperty(this, "uiConfig", void 0);
    _defineProperty(this, "stateEmitter", void 0);
    _defineProperty(this, "chainNamespaces", void 0);
    _defineProperty(this, "walletRegistry", void 0);
    _defineProperty(this, "callbacks", void 0);
    _defineProperty(this, "externalWalletsConfig", void 0);
    _defineProperty(this, "analytics", void 0);
    _defineProperty(this, "initModal", async () => {
      const darkState = {
        isDark: this.isDark
      };
      const useLang = this.uiConfig.defaultLanguage || LANGUAGES.en;
      if (useLang === LANGUAGES.de) {
        import("./german.json-LFVUUNVQ.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.ja) {
        import("./japanese.json-6VAA2XC2.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.ko) {
        import("./korean.json-Q65SLEMS.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.zh) {
        import("./mandarin.json-AZOZKRID.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.es) {
        import("./spanish.json-4Y235LYC.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.fr) {
        import("./french.json-GUWFHAUN.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.pt) {
        import("./portuguese.json-A4WAOLID.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.nl) {
        import("./dutch.json-HXT7627C.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.tr) {
        import("./turkish.json-CACA7T4R.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      } else if (useLang === LANGUAGES.en) {
        import("./english.json-D767MBDZ.js").then((messages) => {
          i18nInstance2.addResourceBundle(useLang, "translation", messages.default);
          return i18nInstance2.changeLanguage(useLang);
        }).catch((error) => {
          log.error(error);
        });
      }
      return new Promise((resolve) => {
        var _this$uiConfig, _this$uiConfig$theme, _this$uiConfig2;
        this.stateEmitter.once("MOUNTED", () => {
          log.info("rendered");
          this.setState({
            status: MODAL_STATUS.INITIALIZED,
            web3authClientId: this.uiConfig.web3authClientId,
            web3authNetwork: this.uiConfig.web3authNetwork,
            authBuildEnv: this.uiConfig.authBuildEnv
          });
          return resolve();
        });
        if (this.uiConfig.widgetType === WIDGET_TYPE.MODAL) {
          createWrapperForModal(this.uiConfig.modalZIndex);
        } else if (this.uiConfig.widgetType === WIDGET_TYPE.EMBED) {
          createWrapperForEmbed(this.uiConfig.targetId);
        } else {
          throw WalletInitializationError.invalidParams(`Invalid widget type: ${this.uiConfig.widgetType}`);
        }
        const container = document.getElementById("w3a-parent-container");
        if (darkState.isDark) {
          container.classList.add("w3a--dark");
        } else {
          container.classList.remove("w3a--dark");
        }
        const root = (0, import_client.createRoot)(container);
        root.render((0, import_jsx_runtime27.jsx)(ThemedContext.Provider, {
          value: darkState,
          children: (0, import_jsx_runtime27.jsx)(AnalyticsContext.Provider, {
            value: {
              analytics: this.analytics
            },
            children: (0, import_jsx_runtime27.jsx)(Widget, {
              stateListener: this.stateEmitter,
              appLogo: darkState.isDark ? this.uiConfig.logoDark : this.uiConfig.logoLight,
              appName: this.uiConfig.appName,
              chainNamespaces: this.chainNamespaces,
              walletRegistry: this.walletRegistry,
              deviceDetails: this.deviceDetails,
              handleShowExternalWallets: this.handleShowExternalWallets,
              handleExternalWalletClick: this.handleExternalWalletClick,
              handleSocialLoginClick: this.handleSocialLoginClick,
              closeModal: this.closeModal,
              uiConfig: this.uiConfig
            })
          })
        }));
        const isDefaultColors = ((_this$uiConfig = this.uiConfig) === null || _this$uiConfig === void 0 || (_this$uiConfig = _this$uiConfig.theme) === null || _this$uiConfig === void 0 ? void 0 : _this$uiConfig.primary) === DEFAULT_PRIMARY_COLOR && ((_this$uiConfig$theme = this.uiConfig.theme) === null || _this$uiConfig$theme === void 0 ? void 0 : _this$uiConfig$theme.onPrimary) === DEFAULT_ON_PRIMARY_COLOR;
        if ((_this$uiConfig2 = this.uiConfig) !== null && _this$uiConfig2 !== void 0 && _this$uiConfig2.theme && !isDefaultColors) {
          import("./color-TLNG3CUN.js").then(({
            default: Color
          }) => {
            const rootElement = document.getElementById("w3a-parent-container");
            applyWhiteLabelTheme(Color, rootElement, this.uiConfig.theme);
            return;
          }).catch((error) => {
            log.error(error);
          });
        }
      });
    });
    _defineProperty(this, "addSocialLogins", (connector, loginMethods, loginMethodsOrder, uiConfig) => {
      this.setState({
        socialLoginsConfig: {
          connector,
          loginMethods,
          loginMethodsOrder,
          uiConfig
        }
      });
      log.info("addSocialLogins", connector, loginMethods, loginMethodsOrder, uiConfig);
    });
    _defineProperty(this, "addWalletLogins", (externalWalletsConfig, options2) => {
      this.externalWalletsConfig = externalWalletsConfig;
      const isMMAvailable = !!externalWalletsConfig[WALLET_CONNECTORS.METAMASK];
      this.setState({
        externalWalletsConfig,
        externalWalletsInitialized: !!options2.externalWalletsInitialized,
        showExternalWalletsOnly: !!options2.showExternalWalletsOnly,
        externalWalletsVisibility: isMMAvailable ? false : !!options2.externalWalletsVisibility
      });
    });
    _defineProperty(this, "open", () => {
      var _this$analytics, _this$walletRegistry, _this$walletRegistry2;
      this.setState({
        modalVisibility: true
      });
      (_this$analytics = this.analytics) === null || _this$analytics === void 0 || _this$analytics.track(ANALYTICS_EVENTS.LOGIN_MODAL_OPENED, _objectSpread2(_objectSpread2({
        chain_namespaces: this.chainNamespaces,
        wallet_registry_count: Object.keys((_this$walletRegistry = this.walletRegistry) === null || _this$walletRegistry === void 0 ? void 0 : _this$walletRegistry.default).length + Object.keys((_this$walletRegistry2 = this.walletRegistry) === null || _this$walletRegistry2 === void 0 ? void 0 : _this$walletRegistry2.others).length,
        external_wallet_connectors: Object.keys(this.externalWalletsConfig || {})
      }, getWhitelabelAnalyticsProperties(this.uiConfig)), getLoginModalAnalyticsProperties(this.uiConfig)));
      if (this.callbacks.onModalVisibility) {
        this.callbacks.onModalVisibility(true);
      }
    });
    _defineProperty(this, "closeModal", () => {
      var _this$analytics2;
      this.setState({
        modalVisibility: false,
        externalWalletsVisibility: false
      });
      (_this$analytics2 = this.analytics) === null || _this$analytics2 === void 0 || _this$analytics2.track(ANALYTICS_EVENTS.LOGIN_MODAL_CLOSED);
      if (this.callbacks.onModalVisibility) {
        this.callbacks.onModalVisibility(false);
      }
    });
    _defineProperty(this, "initExternalWalletContainer", () => {
      this.setState({
        hasExternalWallets: true
      });
    });
    _defineProperty(this, "handleShowExternalWallets", (status) => {
      if (this.callbacks.onInitExternalWallets) {
        this.callbacks.onInitExternalWallets({
          externalWalletsInitialized: status
        });
      }
    });
    _defineProperty(this, "handleExternalWalletClick", (params) => {
      log.info("external wallet clicked", params);
      const {
        connector,
        chainNamespace
      } = params;
      if (this.callbacks.onExternalWalletLogin) {
        this.callbacks.onExternalWalletLogin({
          connector,
          loginParams: {
            chainNamespace
          }
        });
      }
    });
    _defineProperty(this, "handleSocialLoginClick", (params) => {
      var _this$analytics3;
      log.info("social login clicked", params);
      const {
        connector,
        loginParams
      } = params;
      (_this$analytics3 = this.analytics) === null || _this$analytics3 === void 0 || _this$analytics3.track(ANALYTICS_EVENTS.SOCIAL_LOGIN_SELECTED, {
        connector,
        auth_connection: loginParams.authConnection,
        auth_connection_id: loginParams.authConnectionId,
        group_auth_connection_id: loginParams.groupedAuthConnectionId
      });
      if (this.callbacks.onSocialLogin) {
        this.callbacks.onSocialLogin({
          connector,
          loginParams
        });
      }
    });
    _defineProperty(this, "setState", (newState) => {
      this.stateEmitter.emit("STATE_UPDATED", newState);
    });
    _defineProperty(this, "handleConnectorData", (connectorData) => {
      if (connectorData.connectorName === WALLET_CONNECTORS.WALLET_CONNECT_V2) {
        const walletConnectData = connectorData.data;
        if (walletConnectData.uri) {
          this.setState({
            walletConnectUri: walletConnectData.uri
          });
        }
      }
      if (connectorData.connectorName === WALLET_CONNECTORS.METAMASK) {
        const metamaskData = connectorData.data;
        if (metamaskData.uri) {
          this.setState({
            metamaskConnectUri: metamaskData.uri
          });
        }
      }
    });
    _defineProperty(this, "subscribeCoreEvents", (listener) => {
      listener.on(CONNECTOR_EVENTS.CONNECTING, (data) => {
        var _this$externalWallets;
        log.info("connecting with connector", data);
        if ((data === null || data === void 0 ? void 0 : data.connector) === WALLET_CONNECTORS.WALLET_CONNECT_V2) return;
        const isMetamaskInjected = (_this$externalWallets = this.externalWalletsConfig) === null || _this$externalWallets === void 0 || (_this$externalWallets = _this$externalWallets[WALLET_CONNECTORS.METAMASK]) === null || _this$externalWallets === void 0 ? void 0 : _this$externalWallets.isInjected;
        if ((data === null || data === void 0 ? void 0 : data.connector) === WALLET_CONNECTORS.METAMASK && !isMetamaskInjected && this.deviceDetails.platform === "desktop") return;
        this.setState({
          status: MODAL_STATUS.CONNECTING
        });
      });
      listener.on(CONNECTOR_EVENTS.CONNECTED, (data) => {
        log.debug("connected with connector", data);
        if (!data.reconnected && data.loginMode === LOGIN_MODE.MODAL) {
          this.setState({
            status: MODAL_STATUS.CONNECTED,
            modalVisibility: true,
            postLoadingMessage: "modal.post-loading.connected"
          });
        } else {
          this.setState({
            status: MODAL_STATUS.CONNECTED
          });
        }
      });
      listener.on(CONNECTOR_EVENTS.ERRORED, (error, loginMode) => {
        log.error("error", error, error.message);
        if (loginMode === LOGIN_MODE.NO_MODAL) return;
        if (error.code === 5e3) {
          if (this.uiConfig.displayErrorsOnModal) this.setState({
            modalVisibility: true,
            postLoadingMessage: error.message || "modal.post-loading.something-wrong",
            status: MODAL_STATUS.ERRORED
          });
          else this.setState({
            modalVisibility: false
          });
        } else {
          this.setState({
            modalVisibility: true,
            status: MODAL_STATUS.INITIALIZED
          });
        }
      });
      listener.on(CONNECTOR_EVENTS.DISCONNECTED, () => {
        this.setState({
          status: MODAL_STATUS.INITIALIZED,
          externalWalletsVisibility: false
        });
      });
      listener.on(CONNECTOR_EVENTS.CONNECTOR_DATA_UPDATED, (connectorData) => {
        this.handleConnectorData(connectorData);
      });
    });
    this.uiConfig = _uiConfig;
    if (!_uiConfig.logoDark) this.uiConfig.logoDark = DEFAULT_LOGO_DARK;
    if (!_uiConfig.logoLight) this.uiConfig.logoLight = DEFAULT_LOGO_LIGHT;
    if (!_uiConfig.mode) this.uiConfig.mode = "light";
    if (!_uiConfig.modalZIndex) this.uiConfig.modalZIndex = "99998";
    if (typeof _uiConfig.displayErrorsOnModal === "undefined") this.uiConfig.displayErrorsOnModal = true;
    if (!_uiConfig.appName) this.uiConfig.appName = "Web3Auth";
    if (!_uiConfig.loginGridCol) this.uiConfig.loginGridCol = 3;
    if (!_uiConfig.primaryButton) this.uiConfig.primaryButton = "socialLogin";
    if (!_uiConfig.defaultLanguage) this.uiConfig.defaultLanguage = getUserLanguage(_uiConfig.defaultLanguage);
    if (!_uiConfig.widgetType) this.uiConfig.widgetType = WIDGET_TYPE.MODAL;
    if (_uiConfig.widgetType === WIDGET_TYPE.EMBED && !_uiConfig.targetId) {
      log.error("targetId is required for embed widget");
      throw WalletInitializationError.invalidParams("targetId is required for embed widget");
    }
    this.stateEmitter = new SafeEventEmitter();
    this.chainNamespaces = _uiConfig.chainNamespaces;
    this.walletRegistry = _uiConfig.walletRegistry;
    this.callbacks = callbacks;
    this.analytics = _uiConfig.analytics;
    this.subscribeCoreEvents(this.uiConfig.connectorListener);
  }
  get isDark() {
    return this.uiConfig.mode === "dark" || this.uiConfig.mode === "auto" && window.matchMedia("(prefers-color-scheme: dark)").matches;
  }
  get deviceDetails() {
    if (typeof window === "undefined") return {
      platform: "mobile",
      browser: "chrome",
      os: "ios"
    };
    const browserData = bowser_default.getParser(window.navigator.userAgent);
    return {
      platform: browserData.getPlatformType(),
      browser: browserData.getBrowserName().toLowerCase(),
      os: browserData.getOSName()
    };
  }
};

// node_modules/@web3auth/modal/dist/lib.esm/packages/modal/src/modalManager.js
var Web3Auth = class extends Web3AuthNoModal {
  constructor(options2, initialState) {
    super(options2, initialState);
    _defineProperty(this, "loginModal", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "modalConfig", cloneDeep2(defaultConnectorsModalConfig));
    _defineProperty(this, "onInitExternalWallets", async (params) => {
      if (params.externalWalletsInitialized) return;
      await this.initExternalConnectors(this.connectors.filter((x3) => x3.name === WALLET_CONNECTORS.WALLET_CONNECT_V2), {
        externalWalletsInitialized: true,
        externalWalletsVisibility: true
      });
    });
    _defineProperty(this, "onSocialLogin", async (params) => {
      try {
        await this.connectTo(WALLET_CONNECTORS.AUTH, params.loginParams, LOGIN_MODE.MODAL);
      } catch (error) {
        log.error(`Error while connecting to connector: ${params.connector}`, error);
      }
    });
    _defineProperty(this, "onExternalWalletLogin", async (params) => {
      try {
        var _params$loginParams;
        const connector = this.getConnector(params.connector, (_params$loginParams = params.loginParams) === null || _params$loginParams === void 0 ? void 0 : _params$loginParams.chainNamespace);
        const shouldStartConnectionInBackground = connector.name === WALLET_CONNECTORS.WALLET_CONNECT_V2;
        if (shouldStartConnectionInBackground) {
          const initialChain = this.getInitialChainIdForConnector(connector);
          await connector.connect({
            chainId: initialChain.chainId
          });
        } else {
          await this.connectTo(params.connector, params.loginParams, LOGIN_MODE.MODAL);
        }
      } catch (error) {
        log.error(`Error while connecting to connector: ${params.connector}`, error);
      }
    });
    _defineProperty(this, "onModalVisibility", async (visibility) => {
      log.debug("is login modal visible", visibility);
      this.emit(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, visibility);
      const wcConnector = this.getConnector(WALLET_CONNECTORS.WALLET_CONNECT_V2);
      if (wcConnector) {
        const walletConnectStatus = wcConnector === null || wcConnector === void 0 ? void 0 : wcConnector.status;
        log.debug("trying refreshing wc session", visibility, walletConnectStatus);
        if (visibility && (walletConnectStatus === CONNECTOR_STATUS.READY || walletConnectStatus === CONNECTOR_STATUS.CONNECTING)) {
          log.debug("refreshing wc session");
          try {
            const initialChain = this.getInitialChainIdForConnector(wcConnector);
            wcConnector.connect({
              chainId: initialChain.chainId
            });
          } catch (error) {
            log.error(`Error while disconnecting to wallet connect in core`, error);
          }
        }
        if (!visibility && this.status === CONNECTOR_STATUS.CONNECTED && (walletConnectStatus === CONNECTOR_STATUS.READY || walletConnectStatus === CONNECTOR_STATUS.CONNECTING)) {
          log.debug("this stops wc connector from trying to reconnect once proposal expires");
          wcConnector.status = CONNECTOR_STATUS.READY;
        }
      }
    });
    _defineProperty(this, "getChainNamespaces", () => {
      var _this$coreOptions$cha;
      return [...new Set(((_this$coreOptions$cha = this.coreOptions.chains) === null || _this$coreOptions$cha === void 0 ? void 0 : _this$coreOptions$cha.map((x3) => x3.chainNamespace)) || [])];
    });
    this.options = _objectSpread2({}, options2);
    if (!this.options.uiConfig) this.options.uiConfig = {};
    if (this.options.modalConfig) this.modalConfig = this.options.modalConfig;
    log.info("modalConfig", this.modalConfig);
  }
  async init(options2) {
    const startTime = Date.now();
    this.analytics.init();
    this.analytics.identify(this.options.clientId, {
      web3auth_client_id: this.options.clientId,
      web3auth_network: this.options.web3AuthNetwork
    });
    this.analytics.setGlobalProperties({
      dapp_url: window.location.origin,
      sdk_name: ANALYTICS_SDK_TYPE.WEB_MODAL,
      sdk_version: sdkVersion,
      // Required for organization analytics
      web3auth_client_id: this.options.clientId,
      web3auth_network: this.options.web3AuthNetwork
    });
    let trackData = {};
    try {
      var _authConnector$authIn, _this$coreOptions$uiC;
      const {
        signal
      } = options2 || {};
      super.checkInitRequirements();
      const {
        projectConfig,
        walletRegistry
      } = await this.getProjectAndWalletConfig();
      this.initUIConfig(projectConfig);
      super.initAccountAbstractionConfig(projectConfig);
      super.initChainsConfig(projectConfig);
      super.initCachedConnectorAndChainId();
      super.initWalletServicesConfig(projectConfig);
      this.analytics.setGlobalProperties({
        team_id: projectConfig.teamId
      });
      trackData = this.getInitializationTrackData();
      const {
        filteredWalletRegistry,
        disabledExternalWallets
      } = this.filterWalletRegistry(walletRegistry, projectConfig);
      this.loginModal = new LoginModal(_objectSpread2(_objectSpread2({}, this.options.uiConfig), {}, {
        connectorListener: this,
        web3authClientId: this.options.clientId,
        web3authNetwork: this.options.web3AuthNetwork,
        authBuildEnv: this.options.authBuildEnv,
        chainNamespaces: this.getChainNamespaces(),
        walletRegistry: filteredWalletRegistry,
        analytics: this.analytics
      }), {
        onInitExternalWallets: this.onInitExternalWallets,
        onSocialLogin: this.onSocialLogin,
        onExternalWalletLogin: this.onExternalWalletLogin,
        onModalVisibility: this.onModalVisibility
      });
      await withAbort(() => this.loginModal.initModal(), signal);
      await withAbort(() => this.setupCommonJRPCProvider(), signal);
      this.on(CONNECTOR_EVENTS.CONNECTORS_UPDATED, ({
        connectors: newConnectors
      }) => {
        const onAbortHandler = () => {
          var _this$connectors;
          log.debug("init aborted");
          if (((_this$connectors = this.connectors) === null || _this$connectors === void 0 ? void 0 : _this$connectors.length) > 0) {
            super.cleanup();
          }
        };
        withAbort(() => this.initConnectors({
          connectors: newConnectors,
          projectConfig,
          disabledExternalWallets
        }), signal, onAbortHandler);
      });
      await withAbort(() => super.loadConnectors({
        projectConfig,
        modalMode: true
      }), signal);
      await withAbort(() => super.initPlugins(), signal);
      const authConnector2 = this.getConnector(WALLET_CONNECTORS.AUTH);
      trackData = _objectSpread2(_objectSpread2({}, trackData), {}, {
        connectors: this.connectors.map((connector) => connector.name),
        plugins: Object.keys(this.plugins),
        auth_ux_mode: (authConnector2 === null || authConnector2 === void 0 || (_authConnector$authIn = authConnector2.authInstance) === null || _authConnector$authIn === void 0 || (_authConnector$authIn = _authConnector$authIn.options) === null || _authConnector$authIn === void 0 ? void 0 : _authConnector$authIn.uxMode) || ((_this$coreOptions$uiC = this.coreOptions.uiConfig) === null || _this$coreOptions$uiC === void 0 ? void 0 : _this$coreOptions$uiC.uxMode)
      });
      this.analytics.track(ANALYTICS_EVENTS.SDK_INITIALIZATION_COMPLETED, _objectSpread2(_objectSpread2({}, trackData), {}, {
        duration: Date.now() - startTime
      }));
    } catch (error) {
      if (error instanceof DOMException && error.name === "AbortError") return;
      this.analytics.track(ANALYTICS_EVENTS.SDK_INITIALIZATION_FAILED, _objectSpread2(_objectSpread2(_objectSpread2({}, trackData), getErrorAnalyticsProperties2(error)), {}, {
        duration: Date.now() - startTime
      }));
      log.error("Failed to initialize modal", error);
      throw error;
    }
  }
  async connect() {
    if (!this.loginModal) throw WalletInitializationError.notReady("Login modal is not initialized");
    if (this.connectedConnectorName && this.status === CONNECTOR_STATUS.CONNECTED && this.provider) return this.provider;
    this.loginModal.open();
    return new Promise((resolve, reject) => {
      const handleConnected = () => {
        this.removeListener(CONNECTOR_EVENTS.ERRORED, handleError);
        this.removeListener(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, handleVisibility);
        return resolve(this.provider);
      };
      const handleError = (err) => {
        this.removeListener(CONNECTOR_EVENTS.CONNECTED, handleConnected);
        this.removeListener(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, handleVisibility);
        return reject(err);
      };
      const handleVisibility = (visibility) => {
        if (!visibility && this.status !== CONNECTOR_STATUS.CONNECTED) {
          this.removeListener(CONNECTOR_EVENTS.CONNECTED, handleConnected);
          this.removeListener(CONNECTOR_EVENTS.ERRORED, handleError);
          return reject(new Error("User closed the modal"));
        }
      };
      this.once(CONNECTOR_EVENTS.CONNECTED, handleConnected);
      this.once(CONNECTOR_EVENTS.ERRORED, handleError);
      this.once(LOGIN_MODAL_EVENTS.MODAL_VISIBILITY, handleVisibility);
    });
  }
  initUIConfig(projectConfig) {
    super.initUIConfig(projectConfig);
    this.options.uiConfig = (0, import_deepmerge5.default)(cloneDeep2(projectConfig.whitelabel || {}), this.options.uiConfig || {});
    if (!this.options.uiConfig.defaultLanguage) this.options.uiConfig.defaultLanguage = getUserLanguage(this.options.uiConfig.defaultLanguage);
    if (!this.options.uiConfig.mode) this.options.uiConfig.mode = "light";
    this.options.uiConfig = (0, import_deepmerge5.default)(projectConfig.loginModal || {}, this.options.uiConfig, {
      arrayMerge: (_3, sourceArray) => sourceArray
    });
    const defaultAuthConnections = projectConfig.embeddedWalletAuth.filter((x3) => x3.isDefault).map((x3) => x3.authConnection);
    const mergedAuthConnections = [...this.options.uiConfig.loginMethodsOrder || [], ...defaultAuthConnections];
    const loginMethodsOrder = [];
    const authConnectionSet = /* @__PURE__ */ new Set();
    for (const authConnection of mergedAuthConnections) {
      if (authConnectionSet.has(authConnection)) continue;
      authConnectionSet.add(authConnection);
      loginMethodsOrder.push(authConnection);
    }
    this.options.uiConfig.loginMethodsOrder = loginMethodsOrder;
  }
  getInitializationTrackData() {
    var _this$modalConfig, _this$modalConfig2, _this$modalConfig3, _this$options$uiConfi, _this$options$uiConfi2, _this$options$uiConfi3, _this$options$uiConfi4, _this$options$uiConfi5, _this$options$uiConfi6, _this$options$uiConfi7, _this$options$uiConfi8, _this$options$uiConfi9, _this$options$uiConfi0, _this$options$uiConfi1, _this$options$uiConfi10, _this$options$uiConfi11, _this$options$uiConfi12;
    return _objectSpread2(_objectSpread2({}, super.getInitializationTrackData()), {}, {
      modal_hide_wallet_discovery: (_this$modalConfig = this.modalConfig) === null || _this$modalConfig === void 0 ? void 0 : _this$modalConfig.hideWalletDiscovery,
      modal_connectors: Object.keys(((_this$modalConfig2 = this.modalConfig) === null || _this$modalConfig2 === void 0 ? void 0 : _this$modalConfig2.connectors) || {}),
      modal_auth_connector_login_methods: Object.keys(((_this$modalConfig3 = this.modalConfig) === null || _this$modalConfig3 === void 0 || (_this$modalConfig3 = _this$modalConfig3.connectors) === null || _this$modalConfig3 === void 0 || (_this$modalConfig3 = _this$modalConfig3[WALLET_CONNECTORS.AUTH]) === null || _this$modalConfig3 === void 0 ? void 0 : _this$modalConfig3.loginMethods) || {}),
      // UI config
      ui_login_methods_order: (_this$options$uiConfi = this.options.uiConfig) === null || _this$options$uiConfi === void 0 ? void 0 : _this$options$uiConfi.loginMethodsOrder,
      ui_modal_z_index: (_this$options$uiConfi2 = this.options.uiConfig) === null || _this$options$uiConfi2 === void 0 ? void 0 : _this$options$uiConfi2.modalZIndex,
      ui_display_errors_on_modal: (_this$options$uiConfi3 = this.options.uiConfig) === null || _this$options$uiConfi3 === void 0 ? void 0 : _this$options$uiConfi3.displayErrorsOnModal,
      ui_login_grid_col: (_this$options$uiConfi4 = this.options.uiConfig) === null || _this$options$uiConfi4 === void 0 ? void 0 : _this$options$uiConfi4.loginGridCol,
      ui_primary_button: (_this$options$uiConfi5 = this.options.uiConfig) === null || _this$options$uiConfi5 === void 0 ? void 0 : _this$options$uiConfi5.primaryButton,
      ui_modal_widget_type: (_this$options$uiConfi6 = this.options.uiConfig) === null || _this$options$uiConfi6 === void 0 ? void 0 : _this$options$uiConfi6.widgetType,
      ui_modal_target_id_used: Boolean((_this$options$uiConfi7 = this.options.uiConfig) === null || _this$options$uiConfi7 === void 0 ? void 0 : _this$options$uiConfi7.targetId),
      ui_modal_logo_alignment: (_this$options$uiConfi8 = this.options.uiConfig) === null || _this$options$uiConfi8 === void 0 ? void 0 : _this$options$uiConfi8.logoAlignment,
      ui_modal_border_radius_type: (_this$options$uiConfi9 = this.options.uiConfig) === null || _this$options$uiConfi9 === void 0 ? void 0 : _this$options$uiConfi9.borderRadiusType,
      ui_modal_button_radius_type: (_this$options$uiConfi0 = this.options.uiConfig) === null || _this$options$uiConfi0 === void 0 ? void 0 : _this$options$uiConfi0.buttonRadiusType,
      ui_modal_sign_in_methods: (_this$options$uiConfi1 = this.options.uiConfig) === null || _this$options$uiConfi1 === void 0 ? void 0 : _this$options$uiConfi1.signInMethods,
      ui_modal_add_previous_login_hint: (_this$options$uiConfi10 = this.options.uiConfig) === null || _this$options$uiConfi10 === void 0 ? void 0 : _this$options$uiConfi10.addPreviousLoginHint,
      ui_modal_display_installed_external_wallets: (_this$options$uiConfi11 = this.options.uiConfig) === null || _this$options$uiConfi11 === void 0 ? void 0 : _this$options$uiConfi11.displayInstalledExternalWallets,
      ui_modal_display_external_wallets_count: (_this$options$uiConfi12 = this.options.uiConfig) === null || _this$options$uiConfi12 === void 0 ? void 0 : _this$options$uiConfi12.displayExternalWalletsCount
    });
  }
  filterWalletRegistry(walletRegistry, projectConfig) {
    const {
      disableAllRecommendedWallets,
      disableAllOtherWallets,
      disabledWallets
    } = projectConfig.externalWalletAuth || {};
    const disabledExternalWallets = new Set(disabledWallets || []);
    if (disableAllRecommendedWallets) {
      Object.keys(walletRegistry.default).forEach((wallet) => disabledExternalWallets.add(wallet));
    }
    if (disableAllOtherWallets) {
      Object.keys(walletRegistry.others).forEach((wallet) => disabledExternalWallets.add(wallet));
    }
    disabledExternalWallets.delete(WALLET_CONNECTORS.METAMASK);
    const filteredWalletRegistry = cloneDeep2(walletRegistry);
    disabledExternalWallets.forEach((wallet) => {
      delete filteredWalletRegistry.default[wallet];
      delete filteredWalletRegistry.others[wallet];
    });
    return {
      disabledExternalWallets,
      filteredWalletRegistry
    };
  }
  async getProjectAndWalletConfig() {
    var _this$options$account, _this$modalConfig4;
    const [projectConfigResult, walletRegistryResult] = await Promise.allSettled([fetchProjectConfig({
      clientId: this.options.clientId,
      web3AuthNetwork: this.options.web3AuthNetwork,
      aaProvider: (_this$options$account = this.options.accountAbstractionConfig) === null || _this$options$account === void 0 ? void 0 : _this$options$account.smartAccountType,
      authBuildEnv: this.options.authBuildEnv
    }), fetchWalletRegistry(walletRegistryUrl)]);
    if (projectConfigResult.status === "rejected") {
      const error = await serializeError(projectConfigResult.reason);
      log.error("Failed to fetch project configurations", error);
      throw WalletInitializationError.notReady("failed to fetch project configurations", error);
    }
    const projectConfig = projectConfigResult.value;
    let walletRegistry = {
      others: {},
      default: {}
    };
    const isExternalWalletEnabled = Boolean(projectConfig.externalWalletAuth);
    if (isExternalWalletEnabled && !((_this$modalConfig4 = this.modalConfig) !== null && _this$modalConfig4 !== void 0 && _this$modalConfig4.hideWalletDiscovery)) {
      if (walletRegistryResult.status === "fulfilled") {
        walletRegistry = walletRegistryResult.value;
      } else {
        log.error("Failed to fetch wallet registry", walletRegistryResult.reason);
      }
    }
    return {
      projectConfig,
      walletRegistry
    };
  }
  async initConnectors({
    connectors,
    projectConfig,
    disabledExternalWallets
  }) {
    const filteredConnectorNames = await this.filterConnectors({
      projectConfig,
      disabledExternalWallets
    });
    const {
      hasInAppConnectors,
      hasExternalConnectors
    } = await this.checkConnectorAvailability(filteredConnectorNames);
    const filteredConnectors = connectors.filter((x3) => filteredConnectorNames.includes(x3.name));
    await this.initInAppAndCachedConnectors(filteredConnectors);
    if (hasExternalConnectors) {
      if (hasInAppConnectors) {
        this.loginModal.initExternalWalletContainer();
        this.initExternalConnectors(filteredConnectors.filter((x3) => x3.type === CONNECTOR_CATEGORY.EXTERNAL && x3.name !== WALLET_CONNECTORS.WALLET_CONNECT_V2), {
          externalWalletsInitialized: false,
          showExternalWalletsOnly: false,
          externalWalletsVisibility: false
        });
      } else {
        await this.initExternalConnectors(filteredConnectors.filter((x3) => x3.type === CONNECTOR_CATEGORY.EXTERNAL), {
          externalWalletsInitialized: true,
          showExternalWalletsOnly: true,
          externalWalletsVisibility: true
        });
      }
    }
    if (this.status === CONNECTOR_STATUS.NOT_READY) {
      this.status = CONNECTOR_STATUS.READY;
      this.emit(CONNECTOR_EVENTS.READY);
    }
  }
  async filterConnectors({
    projectConfig,
    disabledExternalWallets
  }) {
    var _this$modalConfig5;
    const loginMethods = {};
    const embedWalletConfigMap = /* @__PURE__ */ new Map();
    for (const authConnectionConfig of projectConfig.embeddedWalletAuth || []) {
      const {
        isDefault,
        authConnection,
        groupedAuthConnectionId,
        authConnectionId
      } = authConnectionConfig;
      if (isDefault) {
        loginMethods[authConnection] = {
          name: AUTH_PROVIDERS_NAMES[authConnection],
          authConnection,
          authConnectionId,
          groupedAuthConnectionId,
          extraLoginOptions: authConnectionConfig.jwtParameters,
          isDefault: true,
          showOnModal: true
        };
      }
      embedWalletConfigMap.set(groupedAuthConnectionId || authConnectionId, authConnectionConfig);
    }
    const dashboardConnectorConfig = {
      [WALLET_CONNECTORS.AUTH]: {
        label: WALLET_CONNECTORS.AUTH,
        loginMethods
      }
    };
    if ((_this$modalConfig5 = this.modalConfig) !== null && _this$modalConfig5 !== void 0 && (_this$modalConfig5 = _this$modalConfig5.connectors) !== null && _this$modalConfig5 !== void 0 && _this$modalConfig5[WALLET_CONNECTORS.AUTH]) {
      if (!this.modalConfig.connectors[WALLET_CONNECTORS.AUTH].loginMethods) this.modalConfig.connectors[WALLET_CONNECTORS.AUTH].loginMethods = {};
    }
    const authProviders = new Set(AUTH_PROVIDERS);
    Object.keys(this.modalConfig.connectors[WALLET_CONNECTORS.AUTH].loginMethods).forEach((key) => {
      const userConfig = this.modalConfig.connectors[WALLET_CONNECTORS.AUTH].loginMethods[key];
      const {
        authConnectionId,
        groupedAuthConnectionId
      } = userConfig;
      if (!authProviders.has(key)) {
        throw WalletInitializationError.invalidParams(`Invalid auth connection: ${key}`);
      }
      if (groupedAuthConnectionId || authConnectionId) {
        if (!embedWalletConfigMap.has(groupedAuthConnectionId || authConnectionId)) throw WalletInitializationError.invalidParams(`Invalid auth connection config, authConnection: ${key}. Missing AuthConnectionConfig from the dashboard.`);
        const configFromDashboard = embedWalletConfigMap.get(groupedAuthConnectionId || authConnectionId);
        this.modalConfig.connectors[WALLET_CONNECTORS.AUTH].loginMethods[key] = {
          authConnection: configFromDashboard.authConnection,
          authConnectionId: configFromDashboard.authConnectionId,
          groupedAuthConnectionId: configFromDashboard.groupedAuthConnectionId,
          isDefault: configFromDashboard.isDefault || false,
          extraLoginOptions: _objectSpread2(_objectSpread2({}, configFromDashboard.jwtParameters), userConfig.extraLoginOptions)
        };
      }
    });
    this.modalConfig.connectors = (0, import_deepmerge5.default)(dashboardConnectorConfig, cloneDeep2(this.modalConfig.connectors || {}));
    const allConnectorNames = [.../* @__PURE__ */ new Set([...Object.keys(this.modalConfig.connectors || {}), ...this.connectors.map((connector) => connector.name)])];
    const connectorNames = allConnectorNames.map((connectorName) => {
      var _this$modalConfig6, _this$modalConfig$con, _this$modalConfig$con2;
      const defaultConnectorConfig = {
        label: CONNECTOR_NAMES[connectorName] || connectorName.split("-").map(capitalizeFirstLetter).join(" "),
        showOnModal: true
      };
      this.modalConfig.connectors[connectorName] = _objectSpread2(_objectSpread2({}, defaultConnectorConfig), ((_this$modalConfig6 = this.modalConfig) === null || _this$modalConfig6 === void 0 || (_this$modalConfig6 = _this$modalConfig6.connectors) === null || _this$modalConfig6 === void 0 ? void 0 : _this$modalConfig6[connectorName]) || {});
      const connector = this.getConnector(connectorName);
      log.debug("connector config", connectorName, (_this$modalConfig$con = this.modalConfig.connectors) === null || _this$modalConfig$con === void 0 || (_this$modalConfig$con = _this$modalConfig$con[connectorName]) === null || _this$modalConfig$con === void 0 ? void 0 : _this$modalConfig$con.showOnModal, connector);
      const connectorConfig = (_this$modalConfig$con2 = this.modalConfig.connectors) === null || _this$modalConfig$con2 === void 0 ? void 0 : _this$modalConfig$con2[connectorName];
      if (!connector) {
        if (connectorConfig.showOnModal) throw WalletInitializationError.invalidParams(`Connector ${connectorName} is not configured`);
        return;
      }
      if (!connectorConfig.showOnModal) return;
      const isExternalWalletEnabled = Boolean(projectConfig.externalWalletAuth);
      if (connector.type === CONNECTOR_CATEGORY.EXTERNAL && connector.name !== WALLET_CONNECTORS.METAMASK) {
        if (!isExternalWalletEnabled) return;
        if (disabledExternalWallets.has(connectorName)) return;
      }
      if (connectorName === WALLET_CONNECTORS.WALLET_CONNECT_V2) {
        var _this$modalConfig7;
        if (!isExternalWalletEnabled) return;
        if ((_this$modalConfig7 = this.modalConfig) !== null && _this$modalConfig7 !== void 0 && _this$modalConfig7.hideWalletDiscovery) return;
      }
      this.modalConfig.connectors[connectorName] = connectorConfig;
      return connectorName;
    });
    return connectorNames.filter((name) => name !== void 0);
  }
  async checkConnectorAvailability(connectorNames) {
    const hasInAppConnectors = this.connectors.some((connector) => {
      var _this$modalConfig$con3, _this$modalConfig$con4;
      if (connector.type !== CONNECTOR_CATEGORY.IN_APP) return false;
      if (((_this$modalConfig$con3 = this.modalConfig.connectors) === null || _this$modalConfig$con3 === void 0 || (_this$modalConfig$con3 = _this$modalConfig$con3[connector.name]) === null || _this$modalConfig$con3 === void 0 ? void 0 : _this$modalConfig$con3.showOnModal) !== true) return false;
      if (!((_this$modalConfig$con4 = this.modalConfig.connectors) !== null && _this$modalConfig$con4 !== void 0 && (_this$modalConfig$con4 = _this$modalConfig$con4[connector.name]) !== null && _this$modalConfig$con4 !== void 0 && _this$modalConfig$con4.loginMethods)) return true;
      if (Object.values(this.modalConfig.connectors[connector.name].loginMethods).some((method) => method.showOnModal)) return true;
      return false;
    });
    log.debug(hasInAppConnectors, this.connectors, connectorNames, "hasInAppWallets");
    const hasExternalConnectors = connectorNames.some((connectorName) => {
      var _this$getConnector, _this$modalConfig$con5;
      if (connectorName === WALLET_CONNECTORS.WALLET_CONNECT_V2) return true;
      return ((_this$getConnector = this.getConnector(connectorName)) === null || _this$getConnector === void 0 ? void 0 : _this$getConnector.type) === CONNECTOR_CATEGORY.EXTERNAL && ((_this$modalConfig$con5 = this.modalConfig.connectors) === null || _this$modalConfig$con5 === void 0 || (_this$modalConfig$con5 = _this$modalConfig$con5[connectorName]) === null || _this$modalConfig$con5 === void 0 ? void 0 : _this$modalConfig$con5.showOnModal);
    });
    return {
      hasInAppConnectors,
      hasExternalConnectors
    };
  }
  async initInAppAndCachedConnectors(connectors) {
    await Promise.all(connectors.map(async (connector) => {
      const connectorName = connector.name;
      try {
        if (connector.status !== CONNECTOR_STATUS.NOT_READY) return;
        if (this.cachedConnector !== connectorName && connector.type === CONNECTOR_CATEGORY.EXTERNAL) return;
        this.subscribeToConnectorEvents(connector);
        const initialChain = this.getInitialChainIdForConnector(connector);
        const autoConnect = super.checkIfAutoConnect(connector);
        await connector.init({
          autoConnect,
          chainId: initialChain.chainId
        });
        if (connector.type === CONNECTOR_CATEGORY.IN_APP) {
          var _this$modalConfig$con6, _this$options$uiConfi13, _this$options$uiConfi14, _this$options$uiConfi15;
          log.info("connectorInitResults", connectorName);
          const loginMethods = ((_this$modalConfig$con6 = this.modalConfig.connectors[connectorName]) === null || _this$modalConfig$con6 === void 0 ? void 0 : _this$modalConfig$con6.loginMethods) || {};
          this.loginModal.addSocialLogins(connectorName, loginMethods, ((_this$options$uiConfi13 = this.options.uiConfig) === null || _this$options$uiConfi13 === void 0 ? void 0 : _this$options$uiConfi13.loginMethodsOrder) || AUTH_PROVIDERS, _objectSpread2(_objectSpread2({}, this.options.uiConfig), {}, {
            loginGridCol: ((_this$options$uiConfi14 = this.options.uiConfig) === null || _this$options$uiConfi14 === void 0 ? void 0 : _this$options$uiConfi14.loginGridCol) || 3,
            primaryButton: ((_this$options$uiConfi15 = this.options.uiConfig) === null || _this$options$uiConfi15 === void 0 ? void 0 : _this$options$uiConfi15.primaryButton) || "socialLogin"
          }));
        }
      } catch (error) {
        log.error(error, "error while initializing connector ", connectorName);
      }
    }));
  }
  async initExternalConnectors(externalConnectors, options2) {
    const connectorsConfig = {};
    const connectorChainNamespaceMap = {};
    externalConnectors.forEach(async (connector) => {
      const connectorName = connector.name;
      log.debug("init external wallet", this.cachedConnector, connectorName, connector.status);
      if (!connectorChainNamespaceMap[connectorName]) connectorChainNamespaceMap[connectorName] = /* @__PURE__ */ new Set();
      if (connector.connectorNamespace === CONNECTOR_NAMESPACES.MULTICHAIN) {
        this.getChainNamespaces().forEach((x3) => connectorChainNamespaceMap[connectorName].add(x3));
      } else {
        connectorChainNamespaceMap[connectorName].add(connector.connectorNamespace);
      }
      if (connector.status === CONNECTOR_STATUS.NOT_READY && this.cachedConnector !== connectorName) {
        try {
          this.subscribeToConnectorEvents(connector);
          const initialChain = this.getInitialChainIdForConnector(connector);
          await connector.init({
            autoConnect: this.cachedConnector === connectorName,
            chainId: initialChain.chainId
          });
        } catch (error) {
          log.error(error, "error while initializing connector", connectorName);
        }
      }
      if ([CONNECTOR_STATUS.NOT_READY, CONNECTOR_STATUS.READY, CONNECTOR_STATUS.CONNECTING, CONNECTOR_STATUS.CONNECTED].includes(connector.status)) {
        const connectorModalConfig = this.modalConfig.connectors[connectorName];
        connectorsConfig[connectorName] = _objectSpread2(_objectSpread2({}, connectorModalConfig), {}, {
          isInjected: connector.isInjected,
          icon: connector.icon,
          chainNamespaces: Array.from(connectorChainNamespaceMap[connectorName])
        });
        this.loginModal.addWalletLogins(connectorsConfig, {
          showExternalWalletsOnly: !!options2.showExternalWalletsOnly,
          externalWalletsVisibility: !!options2.externalWalletsVisibility,
          externalWalletsInitialized: !!options2.externalWalletsInitialized
        });
      }
    });
  }
};

export {
  cookieToWeb3AuthState,
  authConnector,
  metaMaskConnector,
  PLUGIN_NAMESPACES,
  PLUGIN_STATUS,
  PLUGIN_EVENTS,
  EVM_PLUGINS,
  SOLANA_PLUGINS,
  WALLET_PLUGINS,
  WalletServicesPluginError,
  NFTCheckoutPluginError,
  walletServicesPlugin,
  Web3AuthNoModal,
  Web3AuthContextKey,
  PROVIDER_EVENTS,
  NFTCheckoutEmbed,
  nftCheckoutPlugin,
  LegacyGasAPIEndpoint,
  EIP1559APIEndpoint,
  TRANSACTION_ENVELOPE_TYPES,
  TRANSACTION_TYPES,
  GAS_ESTIMATE_TYPES,
  normalizeGWEIDecimalNumbers,
  fetchEip1159GasEstimates,
  fetchLegacyGasPriceEstimates,
  validateAddress,
  validateTypedSignMessageDataV4,
  TransactionFormatter,
  SignTypedDataVersion,
  SolanaWallet,
  version2 as version,
  defaultConnectorsModalConfig,
  walletRegistryUrl,
  require_classnames,
  require_dist2 as require_dist,
  Web3Auth
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=chunk-D3TJF7RS.js.map
