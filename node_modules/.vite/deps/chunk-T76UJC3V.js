import {
  BaseProvider
} from "./chunk-JBLZOY4W.js";
import {
  JRPCEngine,
  createAsyncMiddleware,
  createFetchMiddleware,
  createScaffoldMiddleware,
  mergeMiddleware,
  providerErrors,
  providerFromEngine
} from "./chunk-B2N4C5QO.js";
import {
  _defineProperty
} from "./chunk-Z2JNO6L5.js";

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/base-provider/jrpcClient.js
function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "chainId") {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createJsonRpcClient(providerConfig) {
  const {
    chainId,
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = createFetchMiddleware({
    rpcTarget
  });
  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/base-provider/CommonJRPCProvider.js
var _CommonJRPCProvider;
var CommonJRPCProvider = class extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
  }
  async setupProvider(chainId) {
    const chain = this.getChain(chainId);
    if (!chain) throw providerErrors.custom({
      message: "Chain not found",
      code: 4902
    });
    const {
      networkMiddleware
    } = createJsonRpcClient(chain);
    const engine = new JRPCEngine();
    engine.push(networkMiddleware);
    const provider = providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    this.emit("chainChanged", chainId);
    this.emit("connect", {
      chainId
    });
    this.update({
      chainId
    });
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const newChainId = params.chainId;
    if (this.chainId === newChainId) return;
    this.update({
      chainId: "loading"
    });
    await this.setupProvider(newChainId);
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
  lookupNetwork() {
    throw new Error("Method not implemented.");
  }
};
_CommonJRPCProvider = CommonJRPCProvider;
_defineProperty(CommonJRPCProvider, "getProviderInstance", async (params) => {
  const providerFactory = new _CommonJRPCProvider({
    config: {
      chain: params.chain,
      chains: params.chains
    }
  });
  const {
    chainId
  } = params.chain;
  await providerFactory.setupProvider(chainId);
  return providerFactory;
});

// node_modules/@web3auth/no-modal/dist/lib.esm/providers/base-provider/commonPrivateKeyProvider.js
var _CommonPrivateKeyProvider;
var CommonPrivateKeyProvider = class extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "_providerEngineProxy", null);
  }
  get provider() {
    return this._providerEngineProxy;
  }
  set provider(_) {
    throw new Error("Method not implemented.");
  }
  async setupProvider(privKey) {
    const privKeyMiddleware = this.getPrivKeyMiddleware(privKey);
    const engine = new JRPCEngine();
    engine.push(privKeyMiddleware);
    const provider = providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
  }
  async switchChain(_) {
    return Promise.resolve();
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
  async lookupNetwork() {
    return Promise.resolve("");
  }
  getPrivKeyMiddleware(privKey) {
    const middleware = {
      getPrivatekey: async () => {
        if (!this.config.keyExportEnabled) throw new Error("Exporting private key is disabled. Please enable it in the provider config");
        return privKey;
      }
    };
    return this.createPrivKeyMiddleware(middleware);
  }
  createPrivKeyMiddleware({
    getPrivatekey
  }) {
    async function getPrivatekeyHandler(_, res) {
      try {
        res.result = await getPrivatekey();
      } catch (error) {
        res.error = error instanceof Error ? error.message : error;
      }
    }
    return createScaffoldMiddleware({
      private_key: createAsyncMiddleware(getPrivatekeyHandler)
    });
  }
};
_CommonPrivateKeyProvider = CommonPrivateKeyProvider;
_defineProperty(CommonPrivateKeyProvider, "getProviderInstance", async (params) => {
  const providerFactory = new _CommonPrivateKeyProvider({
    config: {
      chain: params.chain,
      chains: params.chains
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});

export {
  CommonJRPCProvider,
  CommonPrivateKeyProvider
};
//# sourceMappingURL=chunk-T76UJC3V.js.map
